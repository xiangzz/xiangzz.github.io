<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Javaå¹¶å‘ç¼–ç¨‹(JUC)</title>
    <link rel="stylesheet" href="./css/style.css">
    <link rel="stylesheet" href="../prism/prism.css">
</head>
<body>

    <main id="presentation">
        <!-- Slide 1: Title -->
        <section class="slide title-slide active">
            <h1>Javaå¹¶å‘ç¼–ç¨‹(JUC)</h1>
            <p>é¢å‘å¯¹è±¡ç¨‹åºè®¾è®¡ï¼ˆJavaï¼‰</p>
            <strong>æŒæ¡å¹¶å‘ç¼–ç¨‹å·¥å…·ï¼Œæå‡ç¨‹åºæ€§èƒ½å’Œå“åº”èƒ½åŠ›</strong>
        </section>

        <!-- Slide 2: JUC Introduction -->
        <section class="slide">
            <div class="slide-content">
                <h2>ä»€ä¹ˆæ˜¯ JUCï¼Ÿ</h2>
                <p><code>java.util.concurrent</code> ç®€ç§° JUCï¼Œæ˜¯ Java 5 å¼•å…¥çš„å¹¶å‘å·¥å…·åŒ…ã€‚å®ƒæä¾›äº†ä¸€å¥—å¼ºå¤§çš„å¹¶å‘ç¼–ç¨‹å·¥å…·ï¼Œå¤§å¤§ç®€åŒ–äº†å¤šçº¿ç¨‹å¼€å‘ã€‚</p>

                <h3>ğŸ¯ ä¸ºä»€ä¹ˆéœ€è¦å¹¶å‘ç¼–ç¨‹ï¼Ÿ</h3>
                <ul>
                    <li><strong>æå‡æ€§èƒ½ï¼š</strong>å……åˆ†åˆ©ç”¨å¤šæ ¸CPUçš„å¤„ç†èƒ½åŠ›</li>
                    <li><strong>æ”¹å–„å“åº”ï¼š</strong>é¿å…è€—æ—¶ä»»åŠ¡é˜»å¡ç”¨æˆ·ç•Œé¢</li>
                    <li><strong>æé«˜ååï¼š</strong>åŒæ—¶å¤„ç†å¤šä¸ªè¯·æ±‚æˆ–ä»»åŠ¡</li>
                </ul>

                <h3>ğŸ“¦ JUC æ ¸å¿ƒç»„ä»¶æ¦‚è§ˆ</h3>
                <pre><code class="language-java">// JUC åŒ…çš„ä¸»è¦ç»“æ„
java.util.concurrent           // æ ¸å¿ƒå¹¶å‘å·¥å…·
â”œâ”€â”€ Executor                    // æ‰§è¡Œå™¨æ¡†æ¶
â”œâ”€â”€ ExecutorService             // çº¿ç¨‹æ± æ¥å£
â”œâ”€â”€ ThreadPoolExecutor          // çº¿ç¨‹æ± å®ç°
â”œâ”€â”€ Callable/Volatile           // å¼‚æ­¥ä»»åŠ¡å’ŒåŸå­æ“ä½œ
â”œâ”€â”€ CountDownLatch/CyclicBarrier// åŒæ­¥å·¥å…·
â”œâ”€â”€ Semaphore                   // ä¿¡å·é‡
â”œâ”€â”€ Lock                        // æ˜¾å¼é”
â”œâ”€â”€ Concurrent collections      // å¹¶å‘é›†åˆ
â””â”€â”€ Atomic classes              // åŸå­ç±»</code></pre>
                <p class="conclusion">JUC è®©å¹¶å‘ç¼–ç¨‹ä»"æ‰‹å·¥ä½œåŠ"æ—¶ä»£è¿›å…¥äº†"å·¥ä¸šåŒ–ç”Ÿäº§"æ—¶ä»£ï¼Œå¤§å¤§é™ä½äº†å¹¶å‘ç¼–ç¨‹çš„å¤æ‚åº¦ã€‚</p>
            </div>
        </section>

        <!-- Slide 3: Traditional Threading vs JUC -->
        <section class="slide">
            <div class="slide-content">
                <h2>ä¼ ç»Ÿçº¿ç¨‹ vs JUCï¼šä¸ºä»€ä¹ˆé€‰æ‹© JUCï¼Ÿ</h2>

                <h3>âŒ ä¼ ç»Ÿæ–¹å¼çš„é—®é¢˜</h3>
                <pre><code class="language-java">// ä¼ ç»Ÿæ–¹å¼ï¼šæ‰‹åŠ¨ç®¡ç†çº¿ç¨‹
public class TraditionalApproach {
    public static void main(String[] args) {
        // é—®é¢˜1ï¼šé¢‘ç¹åˆ›å»ºé”€æ¯çº¿ç¨‹ï¼Œå¼€é”€å¤§
        Thread t1 = new Thread(() -> {
            System.out.println("ä»»åŠ¡1æ‰§è¡Œä¸­...");
        });
        t1.start();

        // é—®é¢˜2ï¼šæ— æ³•æ§åˆ¶å¹¶å‘æ•°é‡
        for (int i = 0; i < 100; i++) {
            new Thread(() -> {
                // å¯èƒ½åˆ›å»ºè¿‡å¤šçº¿ç¨‹ï¼Œå¯¼è‡´ç³»ç»Ÿå´©æºƒ
                heavyTask();
            }).start();
        }

        // é—®é¢˜3ï¼šæ— æ³•è·å–ä»»åŠ¡æ‰§è¡Œç»“æœ
        // é—®é¢˜4ï¼šå¼‚å¸¸å¤„ç†å¤æ‚
    }
}</code></pre>

                <h3>âœ… JUC çš„ä¼˜åŠ¿</h3>
                <pre><code class="language-java">// JUC æ–¹å¼ï¼šä½¿ç”¨çº¿ç¨‹æ± 
public class JUCApproach {
    public static void main(String[] args) {
        // ä¼˜åŠ¿1ï¼šçº¿ç¨‹å¤ç”¨ï¼Œé¿å…é¢‘ç¹åˆ›å»ºé”€æ¯
        ExecutorService executor = Executors.newFixedThreadPool(10);

        // ä¼˜åŠ¿2ï¼šæ§åˆ¶å¹¶å‘æ•°é‡
        for (int i = 0; i < 100; i++) {
            executor.submit(() -> heavyTask());
        }

        // ä¼˜åŠ¿3ï¼šå¯ä»¥è·å–æ‰§è¡Œç»“æœ
        Future<String> future = executor.submit(() -> "ä»»åŠ¡å®Œæˆ");

        // ä¼˜åŠ¿4ï¼šä¼˜é›…å…³é—­
        executor.shutdown();
    }
}</code></pre>
                <p class="conclusion">JUC ä¸ä»…è§£å†³äº†ä¼ ç»Ÿæ–¹å¼çš„é—®é¢˜ï¼Œè¿˜æä¾›äº†æ›´ä¸°å¯Œçš„åŠŸèƒ½å’Œæ›´å¥½çš„æ€§èƒ½ã€‚</p>
            </div>
        </section>

        <!-- Slide 4: JUC é«˜çº§ç‰¹æ€§æ¦‚è§ˆ -->
        <section class="slide">
            <div class="slide-content">
                <h2>JUC é«˜çº§ç‰¹æ€§æ¦‚è§ˆ</h2>
                <p>åœ¨æŒæ¡å¤šçº¿ç¨‹åŸºç¡€åï¼ŒJUC æä¾›äº†æ›´å¼ºå¤§çš„é«˜çº§ç‰¹æ€§æ¥è§£å†³å¤æ‚çš„å¹¶å‘é—®é¢˜ã€‚</p>

                <h3>ğŸš€ JUC æ ¸å¿ƒä¼˜åŠ¿</h3>
                <div class="media-block">
                    <div class="media-block__text">
                        <h4>ç›¸æ¯”ä¼ ç»Ÿå¤šçº¿ç¨‹æ–¹å¼ï¼š</h4>
                        <ul>
                            <li><strong>æ€§èƒ½å“è¶Šï¼š</strong>CAS æ— é”ç®—æ³•ã€åˆ†æ®µé”ã€çº¿ç¨‹æ± ä¼˜åŒ–</li>
                            <li><strong>åŠŸèƒ½ä¸°å¯Œï¼š</strong>å¼‚æ­¥ç¼–ç¨‹ã€å¹¶è¡Œè®¡ç®—ã€å¤æ‚åŒæ­¥å·¥å…·</li>
                            <li><strong>æ˜“ç”¨æ€§é«˜ï¼š</strong>ä¸°å¯Œçš„APIã€å®Œå–„çš„å¼‚å¸¸å¤„ç†ã€å†…ç½®ç›‘æ§</li>
                            <li><strong>å¯æ‰©å±•ï¼š</strong>æ¨¡å—åŒ–è®¾è®¡ï¼Œæ”¯æŒå¤æ‚ä¸šåŠ¡åœºæ™¯</li>
                        </ul>
                    </div>
                    <div class="media-block__visual">
                        <h4>å­¦ä¹ è·¯å¾„ï¼š</h4>
                        <ol>
                            <li>åŸºç¡€å¤šçº¿ç¨‹ (å·²æŒæ¡) â†’</li>
                            <li>JUC å¼‚æ­¥ç¼–ç¨‹ â†’</li>
                            <li>JUC æ— é”ç¼–ç¨‹ â†’</li>
                            <li>JUC æ€§èƒ½ä¼˜åŒ– â†’</li>
                            <li>å®æˆ˜åº”ç”¨æ¡ˆä¾‹</li>
                        </ol>
                    </div>
                </div>

                <h3>ğŸ“¦ JUC é«˜çº§ç‰¹æ€§å›¾è°±</h3>
                <pre><code class="language-java">JUC é«˜çº§ç‰¹æ€§ä½“ç³»
â”œâ”€â”€ å¼‚æ­¥ç¼–ç¨‹ (Async Programming)
â”‚   â”œâ”€â”€ CompletableFuture - é“¾å¼å¼‚æ­¥ä»»åŠ¡
â”‚   â”œâ”€â”€ CompletionService - ä»»åŠ¡å®ŒæˆæœåŠ¡
â”‚   â””â”€â”€ è‡ªå®šä¹‰å¼‚æ­¥æ‰§è¡Œå™¨
â”œâ”€â”€ æ— é”ç¼–ç¨‹ (Lock-Free Programming)
â”‚   â”œâ”€â”€ CAS åŸå­æ“ä½œ
â”‚   â”œâ”€â”€ é«˜æ€§èƒ½åŸå­ç±» (LongAdder, LongAccumulator)
â”‚   â””â”€â”€ åŸå­å¼•ç”¨å’Œå­—æ®µæ›´æ–°å™¨
â”œâ”€â”€ é«˜çº§åŒæ­¥å·¥å…· (Advanced Synchronizers)
â”‚   â”œâ”€â”€ CountDownLatch - å€’è®¡æ—¶é—¨é—©
â”‚   â”œâ”€â”€ CyclicBarrier - å¾ªç¯æ …æ 
â”‚   â”œâ”€â”€ Phaser - é˜¶æ®µåŒæ­¥å™¨
â”‚   â””â”€â”€ Exchanger - çº¿ç¨‹é—´æ•°æ®äº¤æ¢
â”œâ”€â”€ æ€§èƒ½ä¼˜åŒ– (Performance Optimization)
â”‚   â”œâ”€â”€ çº¿ç¨‹æ± è°ƒä¼˜ä¸ç›‘æ§
â”‚   â”œâ”€â”€ å¹¶å‘é›†åˆæ€§èƒ½ä¼˜åŒ–
â”‚   â””â”€â”€ CPU vs IO å¯†é›†å‹é…ç½®
â””â”€â”€ å®æˆ˜åº”ç”¨ (Practical Applications)
    â”œâ”€â”€ ç”µå•†ç§’æ€ç³»ç»Ÿ
    â”œâ”€â”€ å¤§æ•°æ®å¹¶è¡Œå¤„ç†
    â””â”€â”€ åˆ†å¸ƒå¼å¹¶å‘åè°ƒ</code></pre>
                <p class="conclusion">JUC è®©å¹¶å‘ç¼–ç¨‹ä»"èƒ½ç”¨"æå‡åˆ°"å¥½ç”¨"å’Œ"é«˜æ€§èƒ½"ï¼Œæ˜¯é«˜çº§Javaå¼€å‘çš„å¿…å¤‡æŠ€èƒ½ã€‚</p>
            </div>
        </section>

        <!-- Slide 5: CompletableFuture æ·±åº¦ç¼–ç¨‹ (Part 1) -->
        <section class="slide">
            <div class="slide-content">
                <h2>CompletableFuture æ·±åº¦ç¼–ç¨‹ (1)</h2>
                <p>CompletableFuture æ˜¯ Java 8 å¼•å…¥çš„é©å‘½æ€§å¼‚æ­¥ç¼–ç¨‹å·¥å…·ï¼Œæ”¯æŒé“¾å¼è°ƒç”¨å’Œç»„åˆæ“ä½œã€‚</p>

                <h3>ğŸ¯ ä¸ºä»€ä¹ˆéœ€è¦ CompletableFutureï¼Ÿ</h3>
                <div class="media-block">
                    <div class="media-block__text">
                        <h4>ä¼ ç»Ÿ Future çš„å±€é™ï¼š</h4>
                        <ul>
                            <li>åªèƒ½é€šè¿‡ get() é˜»å¡è·å–ç»“æœ</li>
                            <li>æ— æ³•ç»„åˆå¤šä¸ªå¼‚æ­¥æ“ä½œ</li>
                            <li>å¼‚å¸¸å¤„ç†æœºåˆ¶å¤æ‚</li>
                            <li>ä¸æ”¯æŒå›è°ƒæœºåˆ¶</li>
                        </ul>
                    </div>
                    <div class="media-block__visual">
                        <h4>CompletableFuture çš„ä¼˜åŠ¿ï¼š</h4>
                        <ul>
                            <li><strong>éé˜»å¡ï¼š</strong>thenAccept, thenApply ç­‰å›è°ƒ</li>
                            <li><strong>å¯ç»„åˆï¼š</strong>thenCompose, thenCombine é“¾å¼æ“ä½œ</li>
                            <li><strong>å¼‚å¸¸å‹å¥½ï¼š</strong>exceptionally ç»Ÿä¸€å¼‚å¸¸å¤„ç†</li>
                            <li><strong>æ‰¹é‡æ“ä½œï¼š</strong>allOf, anyOf å¤šä»»åŠ¡åè°ƒ</li>
                        </ul>
                    </div>
                </div>

                <h3>âš¡ åˆ›å»º CompletableFuture</h3>
                <pre><code class="language-java">import java.util.concurrent.CompletableFuture;

public class CompletableFutureBasics {
    public static void main(String[] args) {
        // æ–¹å¼1ï¼šåˆ›å»ºå·²å®Œæˆçš„ CompletableFuture
        CompletableFuture<String> completed =
            CompletableFuture.completedFuture("ç«‹å³å®Œæˆ");

        // æ–¹å¼2ï¼šå¼‚æ­¥æ‰§è¡Œ Supplier
        CompletableFuture<String> asyncSupply = CompletableFuture
            .supplyAsync(() -> {
                System.out.println("å¼‚æ­¥æ‰§è¡Œä¸­...");
                return "å¼‚æ­¥ç»“æœ";
            });

        // æ–¹å¼3ï¼šå¼‚æ­¥æ‰§è¡Œ Runnable
        CompletableFuture<Void> asyncRun = CompletableFuture
            .runAsync(() -> {
                System.out.println("å¼‚æ­¥ä»»åŠ¡æ‰§è¡Œ");
            });

        // æ–¹å¼4ï¼šè‡ªå®šä¹‰çº¿ç¨‹æ± æ‰§è¡Œ
        ExecutorService customPool = Executors.newFixedThreadPool(4);
        CompletableFuture<String> customAsync = CompletableFuture
            .supplyAsync(() -> "è‡ªå®šä¹‰çº¿ç¨‹æ± æ‰§è¡Œ", customPool);
    }
}</code></pre>
                <p class="conclusion">CompletableFuture æä¾›äº†ä¸°å¯Œçš„åˆ›å»ºæ–¹å¼ï¼Œé€‚åº”ä¸åŒçš„å¼‚æ­¥åœºæ™¯éœ€æ±‚ã€‚</p>
            </div>
        </section>

        <!-- Slide 6: CompletableFuture æ·±åº¦ç¼–ç¨‹ (Part 2) -->
        <section class="slide">
            <div class="slide-content">
                <h2>CompletableFuture æ·±åº¦ç¼–ç¨‹ (2)</h2>
                <p>CompletableFuture çš„å¼ºå¤§ä¹‹å¤„åœ¨äºå…¶ä¸°å¯Œçš„é“¾å¼è°ƒç”¨å’Œå¼‚å¸¸å¤„ç†æœºåˆ¶ã€‚</p>

                <h3>ğŸ”— é“¾å¼è°ƒç”¨æ–¹æ³•</h3>
                <div class="media-block">
                    <div class="media-block__text">
                        <h4>è½¬æ¢ç±»æ–¹æ³•ï¼š</h4>
                        <ul>
                            <li><strong>thenApply:</strong> æ¥æ”¶ç»“æœï¼Œè¿”å›æ–°ç»“æœ</li>
                            <li><strong>thenAccept:</strong> æ¥æ”¶ç»“æœï¼Œæ‰§è¡Œæ¶ˆè´¹æ“ä½œ</li>
                            <li><strong>thenRun:</strong> ä¸æ¥æ”¶ç»“æœï¼Œæ‰§è¡Œåç»­æ“ä½œ</li>
                        </ul>
                    </div>
                    <div class="media-block__visual">
                        <h4>å¼‚æ­¥ç‰ˆæœ¬ï¼š</h4>
                        <ul>
                            <li><strong>thenApplyAsync:</strong> å¼‚æ­¥æ‰§è¡Œè½¬æ¢</li>
                            <li><strong>thenAcceptAsync:</strong> å¼‚æ­¥æ‰§è¡Œæ¶ˆè´¹</li>
                            <li><strong>thenRunAsync:</strong> å¼‚æ­¥æ‰§è¡Œåç»­æ“ä½œ</li>
                        </ul>
                    </div>
                </div>

                <h3>âš¡ é“¾å¼è°ƒç”¨ç¤ºä¾‹</h3>
                <pre><code class="language-java">public class CompletableFutureChaining {
    public static void main(String[] args) throws Exception {
        CompletableFuture<String> future = CompletableFuture
            .supplyAsync(() -> "ç”¨æˆ·æ•°æ®")

            // è½¬æ¢æ“ä½œ
            .thenApply(data -> {
                System.out.println("1. å¤„ç†: " + data);
                return data + " -> å¢åŠ æƒé™";
            })

            // æ¶ˆè´¹æ“ä½œ
            .thenAccept(processedData -> {
                System.out.println("2. æ¶ˆè´¹: " + processedData);
            })

            // åç»­æ“ä½œ
            .thenRun(() -> {
                System.out.println("3. æ¸…ç†èµ„æº");
            });

        // å¼‚æ­¥ç‰ˆæœ¬ï¼ˆä½¿ç”¨ä¸åŒçº¿ç¨‹æ± ï¼‰
        ExecutorService customPool = Executors.newFixedThreadPool(2);
        CompletableFuture.supplyAsync(() -> "å¼‚æ­¥ä»»åŠ¡", customPool)
            .thenApplyAsync(result -> result + " - å¼‚æ­¥å¤„ç†", customPool)
            .thenAcceptAsync(finalResult ->
                System.out.println("æœ€ç»ˆç»“æœ: " + finalResult), customPool);

        // ç­‰å¾…å®Œæˆ
        future.get();
    }
}</code></pre>
                <p class="conclusion">é“¾å¼è°ƒç”¨è®©å¼‚æ­¥ç¼–ç¨‹å˜å¾—ç›´è§‚ï¼Œå¯ä»¥æ¸…æ™°åœ°è¡¨è¾¾ä¸šåŠ¡æµç¨‹ã€‚</p>
            </div>
        </section>

        <!-- Slide 7: CompletableFuture æ·±åº¦ç¼–ç¨‹ (Part 3) -->
        <section class="slide">
            <div class="slide-content">
                <h2>CompletableFuture æ·±åº¦ç¼–ç¨‹ (3)</h2>
                <p>ç»„åˆæ“ä½œæ˜¯ CompletableFuture çš„é«˜çº§ç‰¹æ€§ï¼Œç”¨äºåè°ƒå¤šä¸ªå¼‚æ­¥ä»»åŠ¡ã€‚</p>

                <h3>ğŸ”„ ç»„åˆæ“ä½œè¯¦è§£</h3>
                <div class="media-block">
                    <div class="media-block__text">
                        <h4>é¡ºåºç»„åˆï¼š</h4>
                        <ul>
                            <li><strong>thenCompose:</strong> å‰ä¸€ä¸ªç»“æœä½œä¸ºä¸‹ä¸€ä¸ªä»»åŠ¡çš„è¾“å…¥</li>
                            <li><strong>ä½¿ç”¨åœºæ™¯ï¼š</strong>éœ€è¦å‰ä¸€æ­¥ç»“æœæ‰èƒ½æ‰§è¡Œåç»­æ­¥éª¤</li>
                        </ul>
                        <pre><code class="language-java">// é¡ºåºæ‰§è¡Œï¼šç”¨æˆ·ID -> ç”¨æˆ·ä¿¡æ¯ -> ç”¨æˆ·è®¢å•
CompletableFuture<String> userOrders = userIdFuture
    .thenCompose(userId -> fetchUserInfo(userId))
    .thenCompose(userInfo -> fetchUserOrders(userInfo));</code></pre>
                    </div>
                    <div class="media-block__visual">
                        <h4>å¹¶è¡Œç»„åˆï¼š</h4>
                        <ul>
                            <li><strong>thenCombine:</strong> åˆå¹¶ä¸¤ä¸ªç‹¬ç«‹ä»»åŠ¡çš„ç»“æœ</li>
                            <li><strong>ä½¿ç”¨åœºæ™¯ï¼š</strong>éœ€è¦åŒæ—¶æ‰§è¡Œå¤šä¸ªä»»åŠ¡å¹¶åˆå¹¶ç»“æœ</li>
                        </ul>
                        <pre><code class="language-java">// å¹¶è¡Œæ‰§è¡Œï¼šç”¨æˆ·ä¿¡æ¯ + ç”¨æˆ·æƒé™
CompletableFuture<UserProfile> profile = userInfoFuture
    .thenCombine(userPermissionsFuture,
        (user, permissions) -> combine(user, permissions));</code></pre>
                    </div>
                </div>

                <h3>ğŸ¯ æ‰¹é‡æ“ä½œç¤ºä¾‹</h3>
                <pre><code class="language-java">public class CompletableFutureComposition {
    public static void main(String[] args) throws Exception {
        // æ¨¡æ‹ŸæœåŠ¡è°ƒç”¨
        CompletableFuture<User> userFuture = CompletableFuture
            .supplyAsync(() -> fetchUser(123));

        CompletableFuture<List<Order>> ordersFuture = CompletableFuture
            .supplyAsync(() -> fetchOrders(123));

        CompletableFuture<Address> addressFuture = CompletableFuture
            .supplyAsync(() -> fetchAddress(123));

        // ç»„åˆç¤ºä¾‹1ï¼šthenCompose (é¡ºåºä¾èµ–)
        CompletableFuture<String> userWithOrders = userFuture
            .thenCompose(user ->
                CompletableFuture.supplyAsync(() ->
                    formatUserWithOrders(user, ordersFuture.join())));

        // ç»„åˆç¤ºä¾‹2ï¼šthenCombine (å¹¶è¡Œåˆå¹¶)
        CompletableFuture<UserProfile> completeProfile = userFuture
            .thenCombine(addressFuture, (user, address) ->
                new UserProfile(user, address));

        // ç»„åˆç¤ºä¾‹3ï¼šallOf (ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ)
        CompletableFuture<Void> allTasks = CompletableFuture.allOf(
            userFuture, ordersFuture, addressFuture);

        allTasks.thenRun(() -> {
            System.out.println("æ‰€æœ‰ç”¨æˆ·æ•°æ®åŠ è½½å®Œæˆï¼");
            User user = userFuture.join();
            List<Order> orders = ordersFuture.join();
            Address address = addressFuture.join();
            processCompleteUserData(user, orders, address);
        });

        // ç»„åˆç¤ºä¾‹4ï¼šanyOf (ç­‰å¾…ä»»æ„ä»»åŠ¡å®Œæˆ)
        CompletableFuture<Object> fastestResponse = CompletableFuture.anyOf(
            userFuture, ordersFuture, addressFuture);

        fastestResponse.thenAccept(result -> {
            System.out.println("æœ€å¿«å“åº”: " + result);
        });

        // ç­‰å¾…ä¸»è¦ä»»åŠ¡å®Œæˆ
        completeProfile.get(5, TimeUnit.SECONDS);
    }

    // æ¨¡æ‹ŸæœåŠ¡æ–¹æ³•
    private static User fetchUser(int id) { /* å®ç° */ return new User(); }
    private static List<Order> fetchOrders(int id) { /* å®ç° */ return new ArrayList<>(); }
    private static Address fetchAddress(int id) { /* å®ç° */ return new Address(); }
}</code></pre>
                <p class="conclusion">ç»„åˆæ“ä½œè®©å¤æ‚çš„å¼‚æ­¥æµç¨‹å˜å¾—ç®€å•ï¼Œæ”¯æŒé¡ºåºã€å¹¶è¡Œã€æ‰¹é‡ç­‰å¤šç§æ¨¡å¼ã€‚</p>
            </div>
        </section>

        <!-- Slide 8: CompletableFuture å¼‚å¸¸å¤„ç†ä¸è¶…æ—¶ -->
        <section class="slide">
            <div class="slide-content">
                <h2>CompletableFuture å¼‚å¸¸å¤„ç†ä¸è¶…æ—¶</h2>
                <p>CompletableFuture æä¾›äº†å®Œå–„çš„å¼‚å¸¸å¤„ç†æœºåˆ¶å’Œè¶…æ—¶æ§åˆ¶ï¼Œæ˜¯æ„å»ºå¥å£®å¼‚æ­¥ç³»ç»Ÿçš„å…³é”®ã€‚</p>

                <h3>ğŸš¨ å¼‚å¸¸å¤„ç†æ–¹æ³•</h3>
                <div class="media-block">
                    <div class="media-block__text">
                        <h4>å¼‚å¸¸å¤„ç†ç­–ç•¥ï¼š</h4>
                        <ul>
                            <li><strong>exceptionally:</strong> æ•è·å¼‚å¸¸å¹¶æä¾›é»˜è®¤å€¼</li>
                            <li><strong>handle:</strong> å¤„ç†æ­£å¸¸ç»“æœå’Œå¼‚å¸¸</li>
                            <li><strong>whenComplete:</strong> å¼‚æ­¥å®Œæˆåæ‰§è¡Œæ¸…ç†</li>
                            <li><strong>exceptionallyAsync:</strong> å¼‚æ­¥å¼‚å¸¸å¤„ç†</li>
                        </ul>
                    </div>
                    <div class="media-block__visual">
                        <h4>è¶…æ—¶æ§åˆ¶ï¼š</h4>
                        <ul>
                            <li><strong>orTimeout:</strong> è¶…æ—¶åæŠ›å‡ºå¼‚å¸¸</li>
                            <li><strong>completeOnTimeout:</strong> è¶…æ—¶åä½¿ç”¨é»˜è®¤å€¼</li>
                            <li><strong>get(timeout):</strong> é˜»å¡è·å–ç»“æœï¼Œè¶…æ—¶æŠ›å¼‚å¸¸</li>
                        </ul>
                    </div>
                </div>

                <h3>âš¡ å¼‚å¸¸å¤„ç†ç¤ºä¾‹</h3>
                <pre><code class="language-java">public class CompletableFutureExceptionHandling {
    public static void main(String[] args) throws Exception {
        // ç¤ºä¾‹1ï¼šexceptionally - æä¾›é»˜è®¤å€¼
        CompletableFuture<String> withDefault = CompletableFuture
            .supplyAsync(() -> {
                if (Math.random() > 0.5) {
                    throw new RuntimeException("éšæœºå¤±è´¥");
                }
                return "æˆåŠŸç»“æœ";
            })
            .exceptionally(ex -> {
                System.err.println("å¼‚å¸¸å¤„ç†: " + ex.getMessage());
                return "é»˜è®¤ç»“æœ"; // æä¾›é»˜è®¤å€¼
            });

        // ç¤ºä¾‹2ï¼šhandle - åŒæ—¶å¤„ç†ç»“æœå’Œå¼‚å¸¸
        CompletableFuture<String> withHandle = CompletableFuture
            .supplyAsync(() -> "å¯èƒ½å¤±è´¥çš„æ“ä½œ")
            .handle((result, ex) -> {
                if (ex != null) {
                    return "å¼‚å¸¸å¤„ç†: " + ex.getMessage();
                } else {
                    return "æ­£å¸¸å¤„ç†: " + result;
                }
            });

        // ç¤ºä¾‹3ï¼šwhenComplete - æ‰§è¡Œæ¸…ç†æ“ä½œ
        CompletableFuture<String> withCleanup = CompletableFuture
            .supplyAsync(() -> {
                // æ¨¡æ‹Ÿèµ„æºåˆ†é…å’Œé‡Šæ”¾
                System.out.println("åˆ†é…èµ„æº");
                if (Math.random() > 0.7) {
                    throw new RuntimeException("æ“ä½œå¤±è´¥");
                }
                return "æ“ä½œæˆåŠŸ";
            })
            .whenComplete((result, ex) -> {
                System.out.println("é‡Šæ”¾èµ„æº"); // æ— è®ºæˆåŠŸå¤±è´¥éƒ½ä¼šæ‰§è¡Œ
                if (ex != null) {
                    System.err.println("æ“ä½œå¼‚å¸¸: " + ex.getMessage());
                } else {
                    System.out.println("æ“ä½œå®Œæˆ: " + result);
                }
            });

        // ç¤ºä¾‹4ï¼šç»„åˆå¼‚å¸¸å¤„ç†
        CompletableFuture<String> robustChain = CompletableFuture
            .supplyAsync(() -> fetchUserData())
            .thenApply(data -> processData(data))
            .exceptionally(ex -> {
                // æ•°æ®è·å–æˆ–å¤„ç†å¤±è´¥æ—¶çš„å›é€€ç­–ç•¥
                logError("æ•°æ®æ“ä½œå¤±è´¥", ex);
                return getFallbackData();
            })
            .thenApply(processedData -> saveToDatabase(processedData))
            .orTimeout(5, TimeUnit.SECONDS) // 5ç§’è¶…æ—¶
            .exceptionally(ex -> {
                if (ex instanceof TimeoutException) {
                    logError("æ“ä½œè¶…æ—¶", ex);
                    return "è¶…æ—¶å¤„ç†ç»“æœ";
                }
                return "æ•°æ®åº“æ“ä½œå¤±è´¥";
            });
    }

    private static String fetchUserData() { /* å®ç° */ return "ç”¨æˆ·æ•°æ®"; }
    private static String processData(String data) { /* å®ç° */ return "å¤„ç†åçš„æ•°æ®"; }
    private static String getFallbackData() { /* å®ç° */ return "å›é€€æ•°æ®"; }
    private static String saveToDatabase(String data) { /* å®ç° */ return "ä¿å­˜æˆåŠŸ"; }
    private static void logError(String message, Throwable ex) { /* å®ç° */ }
}</code></pre>
                <p class="conclusion">å®Œå–„çš„å¼‚å¸¸å¤„ç†å’Œè¶…æ—¶æœºåˆ¶æ˜¯æ„å»ºå¯é å¼‚æ­¥ç³»ç»Ÿçš„å…³é”®ã€‚</p>
            </div>
        </section>

        <!-- Slide 9: æ— é”ç¼–ç¨‹ä¸åŸå­ç±»æ·±å…¥ (Part 1) -->
        <section class="slide">
            <div class="slide-content">
                <h2>æ— é”ç¼–ç¨‹ä¸åŸå­ç±»æ·±å…¥ (1)</h2>
                <p>CASï¼ˆCompare-And-Swapï¼‰æ˜¯æ— é”ç¼–ç¨‹çš„æ ¸å¿ƒï¼ŒJava åŸå­ç±»åŸºäº CAS å®ç°é«˜æ€§èƒ½çš„çº¿ç¨‹å®‰å…¨æ“ä½œã€‚</p>

                <h3>ğŸ”„ CAS åŸç†è¯¦è§£</h3>
                <div class="media-block">
                    <div class="media-block__text">
                        <h4>CAS æ“ä½œä¸‰è¦ç´ ï¼š</h4>
                        <ul>
                            <li><strong>V:</strong> å†…å­˜ä¸­çš„å˜é‡å€¼</li>
                            <li><strong>E:</strong> æœŸæœ›çš„æ—§å€¼</li>
                            <li><strong>N:</strong> è¦æ›´æ–°çš„æ–°å€¼</li>
                        </ul>
                        <p>CAS(V, E, N): å¦‚æœ V == Eï¼Œåˆ™ V = Nï¼Œå¦åˆ™ä¸åšä»»ä½•æ“ä½œ</p>
                    </div>
                    <div class="media-block__visual">
                        <h4>CAS ä¼˜åŠ¿ï¼š</h4>
                        <ul>
                            <li><strong>æ— é˜»å¡ï¼š</strong>æ— éœ€è·å–é”ï¼Œé¿å…çº¿ç¨‹é˜»å¡</li>
                            <li><strong>é«˜æ€§èƒ½ï¼š</strong>æ— é”ç«äº‰ï¼Œå‡å°‘ä¸Šä¸‹æ–‡åˆ‡æ¢</li>
                            <li><strong>æ­»é”å…ç–«ï¼š</strong>æ²¡æœ‰é”ï¼Œè‡ªç„¶æ— æ­»é”é—®é¢˜</li>
                        </ul>
                    </div>
                </div>

                <h3>âš¡ CAS å®ç°ç¤ºä¾‹</h3>
                <pre><code class="language-java">public class CASExample {
    // æ¨¡æ‹Ÿ CAS æ“ä½œ
    public static boolean compareAndSet(int[] memory, int expected, int newValue) {
        if (memory[0] == expected) {
            memory[0] = newValue; // åŸå­æ›´æ–°
            return true;
        }
        return false;
    }

    // è‡ªæ—‹é”å®ç°ï¼ˆåŸºäº CASï¼‰
    public static class SpinLock {
        private final AtomicBoolean locked = new AtomicBoolean(false);

        public void lock() {
            // è‡ªæ—‹ç­‰å¾…ï¼Œç›´åˆ°è·å–é”
            while (!locked.compareAndSet(false, true)) {
                // CPU å¿™ç­‰å¾…
                Thread.onSpinWait(); // Java 9+ æç¤º CPU è¿›å…¥ç­‰å¾…çŠ¶æ€
            }
        }

        public void unlock() {
            locked.set(false);
        }
    }

    // éé˜»å¡è®¡æ•°å™¨å®ç°
    private volatile int count = 0;

    public void increment() {
        int current, newValue;
        do {
            current = count;          // è¯»å–å½“å‰å€¼
            newValue = current + 1;   // è®¡ç®—æ–°å€¼
        } while (!compareAndSet(current, newValue)); // CAS æ›´æ–°
    }

    private native boolean compareAndSet(int expected, int newValue);
}</code></pre>
                <p class="conclusion">CAS æ˜¯æ— é”ç¼–ç¨‹çš„åŸºç¡€ï¼Œç†è§£å…¶åŸç†å¯¹æŒæ¡é«˜æ€§èƒ½å¹¶å‘è‡³å…³é‡è¦ã€‚</p>
            </div>
        </section>

        <!-- Slide 10: çº¿ç¨‹æ± æ·±åº¦é…ç½®ä¸ç›‘æ§ (Part 1) -->
        <section class="slide">
            <div class="slide-content">
                <h2>çº¿ç¨‹æ± æ·±åº¦é…ç½®ä¸ç›‘æ§ (1)</h2>
                <p>ä»åŸºç¡€çº¿ç¨‹æ± ä½¿ç”¨åˆ°ç”Ÿäº§çº§é…ç½®ä¼˜åŒ–ï¼ŒJUC æä¾›äº†å®Œæ•´çš„çº¿ç¨‹æ± ç®¡ç†å’Œç›‘æ§èƒ½åŠ›ã€‚</p>

                <h3>ğŸ—ï¸ ThreadPoolExecutor æ ¸å¿ƒå‚æ•°è¯¦è§£</h3>
                <div class="media-block">
                    <div class="media-block__text">
                        <h4>åŸºç¡€å‚æ•°ï¼ˆå¤ä¹ ï¼‰ï¼š</h4>
                        <ul>
                            <li><strong>corePoolSize:</strong> æ ¸å¿ƒçº¿ç¨‹æ•°ï¼ˆå¸¸é©»ï¼‰</li>
                            <li><strong>maximumPoolSize:</strong> æœ€å¤§çº¿ç¨‹æ•°ï¼ˆæ‰©å®¹ä¸Šé™ï¼‰</li>
                            <li><strong>keepAliveTime:</strong> éæ ¸å¿ƒçº¿ç¨‹å­˜æ´»æ—¶é—´</li>
                            <li><strong>workQueue:</strong> ä»»åŠ¡é˜Ÿåˆ—ç±»å‹å’Œå®¹é‡</li>
                        </ul>
                    </div>
                    <div class="media-block__visual">
                        <h4>é«˜çº§å‚æ•°ï¼š</h4>
                        <ul>
                            <li><strong>threadFactory:</strong> çº¿ç¨‹å·¥å‚ï¼ˆå‘½åã€ä¼˜å…ˆçº§ã€å®ˆæŠ¤çŠ¶æ€ï¼‰</li>
                            <li><strong>handler:</strong> æ‹’ç»ç­–ç•¥ï¼ˆAbortPolicyã€CallerRunsPolicyç­‰ï¼‰</li>
                            <li><strong>allowCoreThreadTimeOut:</strong> å…è®¸æ ¸å¿ƒçº¿ç¨‹è¶…æ—¶</li>
                            <li><strong>prestartAllCoreThreads:</strong> é¢„å¯åŠ¨æ ¸å¿ƒçº¿ç¨‹</li>
                        </ul>
                    </div>
                </div>

                <h3>âš™ï¸ ç”Ÿäº§çº§çº¿ç¨‹æ± é…ç½®ç¤ºä¾‹</h3>
                <pre><code class="language-java">import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

public class ProductionThreadPoolConfig {

    // è‡ªå®šä¹‰çº¿ç¨‹å·¥å‚
    static class CustomThreadFactory implements ThreadFactory {
        private final AtomicInteger threadNumber = new AtomicInteger(1);
        private final String namePrefix;

        CustomThreadFactory(String namePrefix) {
            this.namePrefix = namePrefix;
        }

        @Override
        public Thread newThread(Runnable r) {
            Thread t = new Thread(r, namePrefix + "-" + threadNumber.getAndIncrement());
            t.setDaemon(false); // éå®ˆæŠ¤çº¿ç¨‹
            t.setPriority(Thread.NORM_PRIORITY);
            // è®¾ç½®æœªæ•è·å¼‚å¸¸å¤„ç†å™¨
            t.setUncaughtExceptionHandler((thread, ex) -> {
                System.err.printf("Thread %s threw exception: %s%n",
                    thread.getName(), ex.getMessage());
            });
            return t;
        }
    }

    // CPUå¯†é›†å‹çº¿ç¨‹æ± é…ç½®
    public static ThreadPoolExecutor cpuIntensivePool() {
        int coreCount = Runtime.getRuntime().availableProcessors();
        return new ThreadPoolExecutor(
            coreCount,           // æ ¸å¿ƒçº¿ç¨‹æ•° = CPUæ ¸æ•°
            coreCount,           // æœ€å¤§çº¿ç¨‹æ•° = CPUæ ¸æ•°ï¼ˆæ— æ‰©å®¹ï¼‰
            0L, TimeUnit.MILLISECONDS,  // æ ¸å¿ƒçº¿ç¨‹æ— è¶…æ—¶
            new LinkedBlockingQueue<>(1000), // æœ‰ç•Œé˜Ÿåˆ—
            new CustomThreadFactory("CPU-Pool"),
            new ThreadPoolExecutor.AbortPolicy() // é˜Ÿåˆ—æ»¡åˆ™æ‹’ç»
        );
    }

    // IOå¯†é›†å‹çº¿ç¨‹æ± é…ç½®
    public static ThreadPoolExecutor ioIntensivePool() {
        int coreCount = Runtime.getRuntime().availableProcessors();
        return new ThreadPoolExecutor(
            coreCount * 2,       // æ ¸å¿ƒçº¿ç¨‹æ•° = CPUæ ¸æ•° * 2
            coreCount * 4,       // æœ€å¤§çº¿ç¨‹æ•° = CPUæ ¸æ•° * 4
            60L, TimeUnit.SECONDS, // éæ ¸å¿ƒçº¿ç¨‹60ç§’è¶…æ—¶
            new LinkedBlockingQueue<>(2000), // æ›´å¤§çš„é˜Ÿåˆ—
            new CustomThreadFactory("IO-Pool"),
            new ThreadPoolExecutor.CallerRunsPolicy() // é˜Ÿåˆ—æ»¡æ—¶è°ƒç”¨è€…æ‰§è¡Œ
        );
    }

    // æ··åˆå‹ä»»åŠ¡çº¿ç¨‹æ± é…ç½®
    public static ThreadPoolExecutor hybridPool() {
        int coreCount = Runtime.getRuntime().availableProcessors();
        return new ThreadPoolExecutor(
            coreCount,           // æ ¸å¿ƒçº¿ç¨‹æ•° = CPUæ ¸æ•°
            coreCount * 2,       // æœ€å¤§çº¿ç¨‹æ•° = CPUæ ¸æ•° * 2
            30L, TimeUnit.SECONDS, // ä¸­ç­‰è¶…æ—¶æ—¶é—´
            new PriorityBlockingQueue<>(100, // ä¼˜å…ˆçº§é˜Ÿåˆ—
                (r1, r2) -> {
                    if (r1 instanceof PriorityTask && r2 instanceof PriorityTask) {
                        return Integer.compare(
                            ((PriorityTask) r2).getPriority(),
                            ((PriorityTask) r1).getPriority());
                    }
                    return 0;
                }),
            new CustomThreadFactory("Hybrid-Pool"),
            new ThreadPoolExecutor.CallerRunsPolicy()
        );
    }

    // ä¼˜å…ˆçº§ä»»åŠ¡æ¥å£
    interface PriorityTask extends Runnable {
        int getPriority();
    }
}</code></pre>
                <p class="conclusion">åˆç†çš„çº¿ç¨‹æ± é…ç½®éœ€è¦æ ¹æ®ä»»åŠ¡ç±»å‹ï¼ˆCPUå¯†é›†å‹/IOå¯†é›†å‹ï¼‰å’Œç³»ç»Ÿèµ„æºè¿›è¡Œè°ƒä¼˜ã€‚</p>
            </div>
        </section>

        <!-- Slide 11: çº¿ç¨‹æ± ç›‘æ§ä¸è°ƒä¼˜ (Part 2) -->
        <section class="slide">
            <div class="slide-content">
                <h2>çº¿ç¨‹æ± ç›‘æ§ä¸è°ƒä¼˜ (2)</h2>
                <p>ç”Ÿäº§ç¯å¢ƒä¸­éœ€è¦å¯¹çº¿ç¨‹æ± è¿›è¡Œå®æ—¶ç›‘æ§å’ŒåŠ¨æ€è°ƒä¼˜ï¼Œç¡®ä¿ç³»ç»Ÿç¨³å®šæ€§å’Œæ€§èƒ½ã€‚</p>

                <h3>ğŸ“Š çº¿ç¨‹æ± æ ¸å¿ƒç›‘æ§æŒ‡æ ‡</h3>
                <div class="media-block">
                    <div class="media-block__text">
                        <h4>åŸºç¡€ç›‘æ§æŒ‡æ ‡ï¼š</h4>
                        <ul>
                            <li><strong>getActiveCount():</strong> æ­£åœ¨æ‰§è¡Œä»»åŠ¡çš„çº¿ç¨‹æ•°</li>
                            <li><strong>getPoolSize():</strong> å½“å‰çº¿ç¨‹æ± æ€»çº¿ç¨‹æ•°</li>
                            <li><strong>getCorePoolSize():</strong> æ ¸å¿ƒçº¿ç¨‹æ•°</li>
                            <li><strong>getMaximumPoolSize():</strong> æœ€å¤§çº¿ç¨‹æ•°</li>
                            <li><strong>getQueue().size():</strong> é˜Ÿåˆ—ä¸­ç­‰å¾…ä»»åŠ¡æ•°</li>
                        </ul>
                    </div>
                    <div class="media-block__visual">
                        <h4>æ€§èƒ½ç›‘æ§æŒ‡æ ‡ï¼š</h4>
                        <ul>
                            <li><strong>getCompletedTaskCount():</strong> å·²å®Œæˆä»»åŠ¡æ•°</li>
                            <li><strong>getTaskCount():</strong> æ€»æäº¤ä»»åŠ¡æ•°</li>
                            <li><strong>isShutdown():</strong> æ˜¯å¦å·²å…³é—­</li>
                            <li><strong>isTerminated():</strong> æ˜¯å¦å·²ç»ˆæ­¢</li>
                            <li><strong>isTerminating():</strong> æ˜¯å¦æ­£åœ¨ç»ˆæ­¢</li>
                        </ul>
                    </div>
                </div>

                <h3>ğŸš€ çº¿ç¨‹æ± ç›‘æ§ç³»ç»Ÿå®ç°</h3>
                <pre><code class="language-java">public class ThreadPoolMonitor {
    private final ThreadPoolExecutor executor;
    private final ScheduledExecutorService monitor;

    public ThreadPoolMonitor(ThreadPoolExecutor executor) {
        this.executor = executor;
        this.monitor = Executors.newSingleThreadScheduledExecutor();
        startMonitoring();
    }

    private void startMonitoring() {
        monitor.scheduleAtFixedRate(() -> {
            try {
                // æ”¶é›†ç›‘æ§æ•°æ®
                int activeCount = executor.getActiveCount();
                int poolSize = executor.getPoolSize();
                int corePoolSize = executor.getCorePoolSize();
                int maximumPoolSize = executor.getMaximumPoolSize();
                long completedTaskCount = executor.getCompletedTaskCount();
                long taskCount = executor.getTaskCount();
                int queueSize = executor.getQueue().size();

                // è®¡ç®—æ€§èƒ½æŒ‡æ ‡
                double completionRate = taskCount > 0 ?
                    (double) completedTaskCount / taskCount : 0.0;
                double queueUtilization = maximumPoolSize > 0 ?
                    (double) queueSize / (queueSize + poolSize) : 0.0;

                // è¾“å‡ºç›‘æ§ä¿¡æ¯
                System.out.printf("=== çº¿ç¨‹æ± ç›‘æ§ ===%n");
                System.out.printf("æ´»è·ƒçº¿ç¨‹: %d/%d (æ ¸å¿ƒ: %d, æœ€å¤§: %d)%n",
                    activeCount, poolSize, corePoolSize, maximumPoolSize);
                System.out.printf("ä»»åŠ¡å®Œæˆ: %d/%d (%.2f%%)%n",
                    completedTaskCount, taskCount, completionRate * 100);
                System.out.printf("é˜Ÿåˆ—å¤§å°: %d (åˆ©ç”¨ç‡: %.2f%%)%n",
                    queueSize, queueUtilization * 100);

                // å‘Šè­¦æ£€æŸ¥
                checkAlerts(activeCount, poolSize, queueSize, completionRate);

            } catch (Exception e) {
                System.err.println("ç›‘æ§å¼‚å¸¸: " + e.getMessage());
            }
        }, 0, 5, TimeUnit.SECONDS);
    }

    private void checkAlerts(int activeCount, int poolSize,
                            int queueSize, double completionRate) {
        // æ´»è·ƒçº¿ç¨‹æ•°æ¥è¿‘æœ€å¤§çº¿ç¨‹æ•°
        if (activeCount >= poolSize * 0.9) {
            System.out.println("âš ï¸ è­¦å‘Š: æ´»è·ƒçº¿ç¨‹æ•°æ¥è¿‘ä¸Šé™");
        }

        // é˜Ÿåˆ—ç§¯å‹ä¸¥é‡
        if (queueSize > 1000) {
            System.out.println("âš ï¸ è­¦å‘Š: é˜Ÿåˆ—ç§¯å‹ä¸¥é‡ (" + queueSize + " ä»»åŠ¡)");
        }

        // ä»»åŠ¡å®Œæˆç‡è¿‡ä½
        if (completionRate < 0.8 && executor.getTaskCount() > 100) {
            System.out.println("âš ï¸ è­¦å‘Š: ä»»åŠ¡å®Œæˆç‡è¿‡ä½ (" +
                String.format("%.2f%%", completionRate * 100) + ")");
        }
    }

    // åŠ¨æ€è°ƒæ•´çº¿ç¨‹æ± å¤§å°
    public void adjustPoolSize(int newCoreSize, int newMaxSize) {
        if (newCoreSize > 0 && newMaxSize >= newCoreSize) {
            executor.setCorePoolSize(newCoreSize);
            executor.setMaximumPoolSize(newMaxSize);
            System.out.printf("è°ƒæ•´çº¿ç¨‹æ± : æ ¸å¿ƒ=%d, æœ€å¤§=%d%n",
                newCoreSize, newMaxSize);
        }
    }

    public void shutdown() {
        monitor.shutdown();
    }
}</code></pre>
                <p class="conclusion">å®æ—¶ç›‘æ§å’ŒåŠ¨æ€è°ƒä¼˜æ˜¯ç”Ÿäº§ç¯å¢ƒçº¿ç¨‹æ± ç®¡ç†çš„å…³é”®æŠ€èƒ½ã€‚</p>
            </div>
        </section>

        <!-- Slide 12: çº¿ç¨‹æ± æœ€ä½³å®è·µä¸æ•…éšœæ’æŸ¥ -->
        <section class="slide">
            <div class="slide-content">
                <h2>çº¿ç¨‹æ± æœ€ä½³å®è·µä¸æ•…éšœæ’æŸ¥</h2>
                <p>æŒæ¡çº¿ç¨‹æ± çš„é…ç½®åŸåˆ™ã€æ•…éšœè¯Šæ–­å’Œæ€§èƒ½ä¼˜åŒ–æŠ€å·§ã€‚</p>

                <h3>ğŸ¯ çº¿ç¨‹æ± é…ç½®æœ€ä½³å®è·µ</h3>
                <div class="media-block">
                    <div class="media-block__text">
                        <h4>é…ç½®åŸåˆ™ï¼š</h4>
                        <ul>
                            <li><strong>ä»»åŠ¡ç±»å‹å†³å®šé…ç½®ï¼š</strong> CPUå¯†é›†å‹ã€IOå¯†é›†å‹ã€æ··åˆå‹</li>
                            <li><strong>é˜Ÿåˆ—å®¹é‡é€‚ä¸­ï¼š</strong> å¤ªå°æ˜“æ‹’ç»ï¼Œå¤ªå¤§æ˜“OOM</li>
                            <li><strong>æ‹’ç»ç­–ç•¥æ˜ç¡®ï¼š</strong> æ ¹æ®ä¸šåŠ¡éœ€æ±‚é€‰æ‹©åˆé€‚ç­–ç•¥</li>
                            <li><strong>çº¿ç¨‹å‘½åè§„èŒƒï¼š</strong> ä¾¿äºé—®é¢˜æ’æŸ¥å’Œç›‘æ§</li>
                        </ul>
                    </div>
                    <div class="media-block__visual">
                        <h4>å¸¸è§é”™è¯¯ï¼š</h4>
                        <ul>
                            <li>âŒ ä½¿ç”¨ Executors.newCachedThreadPool() å¤„ç†é•¿ä»»åŠ¡</li>
                            <li>âŒ é˜Ÿåˆ—å®¹é‡è®¾ä¸º Integer.MAX_VALUE</li>
                            <li>âŒ çº¿ç¨‹æ± ä¸è°ƒç”¨ shutdown()</li>
                            <li>âŒ å¿½ç•¥å¼‚å¸¸å¤„ç†å’Œèµ„æºæ¸…ç†</li>
                        </ul>
                    </div>
                </div>

                <h3>ğŸ”§ çº¿ç¨‹æ± æ•…éšœæ’æŸ¥æŒ‡å—</h3>
                <pre><code class="language-java">public class ThreadPoolTroubleshooting {

    // æ•…éšœæ’æŸ¥å·¥å…·ç±»
    public static class ThreadPoolDiagnostics {
        public static void diagnoseThreadPool(ThreadPoolExecutor executor) {
            System.out.println("=== çº¿ç¨‹æ± è¯Šæ–­æŠ¥å‘Š ===");

            // 1. åŸºç¡€çŠ¶æ€æ£€æŸ¥
            System.out.printf("çŠ¶æ€: %s (å…³é—­: %s, ç»ˆæ­¢: %s)%n",
                executor.isShutdown() ? "å·²å…³é—­" : "è¿è¡Œä¸­",
                executor.isShutdown(),
                executor.isTerminated());

            // 2. èµ„æºä½¿ç”¨æƒ…å†µ
            System.out.printf("çº¿ç¨‹ä½¿ç”¨: %d/%d (æ´»è·ƒ: %d)%n",
                executor.getPoolSize(),
                executor.getMaximumPoolSize(),
                executor.getActiveCount());

            // 3. ä»»åŠ¡å¤„ç†æƒ…å†µ
            System.out.printf("ä»»åŠ¡ç»Ÿè®¡: å®Œæˆ %d, æ€»è®¡ %d%n",
                executor.getCompletedTaskCount(),
                executor.getTaskCount());

            // 4. é˜Ÿåˆ—çŠ¶æ€
            System.out.printf("é˜Ÿåˆ—çŠ¶æ€: %d/%d (å‰©ä½™å®¹é‡: %d)%n",
                executor.getQueue().size(),
                executor.getQueue().remainingCapacity() + executor.getQueue().size(),
                executor.getQueue().remainingCapacity());

            // 5. æ€§èƒ½åˆ†æ
            analyzePerformance(executor);
        }

        private static void analyzePerformance(ThreadPoolExecutor executor) {
            long completed = executor.getCompletedTaskCount();
            long total = executor.getTaskCount();

            if (total > 0) {
                double completionRate = (double) completed / total;
                System.out.printf("å®Œæˆç‡: %.2f%%", completionRate * 100);

                if (completionRate < 0.8) {
                    System.out.println(" - æ€§èƒ½é—®é¢˜ï¼šå®Œæˆç‡è¿‡ä½");
                } else if (completionRate > 0.95) {
                    System.out.println(" - æ€§èƒ½è‰¯å¥½");
                } else {
                    System.out.println(" - æ€§èƒ½ä¸€èˆ¬");
                }
            }
        }
    }

    // çº¿ç¨‹æ± å¥åº·æ£€æŸ¥
    public static class ThreadPoolHealthCheck {
        public static boolean isHealthy(ThreadPoolExecutor executor) {
            // æ£€æŸ¥é˜Ÿåˆ—æ˜¯å¦è¿‡é•¿
            if (executor.getQueue().size() > 1000) {
                return false;
            }

            // æ£€æŸ¥çº¿ç¨‹åˆ©ç”¨ç‡
            double utilization = (double) executor.getActiveCount() /
                                executor.getMaximumPoolSize();
            if (utilization > 0.9) {
                return false; // çº¿ç¨‹æ± è¿‡è½½
            }

            // æ£€æŸ¥æ‹’ç»ç­–ç•¥æ˜¯å¦è§¦å‘
            // æ³¨æ„ï¼šThreadPoolExecutor ä¸ç›´æ¥æä¾›æ‹’ç»æ¬¡æ•°ç»Ÿè®¡
            // éœ€è¦è‡ªå®šä¹‰æ‹’ç»ç­–ç•¥æ¥ç»Ÿè®¡

            return true;
        }
    }

    // è‡ªå®šä¹‰æ‹’ç»ç­–ç•¥ï¼ˆç”¨äºç›‘æ§æ‹’ç»æ¬¡æ•°ï¼‰
    public static class MonitoredAbortPolicy implements RejectedExecutionHandler {
        private final AtomicInteger rejectCount = new AtomicInteger(0);

        @Override
        public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
            rejectCount.incrementAndGet();
            System.err.printf("ä»»åŠ¡è¢«æ‹’ç»: %s (å½“å‰æ‹’ç»æ¬¡æ•°: %d)%n",
                r.toString(), rejectCount.get());
            throw new RejectedExecutionException("ä»»åŠ¡è¢«æ‹’ç»");
        }

        public int getRejectCount() {
            return rejectCount.get();
        }
    }
}</code></pre>
                <p class="conclusion">çº¿ç¨‹æ± é…ç½®éœ€è¦åœ¨æ€§èƒ½ã€ç¨³å®šæ€§å’Œèµ„æºä½¿ç”¨ä¹‹é—´æ‰¾åˆ°å¹³è¡¡ç‚¹ã€‚</p>
            </div>
        </section>

        <!-- Slide 13: é«˜çº§é”æœºåˆ¶ä¸æ­»é”æ’æŸ¥ -->
        <section class="slide">
            <div class="slide-content">
                <h2>é«˜çº§é”æœºåˆ¶ä¸æ­»é”æ’æŸ¥</h2>
                <p>æŒæ¡ JUC é”æœºåˆ¶çš„é«˜çº§ç‰¹æ€§ï¼Œå­¦ä¼šè¯†åˆ«å’Œè§£å†³æ­»é”é—®é¢˜ã€‚</p>

                <h3>ğŸ”’ ReentrantReadWriteLockï¼šè¯»å†™åˆ†ç¦»é”</h3>
                <div class="media-block">
                    <div class="media-block__text">
                        <h4>è¯»å†™é”ç‰¹æ€§ï¼š</h4>
                        <ul>
                            <li><strong>è¯»é”å…±äº«ï¼š</strong>å¤šä¸ªçº¿ç¨‹å¯ä»¥åŒæ—¶æŒæœ‰è¯»é”</li>
                            <li><strong>å†™é”ç‹¬å ï¼š</strong>åªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥æŒæœ‰å†™é”</li>
                            <li><strong>è¯»å†™äº’æ–¥ï¼š</strong>è¯»é”å’Œå†™é”ä¸èƒ½åŒæ—¶å­˜åœ¨</li>
                            <li><strong>é”é™çº§ï¼š</strong>å†™é”å¯ä»¥é™çº§ä¸ºè¯»é”</li>
                        </ul>
                    </div>
                    <div class="media-block__visual">
                        <h4>é€‚ç”¨åœºæ™¯ï¼š</h4>
                        <ul>
                            <li>è¯»å¤šå†™å°‘çš„æ•°æ®ç»“æ„</li>
                            <li>ç¼“å­˜ç³»ç»Ÿ</li>
                            <li>é…ç½®ç®¡ç†å™¨</li>
                            <li>ç»Ÿè®¡è®¡æ•°å™¨</li>
                        </ul>
                    </div>
                </div>

                <h3>âš¡ è¯»å†™é”ç¤ºä¾‹</h3>
                <pre><code class="language-java">import java.util.concurrent.locks.ReentrantReadWriteLock;

public class ReadWriteCache<K, V> {
    private final Map<K, V> cache = new HashMap<>();
    private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
    private final ReentrantReadWriteLock.ReadLock readLock = rwLock.readLock();
    private final ReentrantReadWriteLock.WriteLock writeLock = rwLock.writeLock();

    // è¯»å–ç¼“å­˜ï¼ˆå¤šä¸ªçº¿ç¨‹å¯å¹¶å‘è¯»ï¼‰
    public V get(K key) {
        readLock.lock();
        try {
            return cache.get(key);
        } finally {
            readLock.unlock();
        }
    }

    // å†™å…¥ç¼“å­˜ï¼ˆç‹¬å å†™æ“ä½œï¼‰
    public void put(K key, V value) {
        writeLock.lock();
        try {
            cache.put(key, value);
        } finally {
            writeLock.unlock();
        }
    }

    // æ‰¹é‡è¯»å–
    public Map<K, V> getAll() {
        readLock.lock();
        try {
            return new HashMap<>(cache); // è¿”å›å‰¯æœ¬ï¼Œé¿å…å¹¶å‘ä¿®æ”¹
        } finally {
            readLock.unlock();
        }
    }

    // æ¸…ç©ºç¼“å­˜
    public void clear() {
        writeLock.lock();
        try {
            cache.clear();
        } finally {
            writeLock.unlock();
        }
    }
}</code></pre>

                <h3>ğŸš¨ æ­»é”è¯†åˆ«ä¸æ’æŸ¥</h3>
                <pre><code class="language-java">public class DeadlockDetection {

    // æ­»é”çš„å››ä¸ªå¿…è¦æ¡ä»¶
    public static void analyzeDeadlockConditions() {
        System.out.println("æ­»é”çš„å››ä¸ªå¿…è¦æ¡ä»¶ï¼š");
        System.out.println("1. äº’æ–¥æ¡ä»¶ï¼šèµ„æºä¸èƒ½è¢«å¤šä¸ªçº¿ç¨‹åŒæ—¶ä½¿ç”¨");
        System.out.println("2. å æœ‰å¹¶ç­‰å¾…ï¼šçº¿ç¨‹æŒæœ‰èµ„æºçš„åŒæ—¶ç­‰å¾…å…¶ä»–èµ„æº");
        System.out.println("3. ä¸å¯æŠ¢å ï¼šèµ„æºä¸èƒ½è¢«å¼ºåˆ¶æ€§åœ°æŠ¢å ");
        System.out.println("4. å¾ªç¯ç­‰å¾…ï¼šå­˜åœ¨çº¿ç¨‹èµ„æºçš„ç¯å½¢ç­‰å¾…é“¾");
    }

    // æ­»é”é¢„é˜²ç­–ç•¥
    public static class DeadlockPrevention {

        // 1. é”æ’åºï¼šæ‰€æœ‰çº¿ç¨‹æŒ‰å›ºå®šé¡ºåºè·å–é”
        private static final Object lock1 = new Object();
        private static final Object lock2 = new Object();

        public static void lockOrderingExample() {
            // æ‰€æœ‰çº¿ç¨‹éƒ½æŒ‰ lock1 -> lock2 çš„é¡ºåºè·å–é”
            synchronized (lock1) {
                System.out.println("è·å– lock1");
                synchronized (lock2) {
                    System.out.println("è·å– lock2 - ä¸ä¼šæ­»é”");
                }
            }
        }

        // 2. è¶…æ—¶æœºåˆ¶ï¼šä½¿ç”¨ tryLock é¿å…æ— é™ç­‰å¾…
        public static void timeoutExample() throws InterruptedException {
            ReentrantLock lock1 = new ReentrantLock();
            ReentrantLock lock2 = new ReentrantLock();

            // å…ˆå°è¯•è·å– lock1ï¼Œå†å°è¯•è·å– lock2
            if (lock1.tryLock(1, TimeUnit.SECONDS)) {
                try {
                    if (lock2.tryLock(1, TimeUnit.SECONDS)) {
                        try {
                            System.out.println("æˆåŠŸè·å–ä¸¤ä¸ªé”");
                        } finally {
                            lock2.unlock();
                        }
                    } else {
                        System.out.println("è·å– lock2 è¶…æ—¶ï¼Œé‡Šæ”¾ lock1");
                    }
                } finally {
                    lock1.unlock();
                }
            }
        }

        // 3. é“¶è¡Œå®¶ç®—æ³•ï¼šèµ„æºåˆ†é…å‰æ£€æŸ¥å®‰å…¨æ€§
        public static class BankersAlgorithm {
            public static boolean isSafeState(int[] available, int[][] max, int[][] allocation) {
                int[] work = Arrays.copyOf(available, available.length);
                boolean[] finish = new boolean[max.length];

                while (true) {
                    int i = findSafeProcess(work, max, allocation, finish);
                    if (i == -1) break; // æ²¡æœ‰æ‰¾åˆ°å®‰å…¨è¿›ç¨‹

                    work[i] += allocation[i][i]; // å›æ”¶èµ„æº
                    finish[i] = true;
                }

                return Arrays.stream(finish).allMatch(b -> b);
            }

            private static int findSafeProcess(int[] work, int[][] max,
                                             int[][] allocation, boolean[] finish) {
                for (int i = 0; i < max.length; i++) {
                    if (!finish[i] && canSatisfy(work, max[i], allocation[i])) {
                        return i;
                    }
                }
                return -1;
            }

            private static boolean canSatisfy(int[] work, int[] max, int[] allocation) {
                for (int i = 0; i < work.length; i++) {
                    if (max[i] - allocation[i] > work[i]) {
                        return false;
                    }
                }
                return true;
            }
        }
    }

    // æ­»é”æ£€æµ‹å·¥å…·
    public static void detectDeadlock() {
        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
        long[] deadlockedThreads = threadMXBean.findDeadlockedThreads();

        if (deadlockedThreads != null) {
            ThreadInfo[] threadInfos = threadMXBean.getThreadInfo(deadlockedThreads);
            System.out.println("æ£€æµ‹åˆ°æ­»é”ï¼æ¶‰åŠçš„çº¿ç¨‹ï¼š");

            for (ThreadInfo info : threadInfos) {
                System.out.printf("çº¿ç¨‹ %s (%d)%n", info.getThreadName(), info.getThreadId());
                System.out.printf("  ç­‰å¾…çš„é”: %s%n", info.getLockName());
                System.out.printf("  æŒæœ‰çš„é”: %s%n", info.getLockOwnerName());

                for (StackTraceElement element : info.getStackTrace()) {
                    System.out.println("    " + element);
                }
            }
        } else {
            System.out.println("æœªæ£€æµ‹åˆ°æ­»é”");
        }
    }
}</code></pre>
                <p class="conclusion">æŒæ¡æ­»é”é¢„é˜²å’Œæ£€æµ‹æŠ€å·§æ˜¯ç¼–å†™å¯é å¹¶å‘ç¨‹åºçš„å…³é”®ã€‚</p>
            </div>
        </section>

        <!-- Slide 14: å®šæ—¶ä»»åŠ¡ä¸è°ƒåº¦å™¨ -->
        <section class="slide">
            <div class="slide-content">
                <h2>å®šæ—¶ä»»åŠ¡ä¸è°ƒåº¦å™¨</h2>
                <p>JUC æä¾›äº†å¼ºå¤§çš„å®šæ—¶ä»»åŠ¡è°ƒåº¦åŠŸèƒ½ï¼Œæ›¿ä»£ä¼ ç»Ÿçš„ Timer å·¥å…·ã€‚</p>

                <h3>â° ScheduledExecutorService è¯¦è§£</h3>
                <div class="media-block">
                    <div class="media-block__text">
                        <h4>ç›¸æ¯” Timer çš„ä¼˜åŠ¿ï¼š</h4>
                        <ul>
                            <li><strong>å¤šçº¿ç¨‹æ‰§è¡Œï¼š</strong>é¿å…å•çº¿ç¨‹é˜»å¡</li>
                            <li><strong>å¼‚å¸¸éš”ç¦»ï¼š</strong>å•ä¸ªä»»åŠ¡å¼‚å¸¸ä¸å½±å“å…¶ä»–ä»»åŠ¡</li>
                            <li><strong>çµæ´»è°ƒåº¦ï¼š</strong>æ”¯æŒå»¶è¿Ÿå’Œå‘¨æœŸæ‰§è¡Œ</li>
                            <li><strong>æ—¶é—´ç²¾ç¡®ï¼š</strong>åŸºäºç›¸å¯¹æ—¶é—´è°ƒåº¦</li>
                        </ul>
                    </div>
                    <div class="media-block__visual">
                        <h4>è°ƒåº¦æ–¹æ³•ï¼š</h4>
                        <ul>
                            <li><strong>schedule:</strong> å»¶è¿Ÿæ‰§è¡Œä¸€æ¬¡æ€§ä»»åŠ¡</li>
                            <li><strong>scheduleAtFixedRate:</strong> å›ºå®šé¢‘ç‡æ‰§è¡Œ</li>
                            <li><strong>scheduleWithFixedDelay:</strong> å›ºå®šå»¶è¿Ÿæ‰§è¡Œ</li>
                        </ul>
                    </div>
                </div>

                <h3>ğŸš€ è°ƒåº¦å™¨åº”ç”¨ç¤ºä¾‹</h3>
                <pre><code class="language-java">import java.util.concurrent.*;

public class ScheduledTaskExamples {

    // 1. åŸºæœ¬å®šæ—¶ä»»åŠ¡
    public void basicScheduledTask() {
        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);

        // å»¶è¿Ÿ 3 ç§’åæ‰§è¡Œ
        ScheduledFuture<?> future = scheduler.schedule(() -> {
            System.out.println("å»¶è¿Ÿä»»åŠ¡æ‰§è¡Œ: " + System.currentTimeMillis());
        }, 3, TimeUnit.SECONDS);

        // å‘¨æœŸæ€§ä»»åŠ¡ï¼šæ¯ 2 ç§’æ‰§è¡Œä¸€æ¬¡ï¼ˆå›ºå®šé¢‘ç‡ï¼‰
        ScheduledFuture<?> periodicTask = scheduler.scheduleAtFixedRate(() -> {
            System.out.println("å‘¨æœŸä»»åŠ¡: " + new Date());
        }, 0, 2, TimeUnit.SECONDS);

        // å‘¨æœŸæ€§ä»»åŠ¡ï¼šä»»åŠ¡å®Œæˆåç­‰å¾… 2 ç§’å†æ‰§è¡Œä¸‹ä¸€æ¬¡ï¼ˆå›ºå®šå»¶è¿Ÿï¼‰
        ScheduledFuture<?> delayTask = scheduler.scheduleWithFixedDelay(() -> {
            try {
                // æ¨¡æ‹Ÿä»»åŠ¡æ‰§è¡Œæ—¶é—´
                Thread.sleep(1000);
                System.out.println("å›ºå®šå»¶è¿Ÿä»»åŠ¡: " + new Date());
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }, 0, 2, TimeUnit.SECONDS);
    }

    // 2. å¤æ‚è°ƒåº¦åœºæ™¯
    public static class ComplexScheduler {
        private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(3);

        // æ¯å¤©å‡Œæ™¨ 2 ç‚¹æ‰§è¡Œæ•°æ®å¤‡ä»½
        public void scheduleDailyBackup() {
            long initialDelay = calculateInitialDelay(2, 0, 0); // 2:00 AM
            long period = TimeUnit.DAYS.toMillis(1);

            scheduler.scheduleAtFixedRate(() -> {
                try {
                    performDataBackup();
                } catch (Exception e) {
                    System.err.println("å¤‡ä»½å¤±è´¥: " + e.getMessage());
                }
            }, initialDelay, period, TimeUnit.MILLISECONDS);
        }

        // æ¯å°æ—¶æ‰§è¡Œå¥åº·æ£€æŸ¥ï¼Œå¦‚æœè¿ç»­å¤±è´¥åˆ™åœæ­¢
        public void scheduleHealthCheck() {
            AtomicInteger failureCount = new AtomicInteger(0);
            final int maxFailures = 3;

            ScheduledFuture<?> healthCheck = scheduler.scheduleWithFixedDelay(() -> {
                try {
                    boolean healthy = performHealthCheck();
                    if (healthy) {
                        failureCount.set(0); // é‡ç½®å¤±è´¥è®¡æ•°
                    } else {
                        int failures = failureCount.incrementAndGet();
                        if (failures >= maxFailures) {
                            System.out.println("å¥åº·æ£€æŸ¥è¿ç»­å¤±è´¥ï¼Œåœæ­¢è°ƒåº¦");
                            healthCheck.cancel(false);
                        }
                    }
                } catch (Exception e) {
                    failureCount.incrementAndGet();
                    System.err.println("å¥åº·æ£€æŸ¥å¼‚å¸¸: " + e.getMessage());
                }
            }, 0, 1, TimeUnit.HOURS);
        }

        // åŠ¨æ€è°ƒæ•´è°ƒåº¦é¢‘ç‡
        public void adaptiveScheduling() {
            AtomicInteger interval = new AtomicInteger(5); // åˆå§‹é—´éš” 5 ç§’
            AtomicInteger loadLevel = new AtomicInteger(0);

            ScheduledFuture<?> adaptiveTask = scheduler.scheduleWithFixedDelay(() -> {
                try {
                    // ç›‘æ§ç³»ç»Ÿè´Ÿè½½
                    int currentLoad = monitorSystemLoad();
                    loadLevel.set(currentLoad);

                    // æ ¹æ®è´Ÿè½½è°ƒæ•´æ‰§è¡Œé—´éš”
                    int newInterval = calculateInterval(currentLoad);
                    if (newInterval != interval.get()) {
                        System.out.printf("è´Ÿè½½ %dï¼Œè°ƒæ•´é—´éš” %d -> %d ç§’%n",
                            currentLoad, interval.get(), newInterval);
                        interval.set(newInterval);
                    }

                    // æ‰§è¡Œå®é™…ä»»åŠ¡
                    performAdaptiveTask();

                } catch (Exception e) {
                    System.err.println("è‡ªé€‚åº”ä»»åŠ¡å¼‚å¸¸: " + e.getMessage());
                }
            }, 0, interval.get(), TimeUnit.SECONDS);
        }

        private long calculateInitialDelay(int hour, int minute, int second) {
            // è®¡ç®—åˆ°æŒ‡å®šæ—¶é—´çš„å»¶è¿Ÿ
            Calendar now = Calendar.getInstance();
            Calendar target = Calendar.getInstance();
            target.set(Calendar.HOUR_OF_DAY, hour);
            target.set(Calendar.MINUTE, minute);
            target.set(Calendar.SECOND, second);

            if (target.before(now)) {
                target.add(Calendar.DAY_OF_MONTH, 1);
            }

            return target.getTimeInMillis() - now.getTimeInMillis();
        }

        private int calculateInterval(int loadLevel) {
            if (loadLevel < 30) return 1;      // ä½è´Ÿè½½ï¼š1ç§’é—´éš”
            else if (loadLevel < 60) return 5; // ä¸­è´Ÿè½½ï¼š5ç§’é—´éš”
            else if (loadLevel < 80) return 10; // é«˜è´Ÿè½½ï¼š10ç§’é—´éš”
            else return 30;                     // æé«˜è´Ÿè½½ï¼š30ç§’é—´éš”
        }

        // æ¨¡æ‹Ÿæ–¹æ³•
        private void performDataBackup() { /* å®ç° */ }
        private boolean performHealthCheck() { return true; /* å®ç° */ }
        private int monitorSystemLoad() { return 50; /* å®ç° */ }
        private void performAdaptiveTask() { /* å®ç° */ }
    }

    // 3. ä»»åŠ¡å–æ¶ˆå’Œç›‘æ§
    public static class TaskManagement {
        private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);
        private final Map<String, ScheduledFuture<?>> tasks = new ConcurrentHashMap<>();

        public void addTask(String taskId, Runnable task, long delay, TimeUnit unit) {
            ScheduledFuture<?> future = scheduler.schedule(() -> {
                try {
                    task.run();
                } finally {
                    tasks.remove(taskId); // å®Œæˆåè‡ªåŠ¨ç§»é™¤
                }
            }, delay, unit);

            tasks.put(taskId, future);
        }

        public boolean cancelTask(String taskId, boolean mayInterrupt) {
            ScheduledFuture<?> future = tasks.get(taskId);
            if (future != null) {
                boolean cancelled = future.cancel(mayInterrupt);
                if (cancelled) {
                    tasks.remove(taskId);
                }
                return cancelled;
            }
            return false;
        }

        public Map<String, String> getTaskStatus() {
            Map<String, String> status = new HashMap<>();
            tasks.forEach((id, future) -> {
                if (future.isDone()) {
                    if (future.isCancelled()) {
                        status.put(id, "å·²å–æ¶ˆ");
                    } else {
                        status.put(id, "å·²å®Œæˆ");
                    }
                } else {
                    status.put(id, "æ‰§è¡Œä¸­");
                }
            });
            return status;
        }

        public void shutdown() {
            scheduler.shutdown();
            try {
                if (!scheduler.awaitTermination(10, TimeUnit.SECONDS)) {
                    scheduler.shutdownNow();
                }
            } catch (InterruptedException e) {
                scheduler.shutdownNow();
                Thread.currentThread().interrupt();
            }
        }
    }
}</code></pre>
                <p class="conclusion">ScheduledExecutorService æ˜¯ç”Ÿäº§ç¯å¢ƒå®šæ—¶ä»»åŠ¡çš„é¦–é€‰å·¥å…·ã€‚</p>
            </div>
        </section>

        <!-- Slide 15: Fork/Join å¹¶è¡Œè®¡ç®—æ¡†æ¶ -->
        <section class="slide">
            <div class="slide-content">
                <h2>Fork/Join å¹¶è¡Œè®¡ç®—æ¡†æ¶</h2>
                <p>Fork/Join æ˜¯ Java 7 å¼•å…¥çš„å¹¶è¡Œè®¡ç®—æ¡†æ¶ï¼Œé‡‡ç”¨å·¥ä½œçªƒå–ç®—æ³•ï¼Œé€‚ç”¨äºé€’å½’åˆ†æ²»é—®é¢˜çš„å¹¶è¡ŒåŒ–å¤„ç†ã€‚</p>

                <h3>ğŸš€ Fork/Join æ ¸å¿ƒæ¦‚å¿µ</h3>
                <div class="media-block">
                    <div class="media-block__text">
                        <h4>å·¥ä½œçªƒå–ç®—æ³•ï¼š</h4>
                        <ul>
                            <li><strong>åŒç«¯é˜Ÿåˆ—ï¼š</strong>æ¯ä¸ªå·¥ä½œçº¿ç¨‹æœ‰è‡ªå·±çš„ä»»åŠ¡é˜Ÿåˆ—</li>
                            <li><strong>æœ¬åœ°ä¼˜å…ˆï¼š</strong>ä¼˜å…ˆä»è‡ªå·±é˜Ÿåˆ—å–ä»»åŠ¡</li>
                            <li><strong>å·¥ä½œçªƒå–ï¼š</strong>ç©ºé—²çº¿ç¨‹ä»å…¶ä»–çº¿ç¨‹é˜Ÿåˆ—å°¾éƒ¨çªƒå–ä»»åŠ¡</li>
                            <li><strong>è´Ÿè½½å‡è¡¡ï¼š</strong>è‡ªåŠ¨å®ç°å·¥ä½œè´Ÿè½½çš„åŠ¨æ€å¹³è¡¡</li>
                        </ul>
                    </div>
                    <div class="media-block__visual">
                        <h4>é€‚ç”¨åœºæ™¯ï¼š</h4>
                        <ul>
                            <li>CPU å¯†é›†å‹ä»»åŠ¡</li>
                            <li>å¯é€’å½’åˆ†è§£çš„é—®é¢˜</li>
                            <li>æ•°æ®å¹¶è¡Œå¤„ç†</li>
                            <li>åˆ†æ²»ç®—æ³•</li>
                        </ul>
                    </div>
                </div>

                <h3>âš¡ Fork/Join åŸºç¡€åº”ç”¨</h3>
                <pre><code class="language-java">import java.util.concurrent.*;

// 1. æ•°ç»„æ±‚å’Œç¤ºä¾‹
class ArraySumTask extends RecursiveTask<Long> {
    private final long[] array;
    private final int start;
    private final int end;
    private static final int THRESHOLD = 10_000; // æ‹†åˆ†é˜ˆå€¼

    ArraySumTask(long[] array, int start, int end) {
        this.array = array;
        this.start = start;
        this.end = end;
    }

    @Override
    protected Long compute() {
        int length = end - start;
        if (length <= THRESHOLD) {
            // å°ä»»åŠ¡ï¼šé¡ºåºè®¡ç®—
            long sum = 0;
            for (int i = start; i < end; i++) {
                sum += array[i];
            }
            return sum;
        }

        // å¤§ä»»åŠ¡ï¼šæ‹†åˆ†è®¡ç®—
        int mid = start + length / 2;
        ArraySumTask leftTask = new ArraySumTask(array, start, mid);
        ArraySumTask rightTask = new ArraySumTask(array, mid, end);

        leftTask.fork();  // å¼‚æ­¥æ‰§è¡Œå·¦ä»»åŠ¡
        long rightResult = rightTask.compute();  // åŒæ­¥æ‰§è¡Œå³ä»»åŠ¡
        long leftResult = leftTask.join();  // ç­‰å¾…å·¦ä»»åŠ¡å®Œæˆ

        return leftResult + rightResult;  // åˆå¹¶ç»“æœ
    }
}

// 2. å¹¶è¡Œå¿«é€Ÿæ’åº
class ParallelQuickSort extends RecursiveAction {
    private final int[] array;
    private final int low;
    private final int high;
    private static final int THRESHOLD = 1000;

    ParallelQuickSort(int[] array, int low, int high) {
        this.array = array;
        this.low = low;
        this.high = high;
    }

    @Override
    protected void compute() {
        if (high - low <= THRESHOLD) {
            // å°æ•°ç»„ä½¿ç”¨ä¼ ç»Ÿå¿«é€Ÿæ’åº
            Arrays.sort(array, low, high + 1);
            return;
        }

        // é€‰æ‹©åŸºå‡†å€¼å¹¶åˆ†åŒº
        int pivotIndex = partition(array, low, high);

        // å¹¶è¡Œæ’åºå·¦å³ä¸¤éƒ¨åˆ†
        ParallelQuickSort leftTask = new ParallelQuickSort(array, low, pivotIndex - 1);
        ParallelQuickSort rightTask = new ParallelQuickSort(array, pivotIndex + 1, high);

        invokeAll(leftTask, rightTask);  // å¹¶è¡Œæ‰§è¡Œä¸¤ä¸ªä»»åŠ¡
    }

    private int partition(int[] array, int low, int high) {
        int pivot = array[high];
        int i = low - 1;

        for (int j = low; j < high; j++) {
            if (array[j] <= pivot) {
                i++;
                swap(array, i, j);
            }
        }

        swap(array, i + 1, high);
        return i + 1;
    }

    private void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}</code></pre>
                <p class="conclusion">Fork/Join æ¡†æ¶é€šè¿‡å·¥ä½œçªƒå–ç®—æ³•å®ç°äº†é«˜æ•ˆçš„å¹¶è¡Œè®¡ç®—ï¼Œç‰¹åˆ«é€‚åˆå¯é€’å½’åˆ†è§£çš„é—®é¢˜ã€‚</p>
            </div>
        </section>

        <!-- Slide 16: Fork/Join é«˜çº§åº”ç”¨ä¸ä¼˜åŒ– -->
        <section class="slide">
            <div class="slide-content">
                <h2>Fork/Join é«˜çº§åº”ç”¨ä¸ä¼˜åŒ–</h2>
                <p>æŒæ¡ Fork/Join çš„é«˜çº§æŠ€å·§å’Œæ€§èƒ½ä¼˜åŒ–ç­–ç•¥ï¼Œåœ¨å®é™…é¡¹ç›®ä¸­è·å¾—æœ€ä½³å¹¶è¡Œæ€§èƒ½ã€‚</p>

                <h3>ğŸ¯ Fork/Join æœ€ä½³å®è·µ</h3>
                <div class="media-block">
                    <div class="media-block__text">
                        <h4>å…­æ­¥æ³•å¥—è·¯ï¼š</h4>
                        <ol>
                            <li><strong>åœºæ™¯åˆ¤æ–­ï¼š</strong>CPUå¯†é›†ã€å¯åˆ†æ²»ã€ç»“æœå¯åˆå¹¶</li>
                            <li><strong>ä»»åŠ¡å»ºæ¨¡ï¼š</strong>å®šä¹‰ RecursiveTask/Action</li>
                            <li><strong>é˜ˆå€¼è®¾è®¡ï¼š</strong>å¹³è¡¡æ‹†åˆ†ç²’åº¦</li>
                            <li><strong>æ‹†åˆ†ç­–ç•¥ï¼š</strong>äºŒåˆ†æˆ–Kåˆ†ï¼Œå‡è¡¡è´Ÿè½½</li>
                            <li><strong>åˆå¹¶ç­–ç•¥ï¼š</strong>å…ˆå³computeï¼Œå·¦join</li>
                            <li><strong>æäº¤æ‰§è¡Œï¼š</strong>ä½¿ç”¨åˆé€‚çš„çº¿ç¨‹æ± </li>
                        </ol>
                    </div>
                    <div class="media-block__visual">
                        <h4>æ€§èƒ½ä¼˜åŒ–è¦ç‚¹ï¼š</h4>
                        <ul>
                            <li><strong>é˜ˆå€¼è°ƒä¼˜ï¼š</strong>é¿å…è¿‡åº¦æ‹†åˆ†</li>
                            <li><strong>é¿å…é˜»å¡ï¼š</strong>ä¸æ‰§è¡ŒIOæ“ä½œ</li>
                            <li><strong>åˆç†åˆ†å‰ï¼š</strong>ä½¿ç”¨ invokeAll</li>
                            <li><strong>æ± é…ç½®ï¼š</strong>é€‰æ‹©åˆé€‚çš„å¹¶è¡Œåº¦</li>
                        </ul>
                    </div>
                </div>

                <h3>âš¡ é«˜çº§åº”ç”¨ç¤ºä¾‹</h3>
                <pre><code class="language-java">import java.util.concurrent.*;
import java.util.stream.*;

public class ForkJoinAdvancedExamples {

    // 1. å¹¶è¡Œæ–‡ä»¶å¤„ç†
    public static class FileProcessor extends RecursiveTask<List<String>> {
        private final File[] files;
        private final int start;
        private final int end;
        private static final int THRESHOLD = 10;

        FileProcessor(File[] files, int start, int end) {
            this.files = files;
            this.start = start;
            this.end = end;
        }

        @Override
        protected List<String> compute() {
            int length = end - start;
            if (length <= THRESHOLD) {
                return processFiles();
            }

            int mid = start + length / 2;
            FileProcessor left = new FileProcessor(files, start, mid);
            FileProcessor right = new FileProcessor(files, mid, end);

            left.fork();
            List<String> rightResult = right.compute();
            List<String> leftResult = left.join();

            List<String> result = new ArrayList<>(leftResult);
            result.addAll(rightResult);
            return result;
        }

        private List<String> processFiles() {
            List<String> results = new ArrayList<>();
            for (int i = start; i < end; i++) {
                results.addAll(processFile(files[i]));
            }
            return results;
        }

        private List<String> processFile(File file) {
            // å¤„ç†å•ä¸ªæ–‡ä»¶
            return Arrays.asList(file.getName(), String.valueOf(file.length()));
        }
    }

    // 2. å¹¶è¡Œå›¾åƒå¤„ç†
    public static class ImageProcessor extends RecursiveAction {
        private final int[][] image;
        private final int startX, startY, endX, endY;
        private static final int THRESHOLD = 100;

        ImageProcessor(int[][] image, int startX, int startY, int endX, int endY) {
            this.image = image;
            this.startX = startX;
            this.startY = startY;
            this.endX = endX;
            this.endY = endY;
        }

        @Override
        protected void compute() {
            int width = endX - startX;
            int height = endY - startY;

            if (width * height <= THRESHOLD) {
                // å°åŒºåŸŸï¼šé¡ºåºå¤„ç†
                processRegion();
                return;
            }

            // å¤§åŒºåŸŸï¼šåˆ†å—å¹¶è¡Œå¤„ç†
            if (width > height) {
                int midX = startX + width / 2;
                invokeAll(
                    new ImageProcessor(image, startX, startY, midX, endY),
                    new ImageProcessor(image, midX, startY, endX, endY)
                );
            } else {
                int midY = startY + height / 2;
                invokeAll(
                    new ImageProcessor(image, startX, startY, endX, midY),
                    new ImageProcessor(image, startX, midY, endX, endY)
                );
            }
        }

        private void processRegion() {
            // åº”ç”¨æ»¤é•œæˆ–å…¶ä»–å›¾åƒå¤„ç†
            for (int y = startY; y < endY; y++) {
                for (int x = startX; x < endX; x++) {
                    image[y][x] = applyFilter(image[y][x]);
                }
            }
        }

        private int applyFilter(int pixel) {
            // ç®€å•çš„æ»¤é•œå¤„ç†
            return (pixel * 110) / 100; // å¢åŠ äº®åº¦
        }
    }

    // 3. è‡ªå®šä¹‰ ForkJoinPool é…ç½®
    public static class CustomForkJoinPool {
        public static ForkJoinPool createOptimizedPool() {
            int processors = Runtime.getRuntime().availableProcessors();

            return new ForkJoinPool(
                processors,  // å¹¶è¡Œåº¦
                pool -> {     // è‡ªå®šä¹‰çº¿ç¨‹å·¥å‚
                    Thread t = new Thread(pool);
                    t.setName("ForkJoinWorker-" + t.getId());
                    t.setDaemon(false);
                    t.setUncaughtExceptionHandler((thread, ex) -> {
                        System.err.printf("Thread %s uncaught exception: %s%n",
                            thread.getName(), ex.getMessage());
                    });
                    return t;
                },
                (t, e) -> {  // å¼‚å¸¸å¤„ç†å™¨
                    System.err.printf("Task exception in thread %s: %s%n",
                        t.getName(), e.getMessage());
                },
                true        // å¼‚æ­¥æ¨¡å¼
            );
        }

        // æ€§èƒ½ç›‘æ§
        public static void monitorPool(ForkJoinPool pool) {
            ScheduledExecutorService monitor = Executors.newSingleThreadScheduledExecutor();
            monitor.scheduleAtFixedRate(() -> {
                System.out.printf("Pool: parallelism=%d, active=%d, running=%d, queued=%d%n",
                    pool.getParallelism(),
                    pool.getActiveThreadCount(),
                    pool.getRunningThreadCount(),
                    pool.getQueuedSubmissionCount());
            }, 0, 5, TimeUnit.SECONDS);
        }
    }

    // 4. æ€§èƒ½æµ‹è¯•å’ŒåŸºå‡†
    public static class ForkJoinBenchmark {
        public static void benchmarkSum(long[] data) {
            int warmupRuns = 5;
            int benchmarkRuns = 10;

            // é¢„çƒ­
            for (int i = 0; i < warmupRuns; i++) {
                sequentialSum(data);
                parallelSum(data);
            }

            // åŸºå‡†æµ‹è¯•
            long sequentialTime = 0;
            long parallelTime = 0;

            for (int i = 0; i < benchmarkRuns; i++) {
                long start = System.nanoTime();
                long seqResult = sequentialSum(data);
                sequentialTime += System.nanoTime() - start;

                start = System.nanoTime();
                long paraResult = parallelSum(data);
                parallelTime += System.nanoTime() - start;

                // éªŒè¯ç»“æœä¸€è‡´æ€§
                assert seqResult == paraResult : "ç»“æœä¸ä¸€è‡´!";
            }

            System.out.printf("Sequential: %.2f ms%n", sequentialTime / 1_000_000.0 / benchmarkRuns);
            System.out.printf("Parallel:   %.2f ms%n", parallelTime / 1_000_000.0 / benchmarkRuns);
            System.out.printf("Speedup:    %.2fx%n", (double) sequentialTime / parallelTime);
        }

        private static long sequentialSum(long[] data) {
            long sum = 0;
            for (long value : data) {
                sum += value;
            }
            return sum;
        }

        private static long parallelSum(long[] data) {
            ForkJoinPool pool = ForkJoinPool.commonPool();
            return pool.invoke(new ArraySumTask(data, 0, data.length));
        }
    }
}</code></pre>
                <p class="conclusion">Fork/Join æ¡†æ¶åœ¨å¤„ç†å¤§è§„æ¨¡æ•°æ®è®¡ç®—æ—¶èƒ½æ˜¾è‘—æå‡æ€§èƒ½ï¼Œä½†éœ€è¦åˆç†é…ç½®å’Œä¼˜åŒ–ã€‚</p>
            </div>
        </section>

        <!-- Slide 9: Synchronization Tools -->
        <section class="slide">
            <div class="slide-content">
                <h2>åŒæ­¥å·¥å…·ç±»ï¼šåè°ƒçº¿ç¨‹æ‰§è¡Œ</h2>
                <p>JUC æä¾›äº†å¤šç§åŒæ­¥å·¥å…·ç±»ï¼Œç”¨äºåè°ƒå¤šä¸ªçº¿ç¨‹çš„æ‰§è¡Œé¡ºåºã€‚</p>

                <h3>ğŸš¦ CountDownLatchï¼šå€’è®¡æ—¶é—¨é—©</h3>
                <pre><code class="language-java">public class CountDownLatchExample {
    public static void main(String[] args) throws InterruptedException {
        // åˆ›å»ºä¸€ä¸ª CountDownLatchï¼Œè®¡æ•°ä¸º 3
        CountDownLatch latch = new CountDownLatch(3);

        // å¯åŠ¨ 3 ä¸ªå·¥ä½œçº¿ç¨‹
        for (int i = 0; i < 3; i++) {
            int workerId = i;
            new Thread(() -> {
                try {
                    System.out.println("å·¥ä½œçº¿ç¨‹ " + workerId + " å¼€å§‹å·¥ä½œ");
                    Thread.sleep(2000); // æ¨¡æ‹Ÿå·¥ä½œ
                    System.out.println("å·¥ä½œçº¿ç¨‹ " + workerId + " å®Œæˆå·¥ä½œ");
                    latch.countDown(); // è®¡æ•°å‡ 1
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }).start();
        }

        // ä¸»çº¿ç¨‹ç­‰å¾…æ‰€æœ‰å·¥ä½œçº¿ç¨‹å®Œæˆ
        System.out.println("ä¸»çº¿ç¨‹ç­‰å¾…æ‰€æœ‰å·¥ä½œçº¿ç¨‹å®Œæˆ...");
        latch.await(); // é˜»å¡ï¼Œç›´åˆ°è®¡æ•°ä¸º 0
        System.out.println("æ‰€æœ‰å·¥ä½œçº¿ç¨‹éƒ½å·²å®Œæˆï¼Œä¸»çº¿ç¨‹ç»§ç»­æ‰§è¡Œ");
    }
}</code></pre>

                <h3>ğŸ”„ CyclicBarrierï¼šå¾ªç¯æ …æ </h3>
                <pre><code class="language-java">public class CyclicBarrierExample {
    public static void main(String[] args) {
        // åˆ›å»º CyclicBarrierï¼Œç­‰å¾… 3 ä¸ªçº¿ç¨‹ï¼Œåˆ°è¾¾åæ‰§è¡ŒæŒ‡å®šåŠ¨ä½œ
        CyclicBarrier barrier = new CyclicBarrier(3, () -> {
            System.out.println("=== æ‰€æœ‰çº¿ç¨‹éƒ½åˆ°è¾¾å±éšœç‚¹ï¼Œæ‰§è¡Œæ±‡æ€»æ“ä½œ ===");
        });

        for (int i = 0; i < 3; i++) {
            int threadId = i;
            new Thread(() -> {
                try {
                    System.out.println("çº¿ç¨‹ " + threadId + " ç¬¬ä¸€ä¸ªé˜¶æ®µ");
                    Thread.sleep(1000);

                    System.out.println("çº¿ç¨‹ " + threadId + " åˆ°è¾¾å±éšœç‚¹ï¼Œç­‰å¾…å…¶ä»–çº¿ç¨‹");
                    barrier.await(); // ç­‰å¾…å…¶ä»–çº¿ç¨‹

                    System.out.println("çº¿ç¨‹ " + threadId + " ç¬¬äºŒä¸ªé˜¶æ®µ");

                } catch (Exception e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}</code></pre>
            </div>
        </section>

        <!-- Slide 10: Semaphore and Lock -->
        <section class="slide">
            <div class="slide-content">
                <h2>Semaphore å’Œ Lockï¼šèµ„æºæ§åˆ¶</h2>

                <h3>ğŸš¦ Semaphoreï¼šä¿¡å·é‡</h3>
                <pre><code class="language-java">public class SemaphoreExample {
    public static void main(String[] args) {
        // åˆ›å»ºä¿¡å·é‡ï¼Œæœ€å¤šå…è®¸ 3 ä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®
        Semaphore semaphore = new Semaphore(3);

        // æ¨¡æ‹Ÿ 10 ä¸ªçº¿ç¨‹äº‰å¤º 3 ä¸ªèµ„æº
        for (int i = 0; i < 10; i++) {
            final int threadId = i;
            new Thread(() -> {
                try {
                    System.out.println("çº¿ç¨‹ " + threadId + " å°è¯•è·å–èµ„æº");

                    // è·å–è®¸å¯
                    semaphore.acquire();

                    try {
                        System.out.println("çº¿ç¨‹ " + threadId + " è·å¾—èµ„æºï¼Œå¼€å§‹å·¥ä½œ");
                        Thread.sleep(2000); // æ¨¡æ‹Ÿä½¿ç”¨èµ„æº
                        System.out.println("çº¿ç¨‹ " + threadId + " é‡Šæ”¾èµ„æº");
                    } finally {
                        // é‡Šæ”¾è®¸å¯
                        semaphore.release();
                    }

                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }).start();
        }
    }
}</code></pre>

                <h3>ğŸ”’ ReentrantLock é«˜çº§ç‰¹æ€§</h3>
                <pre><code class="language-java">import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.TimeUnit;

public class AdvancedReentrantLockExample {
    // å…¬å¹³é”ï¼šæŒ‰ç­‰å¾…é¡ºåºè·å–é”
    private final ReentrantLock fairLock = new ReentrantLock(true);

    // å¯ä¸­æ–­é”ï¼šæ”¯æŒä¸­æ–­ç­‰å¾…
    private final ReentrantLock interruptibleLock = new ReentrantLock();

    // å¤šæ¡ä»¶ï¼šæ”¯æŒä¸åŒçš„ç­‰å¾…æ¡ä»¶
    private final ReentrantLock multiConditionLock = new ReentrantLock();
    private final Condition notEmpty = multiConditionLock.newCondition();
    private final Condition notFull = multiConditionLock.newCondition();
    private final Queue<String> queue = new LinkedList<>();
    private final int capacity = 10;

    // 1. å…¬å¹³é”åº”ç”¨
    public void fairLockExample() {
        fairLock.lock();
        try {
            // æŒ‰ç…§è¯·æ±‚é¡ºåºæ‰§è¡Œï¼Œé¿å…é¥¥é¥¿
            System.out.println(Thread.currentThread().getName() + " è·å¾—å…¬å¹³é”");
        } finally {
            fairLock.unlock();
        }
    }

    // 2. å¯ä¸­æ–­é”åº”ç”¨
    public void interruptibleLockExample() throws InterruptedException {
        try {
            // æ”¯æŒåœ¨ç­‰å¾…é”çš„è¿‡ç¨‹ä¸­è¢«ä¸­æ–­
            if (interruptibleLock.tryLock(5, TimeUnit.SECONDS)) {
                try {
                    // æ‰§è¡Œä¸´ç•ŒåŒºä»£ç 
                } finally {
                    interruptibleLock.unlock();
                }
            }
        } catch (InterruptedException e) {
            System.out.println("ç­‰å¾…é”è¢«ä¸­æ–­");
            throw e;
        }
    }

    // 3. å¤šæ¡ä»¶ç­‰å¾…ï¼ˆç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹ï¼‰
    public void put(String item) throws InterruptedException {
        multiConditionLock.lock();
        try {
            while (queue.size() >= capacity) {
                notFull.await(); // ç­‰å¾…é˜Ÿåˆ—ä¸æ»¡
            }
            queue.offer(item);
            notEmpty.signal(); // é€šçŸ¥æ¶ˆè´¹è€…é˜Ÿåˆ—ä¸ç©º
        } finally {
            multiConditionLock.unlock();
        }
    }

    public String take() throws InterruptedException {
        multiConditionLock.lock();
        try {
            while (queue.isEmpty()) {
                notEmpty.await(); // ç­‰å¾…é˜Ÿåˆ—ä¸ç©º
            }
            String item = queue.poll();
            notFull.signal(); // é€šçŸ¥ç”Ÿäº§è€…é˜Ÿåˆ—ä¸æ»¡
            return item;
        } finally {
            multiConditionLock.unlock();
        }
    }
}

// é«˜çº§é”æœºåˆ¶æœ€ä½³å®è·µ
public class LockBestPractices {
    private final ReentrantLock lock = new ReentrantLock();
    private final Condition condition = lock.newCondition();

    // 4. é”é™çº§ï¼šå°†å†™é”é™çº§ä¸ºè¯»é”ï¼ˆReentrantReadWriteLockï¼‰
    public void lockDowngradeExample() {
        ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
        ReentrantReadWriteLock.WriteLock writeLock = rwLock.writeLock();
        ReentrantReadWriteLock.ReadLock readLock = rwLock.readLock();

        writeLock.lock();
        try {
            // ä¿®æ”¹å…±äº«æ•°æ®
            updateSharedData();

            // é”é™çº§ï¼šè·å–è¯»é”ï¼Œå†é‡Šæ”¾å†™é”
            readLock.lock();
            try {
                // è¯»å–åˆšä¿®æ”¹çš„æ•°æ®
                readSharedData();
            } finally {
                writeLock.unlock(); // é™çº§å®Œæˆï¼šåªæŒæœ‰è¯»é”
            }
        } finally {
            readLock.unlock();
        }
    }

    // 5. è¶…æ—¶å’Œä¸­æ–­æœºåˆ¶
    public boolean tryLockWithTimeout() throws InterruptedException {
        if (lock.tryLock(3, TimeUnit.SECONDS)) {
            try {
                // æ‰§è¡Œä¸´ç•ŒåŒºä»£ç 
                performCriticalOperation();
                return true;
            } finally {
                lock.unlock();
            }
        } else {
            System.out.println("è·å–é”è¶…æ—¶ï¼Œæ‰§è¡Œå¤‡é€‰æ–¹æ¡ˆ");
            return false;
        }
    }

    // 6. æ¡ä»¶å˜é‡çš„é«˜çº§ç”¨æ³•
    public void advancedConditionExample() throws InterruptedException {
        lock.lock();
        try {
            // ç­‰å¾…ç‰¹å®šæ¡ä»¶
            while (!isConditionMet()) {
                long remainingTime = condition.awaitNanos(TimeUnit.SECONDS.toNanos(5));
                if (remainingTime <= 0) {
                    System.out.println("ç­‰å¾…æ¡ä»¶è¶…æ—¶");
                    break;
                }
            }

            if (isConditionMet()) {
                processCondition();
            }
        } finally {
            lock.unlock();
        }
    }

    private boolean isConditionMet() { /* å®ç° */ return false; }
    private void processCondition() { /* å®ç° */ }
    private void performCriticalOperation() { /* å®ç° */ }
    private void updateSharedData() { /* å®ç° */ }
    private void readSharedData() { /* å®ç° */ }
}</code></pre>
                <p class="conclusion">Semaphore ç”¨äºæ§åˆ¶åŒæ—¶è®¿é—®èµ„æºçš„çº¿ç¨‹æ•°é‡ï¼ŒLock æä¾›äº†æ¯” synchronized æ›´çµæ´»çš„é”æœºåˆ¶ã€‚</p>
            </div>
        </section>

        <!-- Slide 11: Atomic Classes -->
        <section class="slide">
            <div class="slide-content">
                <h2>åŸå­ç±»ï¼šæ— é”çº¿ç¨‹å®‰å…¨</h2>
                <p>åŸå­ç±»åˆ©ç”¨ CASï¼ˆCompare-And-Swapï¼‰æ“ä½œå®ç°æ— é”çš„çº¿ç¨‹å®‰å…¨ï¼Œæ€§èƒ½ä¼˜äºæ˜¾å¼é”ã€‚</p>

                <h3>âš¡ å¸¸ç”¨åŸå­ç±»</h3>
                <pre><code class="language-java">public class AtomicExample {
    // åŸºæœ¬ç±»å‹åŸå­ç±»
    private AtomicInteger atomicInt = new AtomicInteger(0);
    private AtomicLong atomicLong = new AtomicLong(0L);
    private AtomicBoolean atomicBool = new AtomicBoolean(false);

    // å¼•ç”¨ç±»å‹åŸå­ç±»
    private AtomicReference<User> atomicRef = new AtomicReference<>();

    public void demonstrateAtomicOperations() {
        // åŸå­é€’å¢
        int result1 = atomicInt.incrementAndGet(); // å…ˆåŠ 1å†è¿”å›
        int result2 = atomicInt.getAndIncrement(); // å…ˆè¿”å›å†åŠ 1

        // åŸå­åŠ å‡
        int result3 = atomicInt.addAndGet(10);      // åŠ 10å¹¶è¿”å›
        int result4 = atomicInt.getAndAdd(5);       // å…ˆè¿”å›å†åŠ 5

        // åŸå­æ¯”è¾ƒå¹¶è®¾ç½®ï¼ˆCASï¼‰
        boolean success = atomicInt.compareAndSet(5, 100); // å¦‚æœå½“å‰å€¼æ˜¯5ï¼Œåˆ™è®¾ç½®ä¸º100

        // åŸå­æ›´æ–°å¼•ç”¨
        User oldUser = new User("å¼ ä¸‰");
        User newUser = new User("æå››");
        atomicRef.set(oldUser);
        boolean updated = atomicRef.compareAndSet(oldUser, newUser);

        // åŸå­æ“ä½œé“¾
        atomicInt.updateAndGet(x -> x * 2); // åŸå­åœ°æ‰§è¡Œå‡½æ•°æ“ä½œ
        atomicInt.accumulateAndGet(10, (x, y) -> x + y); // åŸå­åœ°ç´¯åŠ 
    }
}</code></pre>

                <h3>ğŸ¯ å®é™…åº”ç”¨ï¼šè®¡æ•°å™¨</h3>
                <pre><code class="language-java">public class ThreadSafeCounter {
    private final AtomicInteger counter = new AtomicInteger(0);

    // ä¼ ç»Ÿæ–¹å¼ï¼šéœ€è¦åŒæ­¥
    private int traditionalCounter = 0;
    private final Object lock = new Object();

    public void incrementTraditional() {
        synchronized (lock) {
            traditionalCounter++;
        }
    }

    // åŸå­æ–¹å¼ï¼šæ— éœ€åŒæ­¥
    public void incrementAtomic() {
        counter.incrementAndGet(); // çº¿ç¨‹å®‰å…¨ï¼Œæ— é”
    }

    public int getValue() {
        return counter.get();
    }

    // CAS æ“ä½œç¤ºä¾‹ï¼šåªæœ‰å½“å‰å€¼ä¸ºæœŸæœ›å€¼æ—¶æ‰æ›´æ–°
    public boolean incrementIfEven() {
        int current, next;
        do {
            current = counter.get();
            if (current % 2 != 0) {
                return false; // å¦‚æœæ˜¯å¥‡æ•°ï¼Œä¸æ‰§è¡Œæ›´æ–°
            }
            next = current + 1;
        } while (!counter.compareAndSet(current, next));

        return true;
    }
}</code></pre>
                <p class="conclusion">åŸå­ç±»æä¾›äº†é«˜æ€§èƒ½çš„çº¿ç¨‹å®‰å…¨æ“ä½œï¼Œç‰¹åˆ«é€‚åˆè®¡æ•°å™¨ã€çŠ¶æ€æ ‡å¿—ç­‰åœºæ™¯ã€‚</p>
            </div>
        </section>

        <!-- Slide 12: Concurrent Collections -->
        <section class="slide">
            <div class="slide-content">
                <h2>å¹¶å‘é›†åˆï¼šçº¿ç¨‹å®‰å…¨çš„å®¹å™¨</h2>
                <p>JUC æä¾›äº†å¤šç§çº¿ç¨‹å®‰å…¨çš„é›†åˆç±»ï¼Œé¿å…äº†æ‰‹åŠ¨åŒæ­¥çš„å¤æ‚æ€§ã€‚</p>

                <h3>ğŸ“¦ å¸¸ç”¨å¹¶å‘é›†åˆ</h3>
                <pre><code class="language-java">public class ConcurrentCollectionsExample {
    public static void main(String[] args) {
        // ConcurrentHashMapï¼šçº¿ç¨‹å®‰å…¨çš„ HashMap
        ConcurrentHashMap<String, Integer> concurrentMap = new ConcurrentHashMap<>();
        concurrentMap.put("key1", 100);
        concurrentMap.putIfAbsent("key2", 200); // å¦‚æœä¸å­˜åœ¨æ‰æ’å…¥

        // CopyOnWriteArrayListï¼šå†™æ—¶å¤åˆ¶çš„ Listï¼Œé€‚åˆè¯»å¤šå†™å°‘
        CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
        list.add("item1");
        list.add("item2");

        // ConcurrentLinkedQueueï¼šæ— ç•Œå¹¶å‘é˜Ÿåˆ—
        ConcurrentLinkedQueue<String> queue = new ConcurrentLinkedQueue<>();
        queue.offer("task1");
        queue.offer("task2");

        // é«˜çº§é˜»å¡é˜Ÿåˆ—ç±»å‹é€‰æ‹©
        ArrayBlockingQueue<String> arrayQueue = new ArrayBlockingQueue<>(100); // æœ‰ç•Œæ•°ç»„
        LinkedBlockingQueue<String> linkedQueue = new LinkedBlockingQueue<>(1000); // é“¾è¡¨ç»“æ„
        PriorityBlockingQueue<String> priorityQueue = new PriorityBlockingQueue<>(); // ä¼˜å…ˆçº§é˜Ÿåˆ—
        SynchronousQueue<String> syncQueue = new SynchronousQueue<>(); // ç›´æ¥ä¼ é€’é˜Ÿåˆ—

        // DelayQueueï¼šå»¶è¿Ÿé˜Ÿåˆ—
        DelayQueue<DelayedTask> delayQueue = new DelayQueue<>();

        // é«˜çº§ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼
        advancedProducerConsumer(arrayQueue, 5, 3);
    }

    // æ¨¡æ‹Ÿæ–¹æ³•
    private static void advancedProducerConsumer(ArrayBlockingQueue<String> queue,
                                               int producerCount, int consumerCount) {
            // ç”Ÿäº§è€…çº¿ç¨‹æ± 
            ExecutorService producers = Executors.newFixedThreadPool(producerCount);
            // æ¶ˆè´¹è€…çº¿ç¨‹æ± 
            ExecutorService consumers = Executors.newFixedThreadPool(consumerCount);

            // å¯åŠ¨ç”Ÿäº§è€…
            for (int i = 0; i < producerCount; i++) {
                final int producerId = i;
                producers.submit(() -> {
                    try {
                        for (int j = 0; j < 100; j++) {
                            String item = String.format("P%d-Item%d", producerId, j);
                            if (queue.offer(item, 1, TimeUnit.SECONDS)) {
                                System.out.printf("Producer %d: produced %s%n", producerId, item);
                            } else {
                                System.out.printf("Producer %d: queue full, waiting...%n", producerId);
                            }
                            Thread.sleep(50);
                        }
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                });
            }

            // å¯åŠ¨æ¶ˆè´¹è€…
            for (int i = 0; i < consumerCount; i++) {
                final int consumerId = i;
                consumers.submit(() -> {
                    try {
                        while (true) {
                            String item = queue.poll(1, TimeUnit.SECONDS);
                            if (item != null) {
                                System.out.printf("Consumer %d: consumed %s%n", consumerId, item);
                                // æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
                                Thread.sleep(100);
                            } else {
                                // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ç”Ÿäº§è€…éƒ½å®Œæˆäº†
                                if (producers.isTerminated()) {
                                    break;
                                }
                            }
                        }
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                });
            }

            producers.shutdown();
            consumers.shutdown();
        }
    }

    // å»¶è¿Ÿä»»åŠ¡ç±»
    static class DelayedTask implements Delayed {
        private final String task;
        private final long executeTime;

        DelayedTask(String task, long delayMs) {
            this.task = task;
            this.executeTime = System.currentTimeMillis() + delayMs;
        }

        @Override
        public long getDelay(TimeUnit unit) {
            return unit.convert(executeTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);
        }

        @Override
        public int compareTo(Delayed other) {
            return Long.compare(this.executeTime, ((DelayedTask) other).executeTime);
        }

        @Override
        public String toString() {
            return task;
        }
    }
}</code></pre>

                <h3>ğŸš€ é˜»å¡é˜Ÿåˆ—æ€§èƒ½ä¼˜åŒ–ç­–ç•¥</h3>
                <pre><code class="language-java">public class BlockingQueueOptimization {

    // 1. é˜Ÿåˆ—å®¹é‡é€‰æ‹©ç­–ç•¥
    public static BlockingQueue<String> selectOptimalQueue(int expectedCapacity,
                                                          String scenario) {
        switch (scenario.toLowerCase()) {
            case "high_throughput":
                // é«˜ååé‡ï¼šä½¿ç”¨æ— ç•ŒLinkedBlockingQueue
                return new LinkedBlockingQueue<>();

            case "memory_constrained":
                // å†…å­˜å—é™ï¼šä½¿ç”¨æœ‰ç•ŒArrayBlockingQueue
                return new ArrayBlockingQueue<>(expectedCapacity);

            case "fairness_required":
                // éœ€è¦å…¬å¹³ï¼šArrayBlockingQueueæ”¯æŒå…¬å¹³é”
                return new ArrayBlockingQueue<>(expectedCapacity, true);

            case "direct_handoff":
                // ç›´æ¥ä¼ é€’ï¼šSynchronousQueueï¼ˆ Executors.newCachedThreadPool() ä½¿ç”¨ï¼‰
                return new SynchronousQueue<>();

            case "priority_needed":
                // éœ€è¦ä¼˜å…ˆçº§ï¼šPriorityBlockingQueue
                return new PriorityBlockingQueue<>(expectedCapacity,
                    Comparator.comparingInt(Integer::parseInt));

            default:
                return new LinkedBlockingQueue<>(expectedCapacity);
        }
    }

    // 2. æ‰¹é‡æ“ä½œä¼˜åŒ–
    public void batchProducerConsumer() {
        BlockingQueue<List<String>> queue = new LinkedBlockingQueue<>();

        // æ‰¹é‡ç”Ÿäº§è€…
        new Thread(() -> {
            List<String> batch = new ArrayList<>(100);
            for (int i = 0; i < 10000; i++) {
                batch.add("item-" + i);
                if (batch.size() == 100) {
                    queue.offer(batch); // æ‰¹é‡æ’å…¥
                    batch = new ArrayList<>(100);
                }
            }
        }).start();

        // æ‰¹é‡æ¶ˆè´¹è€…
        new Thread(() -> {
            try {
                while (true) {
                    List<String> batch = queue.take();
                    processBatch(batch); // æ‰¹é‡å¤„ç†
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
    }

    // 3. ç›‘æ§å’Œè°ƒä¼˜
    public void monitorQueuePerformance(BlockingQueue<?> queue) {
        ScheduledExecutorService monitor = Executors.newSingleThreadScheduledExecutor();
        monitor.scheduleAtFixedRate(() -> {
            System.out.printf("Queue size: %d, Remaining capacity: %d%n",
                queue.size(), queue.remainingCapacity());
        }, 0, 5, TimeUnit.SECONDS);
    }
}</code></pre>

                <h3>ğŸ¯ ConcurrentHashMap é«˜çº§ç‰¹æ€§</h3>
                <pre><code class="language-java">public class ConcurrentHashMapAdvanced {
    public static void main(String[] args) {
        ConcurrentHashMap<String, Long> wordCounts = new ConcurrentHashMap<>();

        // åŸå­æ“ä½œï¼šcomputeIfAbsent
        wordCounts.computeIfAbsent("hello", k -> 0L);

        // åŸå­æ“ä½œï¼šmerge (åˆå¹¶)
        wordCounts.merge("hello", 1L, Long::sum);

        // æ‰¹é‡æ“ä½œï¼šforEach
        wordCounts.forEach(1, (key, value) ->
            System.out.println(key + ": " + value));

        // æœç´¢æ“ä½œï¼šsearch
        String result = wordCounts.search(1, (key, value) ->
            value > 10 ? key : null);

        // å½’çº¦æ“ä½œï¼šreduce
        Long totalCount = wordCounts.reduceValues(1, Long::sum);

        // æ‰¹é‡æ“ä½œï¼ˆJava 8+ï¼‰
        wordCounts.replaceAll((key, value) -> value * 2);
        wordCounts.entrySet().removeIf(entry -> entry.getValue() == 0);
    }
}</code></pre>
            </div>
        </section>

        <!-- Slide 13: Best Practices -->
        <section class="slide">
            <div class="slide-content">
                <h2>JUC æœ€ä½³å®è·µå’Œå¸¸è§é™·é˜±</h2>

                <h3>âœ… æœ€ä½³å®è·µ</h3>
                <ul>
                    <li><strong>ä¼˜å…ˆä½¿ç”¨çº¿ç¨‹æ± ï¼š</strong>é¿å…æ‰‹åŠ¨åˆ›å»ºå’Œç®¡ç†çº¿ç¨‹</li>
                    <li><strong>åˆç†è®¾ç½®çº¿ç¨‹æ± å‚æ•°ï¼š</strong>æ ¹æ®ä»»åŠ¡ç±»å‹ï¼ˆCPUå¯†é›†å‹/IOå¯†é›†å‹ï¼‰è°ƒæ•´</li>
                    <li><strong>ä½¿ç”¨åˆé€‚çš„å¹¶å‘é›†åˆï¼š</strong>æ ¹æ®åœºæ™¯é€‰æ‹© ConcurrentHashMapã€CopyOnWriteArrayList ç­‰</li>
                    <li><strong>é¿å…é”ç«äº‰ï¼š</strong>ä½¿ç”¨åˆ†æ®µé”ã€è¯»å†™é”æˆ–æ— é”æ•°æ®ç»“æ„</li>
                    <li><strong>æ­£ç¡®å¤„ç†å¼‚å¸¸ï¼š</strong>åœ¨å¼‚æ­¥ä»»åŠ¡ä¸­å¦¥å–„å¤„ç†å¼‚å¸¸</li>
                    <li><strong>èµ„æºæ¸…ç†ï¼š</strong>ç¡®ä¿ ExecutorService ç­‰èµ„æºè¢«æ­£ç¡®å…³é—­</li>
                </ul>

                <h3>âŒ å¸¸è§é™·é˜±</h3>
                <pre><code class="language-java">// é™·é˜±1ï¼šçº¿ç¨‹æ± æœªå…³é—­å¯¼è‡´èµ„æºæ³„æ¼
public class BadPractice1 {
    public void badMethod() {
        ExecutorService executor = Executors.newFixedThreadPool(10);
        executor.submit(() -> System.out.println("ä»»åŠ¡æ‰§è¡Œ"));
        // å¿˜è®°è°ƒç”¨ executor.shutdown()
    }
}

// é™·é˜±2ï¼šé”™è¯¯åœ°ä½¿ç”¨ synchronized æ›¿ä»£ JUC å·¥å…·
public class BadPractice2 {
    private final List<String> list = new ArrayList<>();

    public void addItem(String item) {
        synchronized (list) { // ä¸å¦‚ä½¿ç”¨ CopyOnWriteArrayList
            list.add(item);
        }
    }
}

// é™·é˜±3ï¼šé˜»å¡æ“ä½œå¿˜è®°å¤„ç† InterruptedException
public class BadPractice3 {
    public void badSleep() {
        try {
            Thread.sleep(1000); // å¯èƒ½è¢«ä¸­æ–­ä½†æœªå¤„ç†
        } catch (InterruptedException e) {
            // é”™è¯¯ï¼šå¿½ç•¥ä¸­æ–­ä¿¡å·
        }
    }
}</code></pre>

                <h3>ğŸ” æ€§èƒ½è°ƒä¼˜å»ºè®®</h3>
                <pre><code class="language-java">// æ€§èƒ½è°ƒä¼˜ç¤ºä¾‹
public class PerformanceOptimization {

    // CPU å¯†é›†å‹ä»»åŠ¡ï¼šçº¿ç¨‹æ•° = CPU æ ¸å¿ƒæ•°
    public ExecutorService cpuIntensivePool() {
        int cores = Runtime.getRuntime().availableProcessors();
        return new ThreadPoolExecutor(
            cores, cores, 0L, TimeUnit.MILLISECONDS,
            new LinkedBlockingQueue<>()
        );
    }

    // IO å¯†é›†å‹ä»»åŠ¡ï¼šçº¿ç¨‹æ•°å¯ä»¥é€‚å½“å¢åŠ 
    public ExecutorService ioIntensivePool() {
        int cores = Runtime.getRuntime().availableProcessors();
        return new ThreadPoolExecutor(
            cores * 2, cores * 4, 60L, TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(1000)
        );
    }

    // ç›‘æ§çº¿ç¨‹æ± æ€§èƒ½
    public void monitorPool(ThreadPoolExecutor executor) {
        ScheduledExecutorService monitor = Executors.newScheduledThreadPool(1);
        monitor.scheduleAtFixedRate(() -> {
            System.out.printf("æ´»è·ƒçº¿ç¨‹: %d, é˜Ÿåˆ—å¤§å°: %d, å·²å®Œæˆä»»åŠ¡: %d%n",
                executor.getActiveCount(),
                executor.getQueue().size(),
                executor.getCompletedTaskCount());
        }, 0, 5, TimeUnit.SECONDS);
    }
}</code></pre>
                <p class="conclusion">æŒæ¡ JUC ä¸ä»…èƒ½æå‡ç¨‹åºæ€§èƒ½ï¼Œè¿˜èƒ½å†™å‡ºæ›´å¥å£®ã€å¯ç»´æŠ¤çš„å¹¶å‘ä»£ç ã€‚å®è·µæ˜¯æœ€å¥½çš„è€å¸ˆï¼Œå¤šå†™å¤šç»ƒæ‰èƒ½ç²¾é€šã€‚</p>
            </div>
        </section>

        <!-- UI Elements -->
        <div class="progress-bar-container">
            <div id="progress-bar"></div>
        </div>
        <div class="controls">
            <button id="prevBtn">ä¸Šä¸€é¡µ</button>
            <span id="slide-counter">1 / X</span>
            <button id="nextBtn">ä¸‹ä¸€é¡µ</button>
        </div>
    </main>

    <script src="../prism/prism.js"></script>
    <script src="../prism/prism-autoloader.min.js"></script>
    <script src="./js/ppt.js"></script>
    <script src="./js/nav.js"></script>
</body>
</html>