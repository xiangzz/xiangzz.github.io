<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>面向对象基础篇</title>
    <link rel="stylesheet" href="./css/style.css">
    <link rel="stylesheet" href="./css/animation.css">
    <link rel="stylesheet" href="./css/hacker-cmd.css">
    <link rel="stylesheet" href="../prism/prism.css">
</head>

<body>

    <main id="presentation">
        <!-- Slide 1: Title -->
        <section class="slide title-slide active">
            <h1>Java方法详解</h1>
            <p>Java Methods - Complete Guide</p>
            <strong>掌握方法的定义、调用与高级特性</strong>
        </section>

        <!-- Quote Slide -->
        <section class="slide">
            <div class="slide-content" style="text-align: center;">
                <blockquote
                    style="font-size: 1.3em; font-style: italic; border-left: 4px solid var(--accent-color); padding-left: 20px;">
                    <p>工欲善其事，必先利其器。</p>
                    <cite style="display: block; text-align: right; margin-top: 20px;">——《论语·卫灵公》</cite>
                </blockquote>
            </div>
        </section>

        <!-- Slide 21: this Keyword -->
        <section class="slide">
            <div class="slide-content">
                <h2>变量遮盖问题</h2>
                <p>首先，让我们看一个完整的Person类定义：</p>
                <pre><code class="language-java">public class Person {
    String name;    // 成员变量（实例变量）
    
    void setName(String name) {    // 参数变量
        // 这里有两个name变量：成员变量name 和 参数name
    }
}</code></pre>
                <p><strong>什么是变量遮盖？</strong></p>
                <p>当方法参数或局部变量与成员变量同名时，会发生<strong>变量遮盖</strong>现象。</p>
                <p>Java会优先使用<strong>作用域最近</strong>的变量，即参数或局部变量会"遮盖"成员变量。</p>
                <pre><code class="language-java">void setName(String name) {
    name = name;    // ❌ 错误！这里的两个name都是指参数name
                    // 相当于：参数name = 参数name（自己赋值给自己）
}</code></pre>
                <p>让我们测试一下这个问题：</p>
                <pre><code class="language-java">public static void main(String[] args) {
    Person p = new Person();
    System.out.println("修改前：" + p.name);    // 输出：null
    p.setName("小明");
    System.out.println("修改后：" + p.name);    // 输出：null（没有改变！）
}</code></pre>
            </div>
        </section>

        
        <section class="slide">
            <div class="slide-content">
                <h2>this关键字：解决变量遮盖问题</h2>
                <p><strong>什么是this关键字？</strong></p>
                <p><code>this</code>是Java中的一个特殊关键字，它代表<strong>当前对象的引用</strong>。通过this，我们可以明确地访问当前对象的成员变量和方法。</p>
                
                <p><strong>使用this解决变量遮盖：</strong></p>
                <pre><code class="language-java">void setName(String name) {
    this.name = name;   // ✅ 正确！
    // this.name 指向成员变量
    // name 指向参数变量
}</code></pre>
                
                <p>让我们验证修复效果：</p>
                <pre><code class="language-java">public static void main(String[] args) {
    Person p = new Person();
    System.out.println("修改前：" + p.name);    // 输出：null
    p.setName("小明");
    System.out.println("修改后：" + p.name);    // 输出：小明 ✅
}</code></pre>
                
                <p><strong>this的使用规则：</strong></p>
                <ul>
                    <li><strong>必须使用</strong>：当存在变量遮盖时</li>
                    <li><strong>可选使用</strong>：当没有变量遮盖时</li>
                </ul>
                <pre><code class="language-java">String getName() {
    return name;        // 可以省略this，因为没有遮盖
    // return this.name; // 也可以显式使用this，更清晰
}</code></pre>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>this关键字的其他使用场景</h2>
                <p><strong>1. 构造方法中的this</strong></p>
                <pre><code class="language-java">public class Person {
    String name;
    int age;
    
    // 构造方法中经常需要使用this来避免遮盖
    public Person(String name, int age) {
        this.name = name;    // 必须使用this
        this.age = age;      // 必须使用this
    }
}</code></pre>
                
                <p><strong>2. 方法链式调用</strong></p>
                <pre><code class="language-java">public class Person {
    String name;
    int age;
    
    public Person setName(String name) {
        this.name = name;
        return this;    // 返回当前对象，支持链式调用
    }
    
    public Person setAge(int age) {
        this.age = age;
        return this;    // 返回当前对象
    }
}

// 使用链式调用
Person p = new Person().setName("小明").setAge(18);</code></pre>
                
                <p><strong>3. 调用其他构造方法</strong></p>
                <pre><code class="language-java">public class Person {
    String name;
    int age;
    
    public Person() {
        this("未知", 0);    // 调用另一个构造方法
    }
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}</code></pre>
            </div>
        </section>




            <section class="slide">
            <div class="slide-content">
                <h2>参数传递机制：都是值传递</h2>
                <p>实际上参数的传递，会在调用方法的时候，对参数的值进行复制，方法中的参数变量，不是我们传入的变量本身。</p>
                <div class="example-box">
                    <h4>值传递示例（基本数据类型）</h4>
                    <pre><code class="language-java">void swap(int a, int b){   // 这个函数的目的是交换a和b的值
    int tmp = a;
    a = b;
    b = tmp;
}</code></pre>
                <p>上面的代码等价于下面的代码：</p>
                    <pre><code class="language-java">void swap(int a, int b){   
    int swap_a = a;  // 把a的盒子内的值复制来
    int swap_b = b; // 把b的盒子内的值复制来
    // 后面与a和b无关
    int tmp = swap_a;
    swap_a = swap_b;
    swap_b = tmp;
}</code></pre>
                <p>所以得到如下的执行结果：</p>
                    <pre><code class="language-java">public static void main(String[] args) {
    Person p = new Person();
    int a = 5, b = 9;   // 外面也叫a和b
    p.swap(a, b);
    System.out.println("a = " + a + ", b = " + b);   
    // 结果：a = 5, b = 9  （没有交换成功！）
}</code></pre>
                </div>
                <p class="conclusion">参数传递仅仅是值传递，我们是没有办法直接操作到外面的变量的。</p>
            </div>
        </section>

                <!-- Slide 17: Parameter Passing -->
        <section class="slide">
            <div class="slide-content">
                <h2>参数传递机制：都是值传递</h2>
                <p>实际上参数的传递，会在调用方法的时候，对参数的值进行复制，方法中的参数变量，不是我们传入的变量本身。</p>
                <div class="example-box">
                    <h4>值传递示例（引用类型）</h4>
                    <pre><code class="language-java">// 定义一个简单的包装类
class IntWrapper {
    int value;
    IntWrapper(int value) { this.value = value; }
}

void swap(IntWrapper a, IntWrapper b){   // 这个函数的目的是交换a和b的引用
    IntWrapper tmp = a;
    a = b;
    b = tmp;
}</code></pre>
                <p>上面的代码等价于下面的代码：</p>
                    <pre><code class="language-java">void swap(IntWrapper a, IntWrapper b){   
    IntWrapper swap_a = a;  // 把a的引用值复制来（指向同一个对象）
    IntWrapper swap_b = b;  // 把b的引用值复制来（指向同一个对象）
    // 后面交换的是局部变量swap_a和swap_b的引用，与外面的a和b无关
    IntWrapper tmp = swap_a;
    swap_a = swap_b;
    swap_b = tmp;
}</code></pre>
                <p>所以得到如下的执行结果：</p>
                    <pre><code class="language-java">public static void main(String[] args) {
    Person p = new Person();
    IntWrapper a = new IntWrapper(5);
    IntWrapper b = new IntWrapper(9);
    
    System.out.println("交换前: a.value = " + a.value + ", b.value = " + b.value);
    p.swap(a, b);
    System.out.println("交换后: a.value = " + a.value + ", b.value = " + b.value);   
    // 结果：a.value = 5, b.value = 9  （引用没有交换成功！）
    
    // 但是如果我们修改对象的内容：
    p.swapValues(a, b);  // 交换对象内部的值
    System.out.println("交换值后: a.value = " + a.value + ", b.value = " + b.value);   
    // 结果：a.value = 9, b.value = 5  （内容交换成功！）
}</code></pre>
                <p><strong>关键理解：</strong></p>
                <pre><code class="language-java">// 这个方法可以交换对象内部的值
void swapValues(IntWrapper a, IntWrapper b) {
    int tmp = a.value;  // 通过引用访问对象内容
    a.value = b.value;  // 修改对象内部状态
    b.value = tmp;
}</code></pre>
                </div>
                <p class="conclusion">
                    <strong>重要结论：</strong>Java中所有参数传递都是值传递！<br>
                    • 对于基本类型：传递的是数据值的副本<br>
                    • 对于引用类型：传递的是引用值的副本（指向同一个对象）<br>
                    • 我们无法改变外部变量本身，但可以通过引用修改对象的内部状态
                </p>
            </div>
        </section>


        
        <!-- Slide 22: Method Overloading -->
        <section class="slide">
            <div class="slide-content">
                <h2>方法的重载</h2>
                <p>有些时候，参数类型可能会多种多样，我们的方法需要能够同时应对多种情况：</p>
                <pre><code class="language-java">// 定义在 Person 类内部
int sum(int a, int b){
    return a + b;
}</code></pre>
                <pre><code class="language-java">public static void main(String[] args) {
    Person p = new Person();
    System.out.println(p.sum(10, 20));    //这里可以正常计算两个整数的和
}</code></pre>
                <p>现在，我们希望Person不仅能计算<strong>整数</strong>，还能计算<strong>小数</strong>。</p>
                <p>若直接传入小数，编译器会因参数类型为<strong>int</strong>而报错。此时，只需再写一个<strong>同名但参数不同</strong>的方法——这就是<strong>方法重载</strong>。
                </p>
                <p>重载规则：同名、不同参；返回类型可同可异，<strong>仅靠返回类型区分</strong>则编译失败。</p>
                <pre><code class="language-java">int sum(int a, int b){
    return a + b;
}

double sum(double a, double b){    //为了支持小数加法，我们可以进行一次重载
    return a + b;
}</code></pre>
                <p>这样就可以正常使用了：</p>
                <pre><code class="language-java">public static void main(String[] args) {
    Person p = new Person();
  	//当方法出现多个重载的情况，在调用时会自动进行匹配，选择合适的方法进行调用
    System.out.println(p.sum(1.5, 2.2));
}</code></pre>
                <p>包括我们之前一直在使用的println方法，其实也是重载了很多次的，因为要支持各种值的打印。</p>
                <p>注意，如果仅仅是返回值的不同，是不支持重载的。</p>
            </div>
        </section>



        <!-- Slide 24: Recursion -->
        <section class="slide">
            <div class="slide-content">
                <h2>递归调用</h2>
                <p>方法自己也可以调用自己：</p>
                <pre><code class="language-java">void test(){
    test();
}</code></pre>
                <p>像这样自己调用自己的行为，我们称为递归调用，如果直接这样编写，会跟上面一样，出现栈溢出错误。但是如果我们给其合理地设置出口，就不会出现这种问题，比如我们想要计算从1加到n的和：</p>
                <pre><code class="language-java">int test(int n){
    if(n == 0) return 0;
    return test(n - 1) + n;    //返回的结果是下一层返回的结果+当前这一层的n
}</code></pre>
                <p>是不是感觉很巧妙？</p>
            </div>
        </section>


        <!-- 练习题 -->
        <section class="slide">
            <div class="slide-content">
                <h2>🧠 参数传递陷阱题 - 基础类型</h2>
                <p><strong>题目1：</strong>请预测以下代码的输出结果</p>
                <pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        int a = 10;
        int b = 20;
        System.out.println("交换前: a=" + a + ", b=" + b);
        swap(a, b);
        System.out.println("交换后: a=" + a + ", b=" + b);
    }
    
    public static void swap(int x, int y) {
        int temp = x;
        x = y;
        y = temp;
        System.out.println("方法内: x=" + x + ", y=" + y);
    }
}</code></pre>
                <div class="quiz-options">
                    <p><strong>选择输出结果：</strong></p>
                    <div style="background: #f5f5f5; padding: 15px; border-radius: 8px; margin: 10px 0;">
                        <p>A) 交换前: a=10, b=20<br>
                           &nbsp;&nbsp;&nbsp;&nbsp;方法内: x=20, y=10<br>
                           &nbsp;&nbsp;&nbsp;&nbsp;交换后: a=20, b=10</p>
                        <p>B) 交换前: a=10, b=20<br>
                           &nbsp;&nbsp;&nbsp;&nbsp;方法内: x=20, y=10<br>
                           &nbsp;&nbsp;&nbsp;&nbsp;交换后: a=10, b=20</p>
                    </div>
                    <details style="margin-top: 15px;">
                        <summary style="cursor: pointer; color: #007acc; font-weight: bold;">💡 点击查看答案和解析</summary>
                        <div style="background: #e8f4fd; padding: 15px; margin-top: 10px; border-radius: 8px;">
                            <p><strong>答案：B</strong></p>
                            <p><strong>解析：</strong>Java中基础类型参数传递是<strong>值传递</strong>。方法接收的是实参值的副本，在方法内部对参数的修改不会影响原始变量。</p>
                        </div>
                    </details>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>🎯 参数传递陷阱题 - 引用类型</h2>
                <p><strong>题目2：</strong>请预测以下代码的输出结果</p>
                <pre><code class="language-java">class Person {
    String name;
    Person(String name) { this.name = name; }
}

public class Test {
    public static void main(String[] args) {
        Person p1 = new Person("张三");
        Person p2 = new Person("李四");
        System.out.println("交换前: p1=" + p1.name + ", p2=" + p2.name);
        swapPersons(p1, p2);
        System.out.println("交换后: p1=" + p1.name + ", p2=" + p2.name);
        
        changeName(p1, "王五");
        System.out.println("修改后: p1=" + p1.name);
    }
    
    public static void swapPersons(Person a, Person b) {
        Person temp = a;
        a = b;
        b = temp;
    }
    
    public static void changeName(Person p, String newName) {
        p.name = newName;
    }
}</code></pre>
                <div class="quiz-options">
                    <p><strong>选择输出结果：</strong></p>
                    <div style="background: #f5f5f5; padding: 15px; border-radius: 8px; margin: 10px 0;">
                        <p>A) 交换前: p1=张三, p2=李四<br>
                           &nbsp;&nbsp;&nbsp;&nbsp;交换后: p1=李四, p2=张三<br>
                           &nbsp;&nbsp;&nbsp;&nbsp;修改后: p1=李四</p>
                        <p>B) 交换前: p1=张三, p2=李四<br>
                           &nbsp;&nbsp;&nbsp;&nbsp;交换后: p1=张三, p2=李四<br>
                           &nbsp;&nbsp;&nbsp;&nbsp;修改后: p1=王五</p>
                    </div>
                    <details style="margin-top: 15px;">
                        <summary style="cursor: pointer; color: #007acc; font-weight: bold;">💡 点击查看答案和解析</summary>
                        <div style="background: #e8f4fd; padding: 15px; margin-top: 10px; border-radius: 8px;">
                            <p><strong>答案：B</strong></p>
                            <p><strong>解析：</strong>引用类型参数传递的是<strong>引用值的副本</strong>。swapPersons方法只是交换了局部引用变量，不影响原始引用。但changeName方法通过引用修改了对象的内容，这会影响原对象。</p>
                        </div>
                    </details>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>🔥 参数传递陷阱题 - 数组类型</h2>
                <p><strong>题目3：</strong>请预测以下代码的输出结果</p>
                <pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        int[] arr1 = {1, 2, 3};
        int[] arr2 = {4, 5, 6};
        
        System.out.println("操作前: arr1[0]=" + arr1[0] + ", arr2[0]=" + arr2[0]);
        
        swapArrays(arr1, arr2);
        System.out.println("交换数组后: arr1[0]=" + arr1[0] + ", arr2[0]=" + arr2[0]);
        
        modifyArray(arr1);
        System.out.println("修改数组后: arr1[0]=" + arr1[0]);
        
        reassignArray(arr1);
        System.out.println("重新赋值后: arr1[0]=" + arr1[0]);
    }
    
    public static void swapArrays(int[] a, int[] b) {
        int[] temp = a;
        a = b;
        b = temp;
    }
    
    public static void modifyArray(int[] arr) {
        arr[0] = 999;
    }
    
    public static void reassignArray(int[] arr) {
        arr = new int[]{100, 200, 300};
    }
}</code></pre>
                <div class="quiz-options">
                    <p><strong>选择输出结果：</strong></p>
                    <div style="background: #f5f5f5; padding: 15px; border-radius: 8px; margin: 10px 0;">
                        <p>A) 操作前: arr1[0]=1, arr2[0]=4<br>
                           &nbsp;&nbsp;&nbsp;&nbsp;交换数组后: arr1[0]=4, arr2[0]=1<br>
                           &nbsp;&nbsp;&nbsp;&nbsp;修改数组后: arr1[0]=999<br>
                           &nbsp;&nbsp;&nbsp;&nbsp;重新赋值后: arr1[0]=100</p>
                        <p>B) 操作前: arr1[0]=1, arr2[0]=4<br>
                           &nbsp;&nbsp;&nbsp;&nbsp;交换数组后: arr1[0]=1, arr2[0]=4<br>
                           &nbsp;&nbsp;&nbsp;&nbsp;修改数组后: arr1[0]=999<br>
                           &nbsp;&nbsp;&nbsp;&nbsp;重新赋值后: arr1[0]=999</p>
                    </div>
                    <details style="margin-top: 15px;">
                        <summary style="cursor: pointer; color: #007acc; font-weight: bold;">💡 点击查看答案和解析</summary>
                        <div style="background: #e8f4fd; padding: 15px; margin-top: 10px; border-radius: 8px;">
                            <p><strong>答案：B</strong></p>
                            <p><strong>解析：</strong>数组是引用类型。swapArrays和reassignArray只是修改了局部引用变量，不影响原始引用。但modifyArray通过引用修改了数组内容，会影响原数组。</p>
                        </div>
                    </details>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>💀 终极挑战题 - 综合考察</h2>
                <p><strong>题目4：</strong>请预测以下复杂代码的输出结果</p>
                <pre><code class="language-java">class Counter {
    int value;
    Counter(int value) { this.value = value; }
}

public class Test {
    public static void main(String[] args) {
        Counter c1 = new Counter(10);
        Counter c2 = new Counter(20);
        int num = 5;
        
        System.out.println("初始: c1=" + c1.value + ", c2=" + c2.value + ", num=" + num);
        
        mysteryMethod(c1, c2, num);
        System.out.println("调用后: c1=" + c1.value + ", c2=" + c2.value + ", num=" + num);
    }
    
    public static void mysteryMethod(Counter a, Counter b, int n) {
        a.value += n;           // 修改对象内容
        b = new Counter(100);   // 重新赋值引用
        b.value = 200;          // 修改新对象
        n = 999;                // 修改基础类型参数
        
        Counter temp = a;       // 引用赋值
        a = b;                  // 重新赋值引用
        temp.value = 888;       // 通过原引用修改对象
    }
}</code></pre>
                <div class="quiz-options">
                    <p><strong>选择输出结果：</strong></p>
                    <div style="background: #f5f5f5; padding: 15px; border-radius: 8px; margin: 10px 0;">
                        <p>A) 初始: c1=10, c2=20, num=5<br>
                           &nbsp;&nbsp;&nbsp;&nbsp;调用后: c1=200, c2=100, num=999</p>
                        <p>B) 初始: c1=10, c2=20, num=5<br>
                           &nbsp;&nbsp;&nbsp;&nbsp;调用后: c1=888, c2=20, num=5</p>
                        <p>C) 初始: c1=10, c2=20, num=5<br>
                           &nbsp;&nbsp;&nbsp;&nbsp;调用后: c1=15, c2=20, num=5</p>
                    </div>
                    <details style="margin-top: 15px;">
                        <summary style="cursor: pointer; color: #007acc; font-weight: bold;">💡 点击查看答案和解析</summary>
                        <div style="background: #e8f4fd; padding: 15px; margin-top: 10px; border-radius: 8px;">
                            <p><strong>答案：B</strong></p>
                            <p><strong>解析：</strong></p>
                            <ul style="text-align: left; margin: 10px 0; padding-left: 20px;">
                                <li><code>a.value += n</code>: c1.value变为15</li>
                                <li><code>b = new Counter(100)</code>: 局部变量b指向新对象，不影响c2</li>
                                <li><code>n = 999</code>: 只修改局部变量，不影响num</li>
                                <li><code>temp = a</code>: temp指向c1对象</li>
                                <li><code>a = b</code>: 局部变量a指向新对象</li>
                                <li><code>temp.value = 888</code>: 通过temp修改c1对象，c1.value变为888</li>
                            </ul>
                        </div>
                    </details>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>📚 参数传递核心总结</h2>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
                    <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; border-left: 4px solid #28a745;">
                        <h3 style="color: #28a745; margin-top: 0;">✅ 会影响原变量的操作</h3>
                        <ul style="margin: 10px 0; padding-left: 20px;">
                            <li>通过引用修改对象的<strong>内容</strong></li>
                            <li>修改数组的<strong>元素值</strong></li>
                            <li>调用对象的<strong>setter方法</strong></li>
                        </ul>
                        <pre><code class="language-java">void modify(Person p) {
    p.name = "新名字";  // ✅ 会影响
}</code></pre>
                    </div>
                    
                    <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; border-left: 4px solid #dc3545;">
                        <h3 style="color: #dc3545; margin-top: 0;">❌ 不会影响原变量的操作</h3>
                        <ul style="margin: 10px 0; padding-left: 20px;">
                            <li>修改基础类型参数的<strong>值</strong></li>
                            <li>重新赋值引用类型参数的<strong>引用</strong></li>
                            <li>让引用指向<strong>新对象</strong></li>
                        </ul>
                        <pre><code class="language-java">void noEffect(Person p) {
    p = new Person();  // ❌ 不会影响
}</code></pre>
                    </div>
                </div>
                
                <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 10px; margin-top: 20px; text-align: center;">
                    <h3 style="margin: 0;">🎯 记忆口诀</h3>
                    <p style="font-size: 1.2em; margin: 15px 0; font-weight: bold;">
                        "值传递是规则，引用传副本<br>
                        修改内容可影响，重新赋值不相关"
                    </p>
                </div>
            </div>
        </section>



        <!-- UI Elements -->
        <div class="progress-bar-container">
            <div id="progress-bar"></div>
        </div>
        <div class="controls">
            <button id="prevBtn">上一页</button>
            <span id="slide-counter">1 / X</span>
            <button id="nextBtn">下一页</button>
        </div>
    </main>

    <script src="./js/animation.js"></script>
    <script src="./js/ppt.js"></script>
    <script src="../prism/prism.js"></script>
    <script src="../prism/prism-autoloader.min.js"></script>
    <script src="./js/nav.js"></script>
</body>

</html>