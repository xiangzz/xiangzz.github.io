<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java 多线程基础</title>
    <link rel="stylesheet" href="./css/style.css">
    <link rel="stylesheet" href="../prism/prism.css">
    <link rel="stylesheet" href="./css/multithread.css">
</head>
<body>

    <main id="presentation">
        <section class="slide title-slide active">
            <h1>多线程基础</h1>
            <p>面向对象程序设计（Java）</p>
            <strong>掌握线程创建、状态与同步，理解并发三要素</strong>
        </section>



        <section class="slide">
            <div class="slide-content">
                <h2>前置知识：进程与线程</h2>
                <div class="media-block">
                    <div class="media-block__text">
                        <h3>进程 = "独立的舞台"</h3>
                        <img src="images/15-multithread-process.png" alt="进程" style="width: 80%;">
                        <ul>
                            <li>每个进程有独立的内存空间（堆、栈、代码段）</li>
                            <li>进程间通信需要 IPC（管道、共享内存、消息队列）</li>
                            <li>创建进程开销大：需要分配内存、复制资源</li>
                            <li>例子：打开浏览器、启动 IDE、运行音乐播放器，各是一个进程</li>
                        </ul>
                    </div>
                    <div class="media-block__visual">
                        <h3>线程 = "舞台上的演员"</h3>
                        <img src="images/15-multithread-process-and-thread.png" alt="线程" style="width: 80%;">
                        <ul>
                            <li>线程属于某个进程，共享该进程的内存空间</li>
                            <li>每个线程有自己的栈（局部变量）和程序计数器</li>
                            <li>线程间通信简单：直接读写共享变量</li>
                            <li>例子：浏览器同时下载文件、渲染页面、响应用户输入，各是线程</li>
                        </ul>
                    </div>
                </div>
                <div class="highlight-box">
                    <strong>类比记忆</strong>
                    <ul>
                        <li>进程就像"舞台"：独立的场地，独立的灯光、独立的音响、独立的道具</li>
                        <li>线程就像"演员"：共享舞台的资源（灯光、音响），各自表演</li>
                        <li>多进程 = 多个舞台，各演各的戏，互不干扰但成本高</li>
                        <li>多线程 = 一个舞台多个演员，资源共享但需要协调（同步）避免冲突</li>
                    </ul>
                </div>
                <p class="conclusion">Java 程序默认有一个主线程（main），可以通过创建新线程实现并发执行。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>为什么需要多线程</h2>
                <p class="problem-intro">你点了一下“导出报表”按钮，整个窗口瞬间卡住，进度条一动不动。5秒后界面才恢复——<strong>单线程的代价</strong>。</p>
                <div class="media-block">
                    <div class="media-block__text">
                        <h3>问题：GUI卡死</h3>
                        <ul>
                            <li>主线程既要响应界面，又要执行耗时任务</li>
                            <li>耗时任务阻塞事件派发线程，界面失去响应</li>
                            <li>把任务搬出主线程，窗口即可继续流畅操作</li>
                        </ul>
                    </div>
                    <div class="media-block__visual">
                        <h3>线程=“不卡”的代价</h3>
                        <ul>
                            <li>线程切换开销远小于进程，适合并发与响应式场景</li>
                            <li>同进程内线程共享堆与方法区，通信零拷贝</li>
                            <li>但共享可变数据必须正确同步，否则结果错乱</li>
                        </ul>
                    </div>
                </div>
                <p class="conclusion">先解决“卡”，再解决“乱”——多线程先让程序不卡，再用同步保证不乱。</p>
            </div>
        </section>

        <!-- 演示链接：串并发对比 -->
        <section class="slide">
            <div class="slide-content">
                <h2>交互式演示：串行 vs 并发 vs 并行</h2>

                <div class="demo-link-card">
                    <div class="demo-card-header">
                        <h3>🎬 可视化对比演示</h3>
                    </div>
                    <div class="demo-card-body">
                        <p class="demo-description">
                            通过动画直观对比三种执行模式的差异，理解"并发"和"并行"的本质区别。
                        </p>
                        <ul class="demo-highlights">
                            <li>✨ 观察3个任务在不同模式下的执行顺序和时间</li>
                            <li>✨ 理解单核并发（时间片轮转）vs 多核并行（同时执行）</li>
                            <li>✨ 感受性能差异，直观理解多线程的优势</li>
                        </ul>
                    </div>
                    <div class="demo-card-footer">
                        <a href="./15-multithread-advantage.html" target="_blank" class="btn-demo-link">
                            <span class="btn-icon">🚀</span>
                            <span class="btn-text">打开串并发对比演示</span>
                            <span class="btn-hint">（新窗口）</span>
                        </a>
                    </div>
                </div>

                <p class="conclusion">
                    建议在学习理论后，通过交互式演示加深理解。
                    观察完成演示后返回教程，继续学习线程与任务的概念。
                </p>
            </div>
        </section>

        <!-- 在这里我觉得先要介绍一下"线程"与"任务" -->

        <section class="slide">
            <div class="slide-content">
                <h2>线程与任务：演员与剧本</h2>
                <div class="media-block">
                    <div class="media-block__text">
                        <div class="highlight-box">
                            <strong>核心概念</strong>
                            <ul>
                                <li><strong>线程（Thread）= 演员</strong>：被动的表演者，拥有独立的栈和程序计数器，由JVM调度上台</li>
                                <li><strong>任务（Task/Runnable）= 剧本</strong>：演员表演的具体内容，定义在 run() 方法中</li>
                                <li><strong>调度器 = 导演</strong>：决定哪个演员上台，换演员时当前演员就停止表演</li>
                            </ul>
                        </div>
                        <p><strong>为什么要分离？</strong></p>
                        <ul>
                            <li><strong>灵活复用</strong>：同一剧本可以由多个演员表演（如多窗口卖票）</li>
                            <li><strong>资源优化</strong>：演员可以表演不同剧本（线程池复用）</li>
                            <li><strong>解耦设计</strong>：剧本内容与演员管理分离，代码更清晰</li>
                        </ul>
                    </div>
                    <div class="media-block__visual">
                        <pre><code class="language-java">// 剧本 = 表演内容（演什么）
Runnable script = () -> {
    System.out.println("表演中...");
};

// 演员 = 表演载体（谁来演）
Thread actor1 = new Thread(script);
Thread actor2 = new Thread(script);

actor1.start(); // 演员1上台表演
actor2.start(); // 演员2上台表演</code></pre>
                        <p class="conclusion">演员只是被动的表演者，它不"理解"剧本的情节，只是按顺序表演台词。导演决定谁上台，不关心演员在表演什么剧本。</p>
                    </div>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>创建线程：继承 Thread</h2>
                <div class="columns-2-vertical">
                    <div class="text-block">
                        <p><strong>核心思想：</strong> 定义一个线程类，重写 <code>run()</code> 方法。</p>
                        <ul>
                            <li><strong>步骤：</strong>
                                <ol>
                                    <li>继承 <code>Thread</code> 类</li>
                                    <li>重写 <code>run()</code> 方法（定义任务）</li>
                                    <li>创建子类对象</li>
                                    <li>调用 <code>start()</code> 启动</li>
                                </ol>
                            </li>
                            <li class="warn"><strong>缺点：</strong> Java 是单继承机制，继承了 Thread 就无法继承其他业务类，耦合度高。</li>
                        </ul>
                    </div>
                    <div class="code-block">
                        <pre><code class="language-java">class MyThread extends Thread {
    public void run() {
        for (int i = 0; i &lt; 3; i++) {
            System.out.println("工作: " + i);
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Thread t = new MyThread();
        t.start(); // 必须调用 start 而不是 run
    }
}</code></pre>
                    </div>
                </div>
                <p class="conclusion">继承方式简单直接，常用于快速测试，但在实际开发中较少使用。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>创建线程：实现 Runnable</h2>
                <div class="columns-2-vertical">
                    <div class="text-block">
                        <p><strong>核心思想：</strong> 将"任务"与"线程"分离，实现解耦。</p>
                        <ul>
                            <li><strong>优势：</strong>
                                <ul>
                                    <li><strong>避免单继承局限：</strong> 任务类还可以继承其他类。</li>
                                    <li><strong>资源共享：</strong> 多个线程可以共享同一个 Runnable 对象中的数据。</li>
                                    <li><strong>线程池支持：</strong> 线程池只接收 Runnable/Callable 任务。</li>
                                </ul>
                            </li>
                        </ul>

                        <div class="highlight-box" style="background:#fff3e0; border-left:4px solid #ff9800; margin-top:16px;">
                            <strong>💡 观察要点：</strong>
                            <ul style="margin:8px 0; padding-left:20px;">
                                <li>两个线程共享同一个 <code>TicketTask</code> 对象</li>
                                <li>共享 <code>tickets</code> 变量，从10减到0</li>
                                <li>两个窗口交替卖票，体现并发执行</li>
                            </ul>
                        </div>
                    </div>
                    <div class="code-block">
                        <pre><code class="language-java">class TicketTask implements Runnable {
    private int tickets = 10;  // 共享资源：10张票

    public void run() {
        while (tickets > 0) {
            System.out.println(Thread.currentThread().getName() +
                " 卖出第 " + tickets-- + " 张票");
            try {
                Thread.sleep(100);  // 模拟卖票耗时
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

public class Main {
    public static void main(String[] args) {
        TicketTask task = new TicketTask();

        // 两个窗口同时卖票，共享同一批票
        new Thread(task, "窗口A").start();
        new Thread(task, "窗口B").start();
    }
}

// 输出示例（每次运行不同）：
// 窗口A 卖出第 10 张票
// 窗口B 卖出第 9 张票
// 窗口A 卖出第 8 张票
// 窗口B 卖出第 7 张票
// ...</code></pre>
                    </div>
                </div>
                <p class="conclusion">
                    这是最常用的基础创建方式，不仅解耦，还更方便资源共享。
                    <strong>注意：</strong>这里尚未加锁，后面会学习如何用 synchronized 解决并发问题。
                </p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>* 进阶：带返回值的异步任务</h2>
                <p>在基础多线程中，我们学习了 <code>Thread</code> 和 <code>Runnable</code>。但如果任务需要返回值呢？</p>

                <div class="highlight-box" style="background:#e3f2fd; border-left:4px solid #2196f3; margin: 20px 0;">
                    <strong>📖 进阶学习：</strong> Callable 和 Future
                    <ul style="margin: 10px 0; padding-left: 20px;">
                        <li><strong>Callable&lt;V&gt;</strong>：类似 Runnable，但可以返回值并抛出异常</li>
                        <li><strong>Future</strong>：表示异步计算的结果，可以获取、取消、检查任务状态</li>
                        <li>这些工具属于 <code>java.util.concurrent</code> 包（JUC）</li>
                    </ul>
                    <p style="margin: 10px 0 0 0;">
                        <strong>详细内容请参见：</strong>第16章 JUC并发编程 → "Callable与Future：带返回值的异步任务"
                    </p>
                </div>

                <div class="media-block">
                    <div class="media-block__text">
                        <h3>🎯 为什么需要 Callable？</h3>
                        <ul>
                            <li><strong>Runnable 的局限：</strong>无返回值，不能抛 checked 异常</li>
                            <li><strong>Callable 的优势：</strong>有返回值，支持异常处理</li>
                            <li><strong>典型场景：</strong>并发计算、批量数据处理、异步IO结果获取</li>
                        </ul>
                    </div>
                    <div class="media-block__visual">
                        <h3>📚 学习路径</h3>
                        <div style="background:#f8f9fa; padding:15px; border-radius:8px; border:2px dashed #ddd;">
                            <p style="margin:0;"><strong>第15章（这里）</strong><br>
                            ✅ Thread + synchronized<br>
                            ✅ Runnable + wait/notify<br>
                            ✅ 基础并发控制</p>
                            <p style="margin:10px 0 0 0;">⬇️</p>
                            <p style="margin:10px 0 0 0;"><strong>第16章（下一步）</strong><br>
                            📌 线程池 + Callable<br>
                            📌 Future 异步结果<br>
                            📌 CompletableFuture</p>
                        </div>
                    </div>
                </div>

                <p class="conclusion">
                    掌握 Thread 和 Runnable 已经足够应对大部分基础并发场景。
                    当需要更强大的异步编程能力时，继续学习 JUC 中的 Callable 和 Future。
                </p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>启动与基本控制</h2>
                <div class="method-cards">
                    <div class="method-card">
                        <div class="method-card__info">
                            <h3 class="method-card__title">start()</h3>
                            <p class="method-card__desc">启动新线程，JVM会在新线程中异步调用该线程的run()方法。</p>
                            <ul class="method-card__points">
                                <li>创建新线程并分配资源</li>
                                <li>调用start后线程进入RUNNABLE状态</li>
                                <li>多次调用start会抛出IllegalThreadStateException</li>
                            </ul>
                            <p class="method-card__note">🎭 导演（调度器）喊"开拍"，演员（线程）上台开始表演。直接调用run()就像自己在后台念剧本，根本没上台！</p>
                        </div>
                        <div class="method-card__code">
                            <pre><code class="language-java">Thread t = new Thread(() -> {
    System.out.println("新线程执行中...");
});
t.start(); // 启动新线程
System.out.println("主线程继续...");</code></pre>
                        </div>
                    </div>

                    <div class="method-card">
                        <div class="method-card__info">
                            <h3 class="method-card__title">sleep(long millis)</h3>
                            <p class="method-card__desc">让当前线程暂停执行指定的毫秒数，进入TIMED_WAITING状态。</p>
                            <ul class="method-card__points">
                                <li>释放CPU但不会释放锁</li>
                                <li>休眠结束后重新进入就绪队列等待调度</li>
                                <li>抛出InterruptedException需处理</li>
                            </ul>
                            <p class="method-card__note">🎭 演员说"中场休息5分钟"，先到后台歇会儿，让其他演员接着演。休息完再上台继续表演。</p>
                        </div>
                        <div class="method-card__code">
                            <pre><code class="language-java">Thread t = new Thread(() -> {
    for (int i = 0; i < 3; i++) {
        System.out.println("任务" + i);
        try {
            Thread.sleep(500); // 休眠500ms
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
});
t.start();</code></pre>
                        </div>
                    </div>

                    <div class="method-card">
                        <div class="method-card__info">
                            <h3 class="method-card__title">yield()</h3>
                            <p class="method-card__desc">建议调度器当前线程愿意让出CPU给其他线程。</p>
                            <ul class="method-card__points">
                                <li>只是建议，不保证一定会切换</li>
                                <li>线程仍处于RUNNABLE状态</li>
                                <li>优先级相同的线程间更可能有效</li>
                            </ul>
                            <p class="method-card__note">🎭 演员礼貌地说"要不先让别的演员演会儿？"但导演可能不理会，继续让这个演员演。</p>
                        </div>
                        <div class="method-card__code">
                            <pre><code class="language-java">Thread t1 = new Thread(() -> {
    for (int i = 0; i < 5; i++) {
        Thread.yield(); // 建议让出CPU
        System.out.println("线程1: " + i);
    }
});
Thread t2 = new Thread(() -> {
    for (int i = 0; i < 5; i++) {
        System.out.println("线程2: " + i);
    }
});
t1.start();
t2.start();</code></pre>
                        </div>
                    </div>

                    <div class="method-card">
                        <div class="method-card__info">
                            <h3 class="method-card__title">join()</h3>
                            <p class="method-card__desc">等待目标线程执行完毕后再继续执行当前线程。</p>
                            <ul class="method-card__points">
                                <li>调用者线程进入WAITING状态</li>
                                <li>目标线程执行完毕后调用者恢复</li>
                                <li>可指定超时时间：join(long millis)</li>
                            </ul>
                            <p class="method-card__note">🎭 主角（主线程）在后台等配角（子线程）演完，配角谢幕下台后，主角才继续登台表演。</p>
                        </div>
                        <div class="method-card__code">
                            <pre><code class="language-java">Thread worker = new Thread(() -> {
    for (int i = 0; i < 3; i++) {
        System.out.println("工作中..." + i);
        try { Thread.sleep(300); } catch (Exception e) {}
    }
});
worker.start();
worker.join(); // 等待worker完成
System.out.println("工作完成！");</code></pre>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- 演示链接：线程控制方法 -->
        <section class="slide">
            <div class="slide-content">
                <h2>交互式演示：线程控制方法</h2>

                <div class="demo-link-card">
                    <div class="demo-card-header">
                        <h3>🎬 sleep() / yield() / join() 演示</h3>
                    </div>
                    <div class="demo-card-body">
                        <p class="demo-description">
                            深入理解三个关键线程控制方法的实际效果和状态变化。
                        </p>
                        <ul class="demo-highlights">
                            <li>✨ 体验线程休眠（sleep）和时间片轮转</li>
                            <li>✨ 观察join()的阻塞等待效果</li>
                            <li>✨ 理解yield()的让出机制（礼让）</li>
                        </ul>
                    </div>
                    <div class="demo-card-footer">
                        <a href="./15-multithread-basic-control.html" target="_blank" class="btn-demo-link">
                            <span class="btn-icon">🚀</span>
                            <span class="btn-text">打开线程控制演示</span>
                            <span class="btn-hint">（新窗口）</span>
                        </a>
                    </div>
                </div>

                <p class="conclusion">
                    通过交互式演示观察线程状态变化，加深对控制方法的理解。
                    掌握这些方法是实现线程协调的基础。
                </p>
            </div>
        </section>

        <!-- Slide 11a: 现实生活中的并发问题 -->
        <section class="slide">
            <div class="slide-content">
                <h2>现实生活中的并发问题</h2>

                <p class="problem-intro">
                    前面我们学习了如何创建和控制线程。现在让我们思考一个问题：
                    <strong>当多个线程同时访问和修改共享数据时，会发生什么？</strong>
                </p>

                <div class="highlight-box" style="background:#fff3e0; border-left:4px solid #ff9800; margin-bottom:20px;">
                    <strong>🤔 先思考一下：</strong>
                    <p style="margin:8px 0;">在卖票示例（Slide 7）中，两个线程共享同一个 <code>TicketTask</code> 对象，并发地修改 <code>tickets</code> 变量。你有没有想过：如果两个线程恰好同时执行 <code>tickets--</code>，会发生什么？</p>
                    <p style="margin:8px 0; font-size:0.9rem; color:#e65100;">
                        答案是：<strong>可能会卖出相同的票号，或者数据丢失！</strong>
                        让我们通过生活中的场景来理解这个问题。
                    </p>
                </div>

                <div class="media-block">
                    <div class="media-block__text">
                        <h3>🎬 场景1：银行存款</h3>
                        <div class="highlight-box">
                            <strong>问题：两人同时存钱</strong>
                            <ul>
                                <li>账户余额：1000元</li>
                                <li>丈夫读取余额：1000元</li>
                                <li>妻子也读取余额：1000元（还没看到丈夫的修改）</li>
                                <li>丈夫存入500元 → 1500元</li>
                                <li>妻子存入300元 → 1300元（覆盖了丈夫的1500）</li>
                                <li><strong style="color:#c62828;">❌ 结果：1300元，应该是1800元！</strong></li>
                            </ul>
                        </div>

                        <h3>🎫 场景2：火车票售票</h3>
                        <div class="highlight-box">
                            <strong>问题：两个窗口同时卖最后一张票</strong>
                            <ul>
                                <li>剩余票数：1张</li>
                                <li>窗口A查询：有票</li>
                                <li>窗口B查询：有票（还没看到A的扣减）</li>
                                <li>窗口A卖出 → 剩余0张</li>
                                <li>窗口B卖出 → 剩余0张（但已经卖出！）</li>
                                <li><strong style="color:#c62828;">❌ 结果：超卖1张票！</strong></li>
                            </ul>
                        </div>
                    </div>

                    <div class="media-block__visual">
                        <h3>🔍 问题根源</h3>
                        <div class="highlight-box" style="background:#fff3e0; border-left:4px solid #ff9800;">
                            <strong>关键发现：</strong>
                            <ul>
                                <li><strong>"读-改-写"不是原子操作</strong></li>
                                <li>在"改"的过程中，其他人可能也在"读"</li>
                                <li>大家都基于旧值修改，导致数据丢失</li>
                                <li>这叫做：<strong style="color:#e65100;">竞态条件（Race Condition）</strong></li>
                            </ul>
                        </div>

                        <h3>⚡ 为什么会这样？</h3>
                        <p style="margin-bottom:12px;">在计算机中，一个简单的 <code>i++</code> 操作实际分成三步：</p>
                        <div style="background:#f5f5f5; padding:12px; border-radius:8px; font-family:monospace;">
                            1. READ: 读取 i 的值<br>
                            2. MODIFY: 计算 i+1<br>
                            3. WRITE: 写回新值
                        </div>
                        <p style="margin-top:12px; color:#666;">
                            如果线程A在步骤2时，线程B执行了步骤1，两个线程都会基于相同的旧值进行修改！
                        </p>

                        <div class="highlight-box" style="background:#e3f2fd; border-left:4px solid #2196f3; margin-top:16px;">
                            <strong>💡 解决思路：</strong>
                            <p style="margin:8px 0;">生活中需要"排队"和"加锁"来避免冲突，程序中也是一样。</p>
                            <p style="margin:8px 0; font-size:0.95rem;">在多线程环境下，我们必须使用<strong>同步机制</strong>来保证数据的一致性。</p>
                        </div>
                    </div>
                </div>

                <p class="conclusion">
                    现实中的并发问题时刻发生：银行存款、火车票、库存扣减...
                    理解这些问题后，让我们看看如何在代码中复现和解决它们。
                </p>
            </div>
        </section>

        <!-- Slide 11b: 并发编程的三大特性 -->
        <section class="slide">
            <div class="slide-content">
                <h2>并发编程的三大特性</h2>

                <div class="highlight-box" style="background:#e8f5e9; border-left:4px solid #4caf50; margin-bottom:20px;">
                    <strong>📚 知识框架：</strong>
                    <p style="margin:8px 0;">在并发编程中，我们面临的线程安全问题都可以归结为三个核心特性：原子性、可见性、有序性。</p>
                    <p style="margin:8px 0; font-size:0.9rem; color:#2e7d32;">理解这三大特性，是掌握并发编程的基础！</p>
                </div>

                <p class="problem-intro">
                    刚才我们看到了生活中的并发问题。现在让我们把视角转回代码：
                    <strong>两个线程各给计数器加100000次，结果应该是200000，但实际往往更少</strong>。
                </p>

                <div class="highlight-box" style="background:#f3f5ff; border-left:4px solid #7e57c2; margin-bottom:20px;">
                    <strong>🎯 学习目标：</strong>
                    <p style="margin:8px 0;">通过这个例子，我们将学习：</p>
                    <ul style="margin:8px 0; padding-left:20px; font-size:0.9rem;">
                        <li>为什么 <code>i++</code> 不是线程安全的？</li>
                        <li>什么是原子性、可见性、有序性？</li>
                        <li>如何用 <code>synchronized</code> 解决并发问题？</li>
                    </ul>
                </div>

                <div class="media-block">
                    <div class="media-block__text">
                        <div class="highlight-box">
                            <strong>🔍 案发现场：20000次更新去哪了？</strong>
                            <ul>
                                <li><code>i++</code> 在字节码里是"取值→+1→写回"三步</li>
                                <li>线程A写回前，线程B也读到旧值</li>
                                <li>线程B也+1，然后写回，覆盖了A的结果</li>
                                <li>一次自增丢失，累加就是"少"</li>
                            </ul>
                        </div>

                        <h3>💡 并发编程三大特性</h3>
                        <p style="margin-bottom:12px; color:#666; font-size:0.95rem;">
                            Java内存模型（JMM）定义了并发编程需要关注的三个核心问题：
                        </p>

                        <!-- 原子性 -->
                        <div class="highlight-box" style="background:#e3f2fd; border-left:4px solid #2196f3; margin-bottom:12px;">
                            <strong>1. 原子性 (Atomicity)</strong>
                            <p style="margin:8px 0; font-size:0.9rem;"><strong>定义：</strong>操作不可分割，要么全部执行成功，要么全部不执行。</p>
                            <p style="margin:8px 0; font-size:0.85rem; color:#666;">
                                <strong>类比：</strong>就像转账操作，要么"扣款+入账"同时成功，要么同时失败，不能只扣款不入账。<br>
                                <strong>本例问题：</strong><code>i++</code> 不是原子操作（分三步），导致数据丢失。<br>
                                <strong>解决方案：</strong>用 <code>synchronized</code> 或锁保证原子性。
                            </p>
                        </div>

                        <!-- 可见性 -->
                        <div class="highlight-box" style="background:#e3f2fd; border-left:4px solid #2196f3; margin-bottom:12px;">
                            <strong>2. 可见性 (Visibility)</strong>
                            <p style="margin:8px 0; font-size:0.9rem;"><strong>定义：</strong>一个线程对共享变量的修改，其他线程能够立即看到。</p>
                            <p style="margin:8px 0; font-size:0.85rem; color:#666;">
                                <strong>类比：</strong>就像公告栏，一个人贴了通知，其他人应该马上能看到。<br>
                                <strong>问题：</strong>每个线程有自己的缓存，修改不会立即同步到主内存。<br>
                                <strong>解决方案：</strong>用 <code>volatile</code> 或 <code>synchronized</code> 保证可见性。
                            </p>
                        </div>

                        <!-- 有序性 -->
                        <div class="highlight-box" style="background:#fff3e0; border-left:4px solid #ff9800; margin-bottom:12px;">
                            <strong>3. 有序性 (Ordering)</strong>
                            <p style="margin:8px 0; font-size:0.9rem;"><strong>定义：</strong>程序执行的顺序按照代码的先后顺序执行。</p>
                            <p style="margin:8px 0; font-size:0.85rem; color:#666;">
                                <strong>问题：</strong>编译器和处理器为了优化性能，可能会<strong>指令重排序</strong>。<br>
                                <strong>影响：</strong>单线程不影响结果，但多线程可能导致问题。<br>
                                <strong>解决方案：</strong>用 <code>volatile</code> 禁止指令重排序（详见后续volatile章节）。
                            </p>
                        </div>

                        <p style="margin-top:16px;"><strong>🎯 本节重点：</strong>用锁把三步打包成一步，保证原子性。</p>
                    </div>
                    <div class="media-block__visual">
                        <pre><code class="language-java">public class RaceCounter {
    static int counter = 0;

    public static void main(String[] args) throws Exception {
        Runnable r = () -&gt; {
            for (int i = 0; i &lt; 100000; i++) {
                counter++; // 非原子操作！
            }
        };

        Thread t1 = new Thread(r);
        Thread t2 = new Thread(r);

        t1.start();
        t2.start();

        t1.join();
        t2.join();

        System.out.println(counter);
        // 输出可能是 180000、195000、198000...
        // 几乎永远不是 200000
    }
}</code></pre>
                        <p class="conclusion">给"读-改-写"加锁，三步变一步，200000次更新不再丢失。</p>
                        <div class="demo-card" style="margin-top:12px;">
                            <div>
                                <button id="raceBtn" style="padding:6px 12px;">无锁竞速</button>
                                <button id="safeBtn" style="padding:6px 12px;">加锁竞速</button>
                                <div style="margin-top:8px;font-size:12px;">预计200000，当前：<span id="raceRes" class="result-bad">未开始</span></div>
                            </div>
                            <div style="display:flex;gap:8px;">
                                <div style="flex:1;">线程1<br><div class="bar-wrap"><div id="r1" class="bar"></div></div></div>
                                <div style="flex:1;">线程2<br><div class="bar-wrap"><div id="r2" class="bar"></div></div></div>
                            </div>
                        </div>
                    </div>
                </div>

                <p class="conclusion">
                    <strong>学习路径：</strong>本节重点讲解原子性（synchronized），可见性和有序性将在后续volatile章节深入展开。
                </p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>synchronized：互斥与可重入</h2>
                <div class="media-block">
                    <div class="media-block__text">
                        <ul>
                            <li>对象监视器互斥进入临界区</li>
                            <li>方法与代码块两种写法</li>
                            <li>同一线程可重入同一锁</li>
                        </ul>
                    </div>
                    <div class="media-block__visual">
                        <pre><code class="language-java">class SafeCounter {
    private int value;
    private final Object lock = new Object();
    public void inc() {
        synchronized (lock) { value++; }
    }
    public synchronized int get() { return value; }
}

public class Main {
    public static void main(String[] args) throws Exception {
        SafeCounter c = new SafeCounter();
        Runnable r = () -&gt; { for (int i = 0; i &lt; 100000; i++) c.inc(); };
        Thread t1 = new Thread(r); Thread t2 = new Thread(r);
        t1.start(); t2.start(); t1.join(); t2.join();
        System.out.println(c.get());
    }
}</code></pre>
                        <p class="conclusion">选择稳定的锁对象，避免将锁暴露给外部。</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- 演示链接：临界区与互斥锁 -->
        <section class="slide">
            <div class="slide-content">
                <h2>交互式演示：临界区与互斥锁</h2>

                <div class="demo-link-card">
                    <div class="demo-card-header">
                        <h3>🎬 临界区冲突演示</h3>
                    </div>
                    <div class="demo-card-body">
                        <p class="demo-description">
                            通过"试衣间"类比，直观理解临界区概念和互斥锁的作用。
                        </p>
                        <ul class="demo-highlights">
                            <li>✨ 对比无保护和有锁保护两种场景</li>
                            <li>✨ 观察冲突发生时的视觉效果（震动）</li>
                            <li>✨ 理解synchronized如何保证线程安全</li>
                        </ul>
                    </div>
                    <div class="demo-card-footer">
                        <a href="./15-multithread-critical-section.html" target="_blank" class="btn-demo-link">
                            <span class="btn-icon">🚀</span>
                            <span class="btn-text">打开临界区演示</span>
                            <span class="btn-hint">（新窗口）</span>
                        </a>
                    </div>
                </div>

                <p class="conclusion">
                    通过可视化演示理解临界区冲突和互斥锁的保护机制。
                    synchronized是Java中最基础也最重要的同步工具。
                </p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>线程生命周期与状态</h2>
                <div class="media-block">
                    <div class="media-block__text">
                    <table style="width:100%; border-collapse: collapse;">
                            <thead>
                                <tr style="background:#f8f9fa;">
                                    <th style="border:1px solid #ddd; padding:.5rem;">状态</th>
                                    <th style="border:1px solid #ddd; padding:.5rem;">含义</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr><td style="border:1px solid #ddd; padding:.5rem;">NEW</td><td style="border:1px solid #ddd; padding:.5rem;">新建未启动</td></tr>
                                <tr><td style="border:1px solid #ddd; padding:.5rem;">RUNNABLE</td><td style="border:1px solid #ddd; padding:.5rem;">就绪或运行中</td></tr>
                                <tr><td style="border:1px solid #ddd; padding:.5rem;">BLOCKED</td><td style="border:1px solid #ddd; padding:.5rem;">等待锁 (如 synchronized)</td></tr>
                                <tr><td style="border:1px solid #ddd; padding:.5rem;">WAITING</td><td style="border:1px solid #ddd; padding:.5rem;">无限期等待通知</td></tr>
                                <tr><td style="border:1px solid #ddd; padding:.5rem;">TIMED_WAITING</td><td style="border:1px solid #ddd; padding:.5rem;">限时等待 (如 sleep)</td></tr>
                                <tr><td style="border:1px solid #ddd; padding:.5rem;">TERMINATED</td><td style="border:1px solid #ddd; padding:.5rem;">执行完毕</td></tr>
                            </tbody>
                        </table>
                    </div>
                    <div class="media-block__visual">
                        <pre><code class="language-java">public class StateDemo {
    static final Object lock = new Object();
    public static void main(String[] args) throws Exception {
        Thread t = new Thread(() -&gt; {
            synchronized (lock) {
                try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); }
            }
        }, "T");
        System.out.println(t.getState());
        t.start();
        System.out.println(t.getState());
        synchronized (lock) {
            Thread.sleep(1000);
        }
        System.out.println(t.getState());
        t.join();
        System.out.println(t.getState());
    }
}</code></pre>
                        <p class="conclusion">通过同步与休眠观察状态变化，理解调度与锁竞争。</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- 演示链接：线程状态机 -->
        <section class="slide">
            <div class="slide-content">
                <h2>交互式演示：线程状态机</h2>

                <div class="demo-link-card">
                    <div class="demo-card-header">
                        <h3>🎬 线程状态转换演示</h3>
                    </div>
                    <div class="demo-card-body">
                        <p class="demo-description">
                            探索Java线程的6种状态以及它们之间的转换关系。
                        </p>
                        <ul class="demo-highlights">
                            <li>✨ 交互式状态转换图，触发各种状态变化</li>
                            <li>✨ 观察BLOCKED、WAITING、TIMED_WAITING的区别</li>
                            <li>✨ 理解锁等待和wait()等待的不同机制</li>
                        </ul>
                    </div>
                    <div class="demo-card-footer">
                        <a href="./15-multithread-state.html" target="_blank" class="btn-demo-link">
                            <span class="btn-icon">🚀</span>
                            <span class="btn-text">打开线程状态机演示</span>
                            <span class="btn-hint">（新窗口）</span>
                        </a>
                    </div>
                </div>

                <p class="conclusion">
                    通过交互式状态机深入理解线程生命周期。
                    掌握线程状态转换是调试并发问题的关键。
                </p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>对象监视器：wait/notify</h2>
                <p class="problem-intro">生产者速度翻倍，仓库瞬间爆仓OOM；消费者速度翻倍，CPU空转飙高——<strong>快慢不协调，资源全浪费</strong>。</p>
                <div class="media-block">
                    <div class="media-block__text">
                        <div class="highlight-box">
                            <strong>案发现场：爆仓与空转</strong>
                            <ul>
                                <li>while(size==cap) 空转sleep→CPU狂飙</li>
                                <li>while(size==0) 空转sleep→内存暴涨</li>
                                <li>快的一方需要“睡”，慢的一方负责“叫醒”</li>
                            </ul>
                        </div>
                        <p>wait让线程睡并放锁；notify/notifyAll精准叫醒等待者。</p>
                    </div>
                    <div class="media-block__visual">
                        <pre><code class="language-java">import java.util.LinkedList;

class BoundedQueue&lt;T&gt; {
    private final LinkedList&lt;T&gt; q = new LinkedList&lt;&gt;();
    private final int cap;
    public BoundedQueue(int cap) { this.cap = cap; }
    public synchronized void put(T x) throws InterruptedException {
        // 必须使用 while 循环检查条件，防止虚假唤醒
        while (q.size() == cap) wait();
        q.add(x);
        notifyAll();
    }
    public synchronized T take() throws InterruptedException {
        // 必须使用 while 循环检查条件，防止虚假唤醒
        while (q.isEmpty()) wait();
        T x = q.removeFirst();
        notifyAll();
        return x;
    }
}</code></pre>
                        <p class="conclusion">用wait/notify把“空转”变“睡眠”，仓库不再爆仓，CPU不再空转。</p>
                        <div class="demo-card" style="margin-top:12px;">
                            <div>
                                <label>生产者速度：<input type="range" id="prodSpeed" min="1" max="10" value="5"></label><br>
                                <label>消费者速度：<input type="range" id="consSpeed" min="1" max="10" value="5"></label>
                                <div style="margin-top:8px;">仓库容量：<span id="cap">0</span>/10 <span id="warn"></span></div>
                            </div>
                            <div style="display:flex;gap:4px;height:20px;" id="boxes"></div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- 演示链接：并发一致性 -->
        <section class="slide">
            <div class="slide-content">
                <h2>交互式演示：并发一致性问题</h2>

                <div class="demo-link-card">
                    <div class="demo-card-header">
                        <h3>🎬 银行存款并发演示</h3>
                    </div>
                    <div class="demo-card-body">
                        <p class="demo-description">
                            通过"银行存款"场景，演示多线程并发操作共享数据时可能出现的数据丢失问题。
                        </p>
                        <ul class="demo-highlights">
                            <li>✨ 手动控制两个线程的执行步骤（READ-MODIFY-WRITE）</li>
                            <li>✨ 观察"读-改-写"操作的冲突和数据覆盖</li>
                            <li>✨ 理解数据竞争的成因和同步的必要性</li>
                        </ul>
                    </div>
                    <div class="demo-card-footer">
                        <a href="./15-multithread-consistency.html" target="_blank" class="btn-demo-link">
                            <span class="btn-icon">🚀</span>
                            <span class="btn-text">打开并发一致性演示</span>
                            <span class="btn-hint">（新窗口）</span>
                        </a>
                    </div>
                </div>

                <p class="conclusion">
                    通过逐步控制的并发场景，理解可见性和原子性问题。
                    这是学习volatile和synchronized的重要基础。
                </p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>volatile：可见性与有序性</h2>
                <div class="media-block">
                    <div class="media-block__text">
                        <ul>
                            <li>保证写对其他线程可见</li>
                            <li>禁止特定指令重排序</li>
                            <li>不提供复合操作原子性</li>
                        </ul>
                    </div>
                    <div class="media-block__visual">
                        <pre><code class="language-java">public class VolatileStop {
    static volatile boolean running = true;
    public static void main(String[] args) throws Exception {
        Thread t = new Thread(() -&gt; {
            long i = 0;
            while (running) { i++; }
            System.out.println(i);
        });
        t.start();
        Thread.sleep(200);
        running = false;
        t.join();
    }
}</code></pre>
                        <p class="conclusion">适用于状态标志等场景，复合更新需配合同步或原子类。</p>
                    </div>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>ThreadLocal：每线程独立变量</h2>
                <div class="media-block">
                    <div class="media-block__text">
                        <ul>
                            <li>避免共享可变状态</li>
                            <li>适合格式化器、上下文信息</li>
                            <li>注意显式清理避免泄漏</li>
                        </ul>
                    </div>
                    <div class="media-block__visual">
                        <pre><code class="language-java">import java.text.SimpleDateFormat;

public class TL {
    static final ThreadLocal&lt;SimpleDateFormat&gt; fmt = ThreadLocal.withInitial(() -&gt; new SimpleDateFormat("yyyy-MM-dd"));
    public static void main(String[] args) throws Exception {
        Runnable r = () -&gt; {
            String s = fmt.get().format(new java.util.Date());
            System.out.println(Thread.currentThread().getName() + " - " + s);
            fmt.remove();
        };
        new Thread(r, "T1").start();
        new Thread(r, "T2").start();
    }
}</code></pre>
                        <p class="conclusion">使用remove在任务结束后清理，避免线程池中的跨任务污染。</p>
                    </div>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>常见陷阱与避免</h2>
                <div class="columns-3">
                    <div class="highlight-box">
                        <strong>死锁</strong>
                        <pre><code class="language-java">class Dead { Object a = new Object(); Object b = new Object();
    void f1() { synchronized(a) { synchronized(b) {} } }
    void f2() { synchronized(b) { synchronized(a) {} } }
}</code></pre>
                        <ul>
                            <li>统一加锁顺序</li>
                            <li>减少持锁时间</li>
                        </ul>
                    </div>
                    <div class="highlight-box">
                        <strong>活锁/饥饿</strong>
                        <ul>
                            <li>过度让步导致无进展</li>
                            <li>高优先级长期占用</li>
                        </ul>
                    </div>
                    <div class="highlight-box">
                        <strong>错误协调</strong>
                        <ul>
                            <li>用sleep代替通知</li>
                            <li>条件判断未用while</li>
                        </ul>
                    </div>
                </div>
                <p class="conclusion">采用固定锁序与条件循环，使用通知机制进行正确协作。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>课堂练习</h2>
                <ul>
                    <li>实现多线程售票系统，比较非同步与同步输出差异</li>
                    <li>编写生产者-消费者模型，控制队列容量与吞吐</li>
                    <li>使用volatile实现停止信号，与synchronized版本对比</li>
                </ul>
                <p class="conclusion">提交可运行代码与结果截图，标注关键同步点与原因。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>回到最初问题：我们解决了什么？</h2>
                <div class="columns-3">
                    <div class="highlight-box">
                        <strong>1. 界面卡死</strong><br>
                        <span style="color:#2e7d32;">✅ 耗时任务放线程，窗口依旧流畅</span>
                    </div>
                    <div class="highlight-box">
                        <strong>2. 200000次自增少了</strong><br>
                        <span style="color:#2e7d32;">✅ 给"读-改-写"加锁，三步变一步</span>
                    </div>
                    <div class="highlight-box">
                        <strong>3. 仓库爆仓/空转</strong><br>
                        <span style="color:#2e7d32;">✅ wait/notify让快的人睡，慢的人叫</span>
                    </div>
                </div>
                <p class="conclusion">多线程先解决"卡"，再解决"乱"；锁、信号量、阻塞队列都是让"不乱"的工具。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>下一步：进入 JUC 高并发编程</h2>
                <p>掌握了基础多线程后，我们发现在实际开发中仍然面临许多挑战：</p>

                <div class="media-block">
                    <div class="media-block__text">
                        <h3>🤔 基础多线程的局限</h3>
                        <ul>
                            <li><strong>线程管理复杂：</strong>手动创建销毁线程，资源管理困难</li>
                            <li><strong>并发控制有限：</strong>synchronized 性能有限，功能单一</li>
                            <li><strong>工具缺乏：</strong>缺乏丰富的并发工具和容器</li>
                            <li><strong>异步编程困难：</strong>Future 使用繁琐，无法链式调用</li>
                            <li><strong>性能优化难：</strong>缺乏高性能的无锁数据结构</li>
                        </ul>
                    </div>
                    <div class="media-block__visual">
                        <h3>🚀 JUC 带来的突破</h3>
                        <ul>
                            <li><strong>线程池框架：</strong>ThreadPoolExecutor 自动管理线程</li>
                            <li><strong>高级锁机制：</strong>ReentrantLock、ReadWriteLock 提供更灵活控制</li>
                            <li><strong>丰富同步工具：</strong>CountDownLatch、CyclicBarrier、Semaphore</li>
                            <li><strong>高性能并发集合：</strong>ConcurrentHashMap、BlockingQueue</li>
                            <li><strong>原子操作类：</strong>AtomicInteger、AtomicReference 实现无锁编程</li>
                            <li><strong>异步编程革命：</strong>CompletableFuture 支持链式调用</li>
                        </ul>
                    </div>
                </div>

                <h3>📚 学习路径建议</h3>
                <div class="highlight-box" style="background:#e3f2fd; border-left:4px solid #2196f3;">
                    <strong>下一步学习推荐顺序：</strong>
                    <ol style="margin: 10px 0; padding-left: 20px;">
                        <li><strong>16-juc.html - Java并发编程(JUC)</strong>：系统学习JUC工具包</li>
                        <li><strong>17-nio.html - NIO与网络编程</strong>：学习高性能IO编程</li>
                        <li><strong>实战项目练习</strong>：结合实际项目巩固并发技能</li>
                    </ol>
                </div>

                <p class="conclusion">从基础多线程到JUC，是从"手工作坊"到"工业化生产"的飞跃。JUC让并发编程变得简单、高效、可靠！</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>并发可视化演示：计数器竞态</h2>
                <div class="demo-card">
                    <div>
                        <div class="demo-controls">
                            <button id="startRace">开始无锁</button>
                            <button id="startSync">开始加锁</button>
                            <button id="resetDemo">重置</button>
                        </div>
                        <div style="margin-top:12px; display:grid; grid-template-columns:1fr 1fr; gap:12px;">
                            <div>
                                <div class="metric">累计操作：<span id="ops">0</span></div>
                                <div class="metric">共享计数：<span id="val">0</span></div>
                            </div>
                            <div>
                                <div class="metric">预计结果：<span id="expect">0</span></div>
                                <div class="metric">正确性：<span id="ok" class="result-bad">未开始</span></div>
                            </div>
                        </div>
                    </div>
                    <div>
                        <div>线程1进度</div>
                        <div class="bar-wrap"><div id="bar1" class="bar"></div></div>
                        <div style="margin-top:12px;">线程2进度</div>
                        <div class="bar-wrap"><div id="bar2" class="bar"></div></div>
                    </div>
                </div>
                <p class="conclusion">比较无锁与加锁的计数结果，直观感受数据竞争与互斥效果。</p>
            </div>
        </section>


        <div class="progress-bar-container">
            <div id="progress-bar"></div>
        </div>
        <div class="controls">
            <button id="prevBtn">上一页</button>
            <span id="slide-counter">1 / X</span>
            <button id="nextBtn">下一页</button>
        </div>
    </main>

    <script src="../prism/prism.js"></script>
    <script src="../prism/prism-autoloader.min.js"></script>
    <script src="./js/ppt.js"></script>
    <script src="./js/nav.js"></script>
    <script src="./js/multithread.js"></script>
    <script src="./js/imgbed-replacer.js"></script>
    <script src="js/chat-with-ai.js"></script>
</body>
</html>