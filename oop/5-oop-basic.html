<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>面向对象基础篇</title>
    <link rel="stylesheet" href="./css/style.css">
    <link rel="stylesheet" href="./css/animation.css">
    <link rel="stylesheet" href="./css/hacker-cmd.css">
    <link rel="stylesheet" href="../prism/prism.css">
</head>
<body>

    <main id="presentation">
        <!-- Slide 1: Title -->
        <section class="slide title-slide active">
            <h1>面向对象基础篇</h1>
            <p>Object Oriented Programming - Basic</p>
            <strong>从面向过程到面向对象的编程思维转变</strong>
        </section>

         <!-- Quote Slide -->
        <section class="slide">
            <div class="slide-content" style="text-align: center;">
                <blockquote
                    style="font-size: 1.3em; font-style: italic; border-left: 4px solid var(--accent-color); padding-left: 20px;">
                    <p>所谓视界不是眼球所看到的画像，是大脑所理解的画像。</p>
                    <p>我们的视野被我们的常识所保护着，人是无法脱离自己的局限而活下去的</p>
                    <p>……本来的话。</p>
                    <cite style="display: block; text-align: right; margin-top: 20px;">——苍崎橙子《空之境界》</cite>
                </blockquote>
                <img src="./images/5-aozaki.webp" alt="cover2" style="width: 80%;">
            </div>
        </section>

        <!-- Slide 2: Introduction -->
        <section class="slide">
            <div class="slide-content">
                <h2>从面向过程到面向对象</h2>
                <p>在前面的学习中，我们已经掌握了面向过程编程的基础知识，能够独立编写简单的程序。</p>
                <p>接下来我们将深入学习<strong>面向对象编程（Object Oriented Programming）</strong>，这是Java语言的核心特性之一。</p>
                <ul>
                    <li><strong>面向对象</strong>是现代高级编程语言的重要特征</li>
                    <li>面向对象概念对于初学者而言是一个重要的学习节点</li>
                    <li>部分学习者能够快速理解，而另一些可能需要更多时间来掌握</li>
                    <li>本章内容难度有所提升，建议认真学习和实践</li>
                </ul>
                <p class="conclusion">熟练掌握面向对象编程是成为优秀Java开发者的关键一步。</p>
            </div>
        </section>

        <!-- Slide 3: What is Class and Object -->
        <section class="slide">
            <div class="slide-content">
                <h2>什么是类与对象？</h2>
                <p>我们在日常生活中其实经常听到"类"这个词。比如说人类、鸟类、鱼类等等。</p>
                <div class="concept-explanation">
                    <div class="concept-item">
                        <h3>类（Class）</h3>
                        <p>对一类东西的概括，是一种<strong>抽象的概念</strong>。比如鸟类，指的是所有具备鸟的特点的动物。</p>
                    </div>
                    <div class="concept-item">
                        <h3>对象（Object）</h3>
                        <p>这类事物中的每一个<strong>具体存在的个体</strong>，也叫实例。我们每个人都是人类这个大类别下的一个具体的例子。</p>
                    </div>
                </div>
                
                <!-- 类与对象关系动画演示 -->
                <div class="class-object-animation">
                    <div class="animation-container">
                        <div class="class-template">
                            <h4>Person 类</h4>
                            <div class="class-content">
                                <div class="attribute">姓名: ?</div>
                                <div class="attribute">年龄: ?</div>
                                <div class="attribute">职业: ?</div>
                                <div class="method">说话()</div>
                                <div class="method">工作()</div>
                            </div>
                        </div>
                        
                        <div class="arrow-container">
                            <div class="instantiation-arrow">实例化</div>
                        </div>
                        
                        <div class="objects-container">
                            <div class="object-instance" data-delay="0">
                                <h4>张三</h4>
                                <div class="object-content">
                                    <div class="attribute">姓名: 张三</div>
                                    <div class="attribute">年龄: 25</div>
                                    <div class="attribute">职业: 程序员</div>
                                </div>
                            </div>
                            
                            <div class="object-instance" data-delay="1">
                                <h4>李四</h4>
                                <div class="object-content">
                                    <div class="attribute">姓名: 李四</div>
                                    <div class="attribute">年龄: 30</div>
                                    <div class="attribute">职业: 设计师</div>
                                </div>
                            </div>
                            

                        </div>
                    </div>
                    
                    <div class="animation-controls">
                        <button id="startAnimation" class="animation-btn">开始演示</button>
                        <button id="resetAnimation" class="animation-btn">重新开始</button>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 4: Class vs Object Example -->
        <section class="slide">
            <div class="slide-content">
                <h2>类与对象的禅</h2>
                <div class="dialogue-example">
                    <div class="dialogue-item">
                        <strong>师父：</strong>什么是美？
                    </div>
                    <div class="dialogue-item">
                        <strong>弟子：</strong>花是美的。<span class="annotation">（花这个类）</span>
                    </div>
                    <div class="dialogue-item">
                        <strong>师父：</strong>花只是概念，真正的美在哪里？
                    </div>
                    <div class="dialogue-item">
                        <strong>弟子：</strong>在那朵正在绽放的莲花中。<span class="annotation">（具体的莲花对象）</span>
                    </div>
                    <div class="dialogue-item">
                        <strong>师父：</strong>悟了。类是万物之理，对象是万物之形。
                    </div>
                </div>
                <p class="conclusion">
                    <strong>类</strong>就是抽象概念的人，而<strong>对象</strong>，就是具体的某一个人。
                </p>
                <p>在Java中，我们可以定义一个类，然后进一步创建许多这个类的实例对象，让所有的功能都通过对象之间的交互来表达。</p>
                <p>这种编程方式，我们称为<strong>面向对象编程</strong>。</p>
                <!-- 猪八戒吃西瓜的例子 -->
                <div class="code-comparison">
                    <div class="comparison-item">
                        <h4>面向过程编程</h4>
                        <pre><code class="language-java">// 函数调用方式
eat(猪八戒, 西瓜);</code></pre>
                        <p>将数据和操作分离，通过函数调用来实现功能</p>
                    </div>
                    <div class="comparison-item">
                        <h4>面向对象编程</h4>
                        <pre><code class="language-java">// 对象方法调用方式
猪八戒.eat(西瓜);</code></pre>
                        <p>将数据和操作封装在对象中，通过对象间交互实现功能</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 5: Defining a Class -->
        <section class="slide">
            <div class="slide-content">
                <h2>类的定义与对象创建</h2>
                <p>接下来我们将学习如何定义一个类。以定义人类为例，演示类的创建过程：</p>
                <div class="step-by-step">
                    <div class="step">
                        <h4>步骤1：创建类文件</h4>
                        <p>在src目录上右键，选择创建新的Java类，命名为Person</p>
                        <ul>
                            <li>类名通常使用英文单词</li>
                            <li><strong>首字母必须大写</strong></li>
                            <li>不能包含特殊字符</li>
                        </ul>
                    </div>
                    <div class="step">
                        <h4>步骤2：基本类结构</h4>
                        <pre><code class="language-java">class Person {
    
}</code></pre>
                        <p>这与Main类的结构相同，Main本身也是一个类。</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 6: Class Attributes -->
        <section class="slide">
            <div class="slide-content">
                <h2>添加类的属性</h2>
                <p>既然是"人类"，那肯定要有与人相关的属性，比如名字、性别、年龄等。</p>
                <p>我们可以把这些<strong>属性直接定义为类的成员变量</strong>。</p>
                <pre><code class="language-java">public class Person {   
    // 这里定义的人类具有三个属性：名字、年龄、性别
    String name;   // 直接在类中定义变量，表示类具有的属性
    int age;
    String sex;
}</code></pre>
                <div class="important-note">
                    <h4>重要概念</h4>
                    <p><strong>成员变量</strong>就是这个类拥有的属性，每个实例创建出来后，这些属性的值可以各不相同。</p>
                    <p>这些变量只有在一个具体的对象中才可以使用。</p>
                </div>
            </div>
        </section>

        <!-- Slide 7: Creating Objects -->
        <section class="slide">
            <div class="slide-content">
                <h2>创建对象</h2>
                <p>现在人类的属性都规定好了，我们就可以尝试创建一个实例对象了。</p>
                <div class="syntax-box">
                    <h4>语法格式</h4>
                    <pre><code class="language-java">new 类名();</code></pre>
                </div>
                <div class="example-box">
                    <h4>实际例子</h4>
                    <pre><code class="language-java">public static void main(String[] args) {
    new Person();   // 使用new关键字来创建某个类的对象
                   // 注意new后面需要跟上 类名()
                   // 这里创建出来的，就是一个具体的人了
}</code></pre>
                </div>
                <p class="conclusion">整个流程为：定义类 → 创建对象 → 使用对象</p>
            </div>
        </section>

        <!-- Slide 8: Using Objects -->
        <section class="slide">
            <div class="slide-content">
                <h2>对象的使用</h2>
                <p>现在我们知道了怎么创建对象，那接下来怎么去使用这个对象呢？</p>
                <p>我们可以用一个变量来代表这个对象：</p>
                <pre><code class="language-java">public static void main(String[] args) {
    // 这里的a存放的是具体的某个值
    int a = 10;
    
    // 创建一个变量指代我们刚刚创建好的对象
    // 变量的类型就是对应的类名
    // 这里的p存放的是对象的引用，而不是本体
    Person p = new Person();
}</code></pre>
                <div class="important-note">
                    <h4>重要概念：引用类型</h4>
                    <p>这种变量存的是对象的"地址"或"引用"，而不是直接存储对象本身。</p>
                    <p>因此，这个变量的类型也被称为"引用类型"，而不再是"基本类型"（如int, double）。</p>
                </div>
            </div>
        </section>

        <!-- Slide 9: Object References -->
        <section class="slide">
            <div class="slide-content">
                <h2>对象引用的概念</h2>
                <p>为什么对象类型的变量存放的是对象的引用？看下面的例子：</p>
                <pre><code class="language-java">public static void main(String[] args) {
    Person p1 = new Person();
    Person p2 = p1;  // 这只是传递了对象的引用
}</code></pre>
                <p>赋值之后，现在p2和p1都指向同一个对象（如果你学过C语言，这就有点像指针的概念）。</p>
                
                <!-- 内存模型动画演示 -->
                <div class="memory-model-animation">
                    <div class="memory-comparison">
                        <!-- 基本类型内存模型 -->
                        <div class="memory-section">
                            <h4>基本类型内存模型</h4>
                            <div class="memory-area stack-area">
                                <div class="memory-label">栈内存 (Stack)</div>
                                <div class="variable-container">
                                    <div class="variable-box primitive-var" data-step="1">
                                        <div class="var-name">int a</div>
                                        <div class="var-value">10</div>
                                    </div>
                                    <div class="variable-box primitive-var" data-step="2">
                                        <div class="var-name">int b</div>
                                        <div class="var-value">10</div>
                                    </div>
                                </div>
                            </div>
                            <div class="code-snippet">
                                <code>int a = 10;<br>int b = a;</code>
                            </div>
                        </div>

                        <!-- 引用类型内存模型 -->
                        <div class="memory-section">
                            <h4>引用类型内存模型</h4>
                            <div class="memory-layout">
                                <div class="memory-area stack-area">
                                    <div class="memory-label">栈内存 (Stack)</div>
                                    <div class="variable-container">
                                        <div class="variable-box reference-var" data-step="3">
                                            <div class="var-name">Person p1</div>
                                            <div class="var-value reference-arrow">@0x1001</div>
                                        </div>
                                        <div class="variable-box reference-var" data-step="4">
                                            <div class="var-name">Person p2</div>
                                            <div class="var-value reference-arrow">@0x1001</div>
                                        </div>
                                    </div>
                                </div>
                                <div class="memory-area heap-area">
                                    <div class="memory-label">堆内存 (Heap)</div>
                                    <div class="object-container">
                                        <div class="object-box" data-step="3">
                                            <div class="object-address">@0x1001</div>
                                            <div class="object-content">
                                                <div class="object-field">name: null</div>
                                                <div class="object-field">age: 0</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="code-snippet">
                                <code>Person p1 = new Person();<br>Person p2 = p1;</code>
                            </div>
                        </div>
                    </div>
                    
                    <div class="animation-controls">
                        <div class="animation-steps">
                            <div class="step-indicator" data-step="1">1. 创建基本类型变量</div>
                            <div class="step-indicator" data-step="2">2. 基本类型赋值（值拷贝）</div>
                            <div class="step-indicator" data-step="3">3. 创建对象（堆内存分配）</div>
                            <div class="step-indicator" data-step="4">4. 引用赋值（地址拷贝）</div>
                        </div>
                        <div class="animation-buttons">
                            <button id="startMemoryAnimation" class="animation-btn">开始演示</button>
                            <button id="resetMemoryAnimation" class="animation-btn">重新开始</button>
                        </div>
                    </div>
                </div>
                
                <div class="test-example">
                    <h4>测试验证</h4>
                    <pre><code class="language-java">public static void main(String[] args) {
    Person p1 = new Person();
    Person p2 = p1;
    System.out.println(p1 == p2);  // 使用 == 判断是否引用同一个对象
    // 结果：true
    
    Person p3 = new Person();  // 创建新对象
    System.out.println(p1 == p3);  // 不同对象的引用
    // 结果：false
}</code></pre>
                </div>
            </div>
        </section>

        <!-- Slide 10: Accessing Object Properties -->
        <section class="slide">
            <div class="slide-content">
                <h2>访问对象属性</h2>
                <p>现在我们有了对象的引用之后，我们就可以进行"<strong>.</strong>"操作了：</p>
                <pre><code class="language-java">public static void main(String[] args) {
    Person p = new Person();
    p.name = "小明";   // 要访问对象的属性，使用 . 运算符
    System.out.println(p.name);   // 打印对象的名字
}</code></pre>
                <div class="important-note">
                    <h4>重要特性</h4>
                    <p>不同对象的属性是分开独立存放的，每个对象都有一个自己的空间，修改一个对象的属性并不会影响到其他对象：</p>
                    <pre><code class="language-java">Person p1 = new Person();
Person p2 = new Person();
p1.name = "小明";   // 修改第一个对象的属性
p2.name = "大明";   // 修改第二个对象的属性
System.out.println(p1.name);  // 输出：小明</code></pre>
                </div>
            </div>
        </section>

        <!-- Slide 11: Null References -->
        <section class="slide">
            <div class="slide-content">
                <h2>空引用（null）</h2>
                <p>关于对象类型的变量，我们也可以不对任何对象进行引用：</p>
                <pre><code class="language-java">public static void main(String[] args) {
    Person p1 = null;  // null是一个特殊的值，表示空，不引用任何对象
}</code></pre>
<img src="./images/5-ground.jpg" alt="NullPointerException" style="max-width: 40%;">
                <div class="warning-box">
                    <h4>⚠️ 空指针异常</h4>
                    <p>若某一变量未引用任何对象，则不应通过该变量对对象进行操作：</p>
                    <pre><code class="language-java">public static void main(String[] args) {
    Person p = null;   // 此时变量没有引用任何对象
    p.name = "小红";   // ❌ 这会导致空指针异常！
    System.out.println(p.name);
}</code></pre>
                    <p>这是Java中出现频率最高的异常，一定要注意避免！</p>
                    
                </div>
            </div>
        </section>

        <!-- Slide 12: Default Values -->
        <section class="slide">
            <div class="slide-content">
                <h2>对象属性的默认值</h2>
                <p>对象创建成功之后，它的属性没有进行赋值，但是能否直接访问呢？</p>
                <pre><code class="language-java">public static void main(String[] args) {
    Person p = new Person();
    System.out.println("name = " + p.name);
    System.out.println("age = " + p.age);
    System.out.println("sex = " + p.sex);
}</code></pre>
                <div class="result-box">
                    <h4>运行结果</h4>
                    <pre><code>name = null
age = 0
sex = null</code></pre>
                </div>
                <div class="rule-box">
                    <h4>默认值规则</h4>
                    <ul>
                        <li><strong>基本类型：</strong>默认为0（boolean默认为false）</li>
                        <li><strong>引用类型：</strong>默认为null</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Slide 13: Methods Introduction -->
        <section class="slide">
            <div class="slide-content">
                <h2>方法创建与使用</h2>
                <p>光有属性还不够，对象还需要能做一些事情，就像人可以走路、跳跃、思考一样。</p>
                <p>对象也可以做各种动作，这可以通过定义<strong>方法</strong>来实现（在C语言中叫做函数）。</p>
                <div class="concept-box">
                    <h4>什么是方法？</h4>
                    <p>方法就是一组指令，用来完成特定的任务。</p>
                    <ul>
                        <li>有的任务完成后需要返回结果，比如计算两个数字的和</li>
                        <li>有的任务只需要执行操作而不需要返回结果，比如把数字打印到屏幕上</li>
                    </ul>
                </div>
                <div class="syntax-box">
                    <h4>方法定义语法</h4>
                    <pre><code>返回值类型 方法名称() {
    方法体...
}</code></pre>
                </div>
            </div>
        </section>

        <!-- Slide 14: Method Example -->
        <section class="slide">
            <div class="slide-content">
                <h2>方法实例：自我介绍</h2>
                <p>比如我们现在给人类编写一个自我介绍的行为：</p>
                <pre><code class="language-java">public class Person {
    String name;
    int age;
    String sex;

    // 自我介绍只需要完成就行，没有返回值，所以使用void
    void hello(){
        // 完成自我介绍需要执行的所有代码就在这个花括号中编写
        // 自我介绍需要用到当前对象的名字和年龄
        // 我们直接使用成员变量即可，变量的值就是当前对象的存放值
        System.out.println("我叫 " + name + " 今年 " + age + " 岁了！");
    }
}</code></pre>
                <div class="usage-example">
                    <h4>方法调用</h4>
                    <pre><code class="language-java">public static void main(String[] args) {
    Person p = new Person();
    p.name = "小明";
    p.age = 18;
    p.hello();    // 使用 . 运算符调用方法，格式：.方法名称()
}</code></pre>
                </div>
            </div>
        </section>

        <!-- Slide 15: Methods with Parameters -->
        <section class="slide">
            <div class="slide-content">
                <h2>带参数的方法</h2>
                <p>比如现在我们要让人类学会加法运算，需要别人提供两个参与加法运算的值：</p>
                <pre><code class="language-java">// 我们可以为方法设定参数，在调用方法时，需要外部传入参数
// 参数的定义需要在小括号内部编写，类似于变量定义
// 需要填写 类型和参数名称，多个参数用逗号隔开
int sum(int a, int b){   // 这里需要两个int类型的参数进行计算
    int c = a + b;   // 参数相当于在函数中定义了局部变量
    return c;   // return后面紧跟需要返回的结果
    // 带返回值的方法，是一定要有一个返回结果的！
}</code></pre>
                <div class="usage-example">
                    <h4>调用带参数的方法</h4>
                    <pre><code class="language-java">public static void main(String[] args) {
    Person p = new Person();
    p.name = "小明";
    p.age = 18;
    int result = p.sum(10, 20);    // 让这个对象帮我们计算10 + 20
    System.out.println(result);    // 成功得到30
}</code></pre>
                </div>
            </div>
        </section>

        <!-- Slide 16: Return Statement -->
        <section class="slide">
            <div class="slide-content">
                <h2>return关键字详解</h2>
                <p>关于return关键字，我们需要进行进一步的介绍：</p>
                <div class="rule-list">
                    <div class="rule-item">
                        <h4>1. 方法立即结束</h4>
                        <p>在使用return关键字之后，方法就会直接结束并返回结果，所以在这之后编写的任何代码，都是不可到达的。</p>
                        <pre><code class="language-java">int test() {
    return 10;
    System.out.println("这行代码永远不会执行"); // ❌ 编译错误
}</code></pre>
                    </div>
                    <div class="rule-item">
                        <h4>2. 分支必须都有返回值</h4>
                        <p>如果程序中出现了分支语句，那么必须保证每一个分支都有返回值：</p>
                        <pre><code class="language-java">int test(int a) {
    if (a > 0) {
        return 1;
    } else {
        return -1;  // 必须保证所有分支都有返回值
    }
}</code></pre>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 17: Parameter Passing -->
        <section class="slide">
            <div class="slide-content">
                <h2>参数传递机制</h2>
                <p>实际上参数的传递，会在调用方法的时候，对参数的值进行复制，方法中的参数变量，不是我们传入的变量本身。</p>
                <div class="example-box">
                    <h4>值传递示例</h4>
                    <pre><code class="language-java">void swap(int a, int b){   // 这个函数的目的是交换a和b的值
    int tmp = a;
    a = b;
    b = tmp;
}</code></pre>
                    <pre><code class="language-java">public static void main(String[] args) {
    Person p = new Person();
    int a = 5, b = 9;   // 外面也叫a和b
    p.swap(a, b);
    System.out.println("a = " + a + ", b = " + b);   
    // 结果：a = 5, b = 9  （没有交换成功！）
}</code></pre>
                </div>
                <p class="conclusion">参数传递仅仅是值传递，我们是没有办法直接操作到外面的变量的。</p>
            </div>
        </section>

        <!-- Slide 18: Reference Parameter Passing -->
        <section class="slide">
            <div class="slide-content">
                <h2>引用类型的参数传递</h2>
                <p>那么各位小伙伴看看下面的例子：</p>
                <pre><code class="language-java">void modify(Person person){
    person.name = "赵铁柱";   // 修改对象的名称
}</code></pre>
                <pre><code class="language-java">public static void main(String[] args) {
    Person p = new Person();
    p.name = "小明";     // 先在外面修改一次
    p.modify(p);        // 调用方法再修改一次
    System.out.println(p.name);    // 请问最后name会是什么？
}</code></pre>
                <div class="result-box">
                    <h4>运行结果</h4>
                    <pre><code>赵铁柱</code></pre>
                </div>
                <div class="explanation">
                    <h4>为什么可以修改成功？</h4>
                    <p>这里同样是进行的值传递，但是引用类型的变量存放的是对象的引用。值传递相当于将对象的引用复制到了方法内部的变量中，而这个内部的变量，依然是引用的同一个对象，所以在方法内操作，相当于直接操作外面的对象。</p>
                </div>
            </div>
        </section>

        <!-- Slide 19: Summary -->
        <section class="slide">
            <div class="slide-content">
                <h2>本章总结</h2>
                <div class="summary-grid">
                    <div class="summary-item">
                        <h3>核心概念</h3>
                        <ul>
                            <li>类是抽象的概念，对象是具体的实例</li>
                            <li>面向对象编程通过对象交互来实现功能</li>
                            <li>引用类型变量存储的是对象的引用</li>
                        </ul>
                    </div>
                    <div class="summary-item">
                        <h3>重要语法</h3>
                        <ul>
                            <li>类定义：<code>public class ClassName { }</code></li>
                            <li>对象创建：<code>new ClassName()</code></li>
                            <li>属性访问：<code>object.property</code></li>
                            <li>方法调用：<code>object.method()</code></li>
                        </ul>
                    </div>
                    <div class="summary-item">
                        <h3>注意事项</h3>
                        <ul>
                            <li>避免空指针异常</li>
                            <li>理解值传递机制</li>
                            <li>方法必须有正确的返回值</li>
                            <li>对象属性有默认值</li>
                        </ul>
                    </div>
                </div>
                <p class="conclusion">掌握了类与对象的基本概念，你就迈出了面向对象编程的第一步！</p>
            </div>
        </section>

        <!-- Slide 20: Method Advanced Usage -->
        <section class="slide">
            <div class="slide-content">
                <h2>方法进阶使用</h2>
                <p>有时候我们的方法中可能会出现一些与成员变量重名的变量：</p>
                <pre><code class="language-java">//我们希望使用这个方法，来为当前对象设定名字
void setName(String name) {
   
}</code></pre>
                <p>此时类中定义的变量名称也是name，那么我们是否可以这样编写呢：</p>
                <pre><code class="language-java">void setName(String name) {
    name = name;    //出现重名时，优先使用作用域最接近的，这里实际上是将方法参数的局部变量name赋值为本身
}</code></pre>
                <p>我们来测试一下：</p>
                <pre><code class="language-java">public static void main(String[] args) {
    Person p = new Person();
    p.setName("小明");
    System.out.println(p.name);
}</code></pre>
                <p>我们发现，似乎这样做并没有任何的效果，name依然是没有修改的状态。那么当出现重名的时候，因为默认情况下会优先使用作用域最近的变量，我们怎么才能表示要使用的变量是类的成员变量呢？</p>
            </div>
        </section>

        <!-- Slide 21: this Keyword -->
        <section class="slide">
            <div class="slide-content">
                <h2>this关键字</h2>
                <pre><code class="language-java">Person p = new Person();
p.name = "小明";    //我们之前在外面使用时，可以直接通过对象.属性的形式访问到
</code></pre>
                <p>同样的，我们如果想要在方法中访问到当前对象的属性，那么可以使用this关键字，来明确表示当前类的示例对象本身：</p>
                <pre><code class="language-java">void setName(String name) {
    this.name = name;   //让当前对象的name变量值等于参数传入的值
}</code></pre>
                <p>这样就可以修改成功了，当然，如果方法内没有变量出现重名的情况，那么默认情况下可以不使用this关键字来明确表示当前对象：</p>
                <pre><code class="language-java">String getName() {
    return name;    //这里没有使用this，但是当前作用域下只有对象属性的name变量，所以说直接就使用了
}</code></pre>
            </div>
        </section>

        <!-- Slide 22: Method Overloading -->
        <section class="slide">
            <div class="slide-content">
                <h2>方法的重载</h2>
                <p>有些时候，参数类型可能会多种多样，我们的方法需要能够同时应对多种情况：</p>
                <pre><code class="language-java">int sum(int a, int b){
    return a + b;
}</code></pre>
                <pre><code class="language-java">public static void main(String[] args) {
    Person p = new Person();
    System.out.println(p.sum(10, 20));    //这里可以正常计算两个整数的和
}</code></pre>
                <p>但是要是我们现在不仅要让人类会计算整数，还要会计算小数呢？</p>
                <p>当我们使用小数时，可以看到，参数要求的是int类型，那么肯定会出现错误，这个方法只能用于计算整数。此时，为了让这个方法支持使用小数进行计算，我们可以将这个方法进行重载。</p>
                <p>一个类中可以包含多个同名的方法，但是需要的形式参数不一样，方法的返回类型，可以相同，也可以不同，但是仅返回类型不同，是不允许的！</p>
                <pre><code class="language-java">int sum(int a, int b){
    return a + b;
}

double sum(double a, double b){    //为了支持小数加法，我们可以进行一次重载
    return a + b;
}</code></pre>
                <p>这样就可以正常使用了：</p>
                <pre><code class="language-java">public static void main(String[] args) {
    Person p = new Person();
  	//当方法出现多个重载的情况，在调用时会自动进行匹配，选择合适的方法进行调用
    System.out.println(p.sum(1.5, 2.2));
}</code></pre>
                <p>包括我们之前一直在使用的println方法，其实也是重载了很多次的，因为要支持各种值的打印。</p>
                <p>注意，如果仅仅是返回值的不同，是不支持重载的。</p>
            </div>
        </section>

        <!-- Slide 23: Method Invocation -->
        <section class="slide">
            <div class="slide-content">
                <h2>方法相互调用</h2>
                <p>当然，方法之间是可以相互调用的：</p>
                <pre><code class="language-java">void test(){
    System.out.println("我是test");   //实际上这里也是调用另一个方法
}

void say(){
    test();   //在一个方法内调用另一个方法
}</code></pre>
                <p>如果我们这样写的话：</p>
                <pre><code class="language-java">void test(){
    say();
}

void say(){
    test();
}</code></pre>
                <p>各位猜猜看会出现什么情况？</p>
                <p>此时又出现了一个我们不认识的异常，实际上什么原因导致的我们自己都很清楚，方法之间一直在相互调用，没有一个出口。</p>
            </div>
        </section>

        <!-- Slide 24: Recursion -->
        <section class="slide">
            <div class="slide-content">
                <h2>递归调用</h2>
                <p>方法自己也可以调用自己：</p>
                <pre><code class="language-java">void test(){
    test();
}</code></pre>
                <p>像这样自己调用自己的行为，我们称为递归调用，如果直接这样编写，会跟上面一样，出现栈溢出错误。但是如果我们给其合理地设置出口，就不会出现这种问题，比如我们想要计算从1加到n的和：</p>
                <pre><code class="language-java">int test(int n){
    if(n == 0) return 0;
    return test(n - 1) + n;    //返回的结果是下一层返回的结果+当前这一层的n
}</code></pre>
                <p>是不是感觉很巧妙？实际上递归调用在很多情况下能够快速解决一些很麻烦的问题，我们会在后面继续了解。</p>
            </div>
        </section>

        <!-- Slide 25: Constructor -->
        <section class="slide">
            <div class="slide-content">
                <h2>构造方法</h2>
                <p>我们接着来看一种比较特殊的方法，构造方法。</p>
                <p>我们前面创建对象，都是直接使用new关键字就能直接搞定了，但是我们发现，对象在创建之后，各种属性都是默认值，那么能否实现在对象创建时就为其指定名字、年龄、性别呢？要在对象创建时进行处理，我们可以使用构造方法（构造器）来完成。</p>
                <p>实际上每个类都有一个默认的构造方法，我们可以来看看反编译的结果：</p>
                <pre><code class="language-java">public class Person {
    String name;
    int age;
    String sex;

    public Person() {    //反编译中，多出来了这样一个方法，这其实就是构造方法
    }
}</code></pre>
                <p>构造方法不需要填写返回值，并且方法名称与类名相同，默认情况下每个类都会自带一个没有任何参数的无参构造方法（只是不用我们去写，编译出来就自带）当然，我们也可以手动声明，对其进行修改：</p>
                <pre><code class="language-java">public class Person {
    String name;
    int age;
    String sex;

    Person(){    //构造方法不需要指定返回值，并且方法名称与类名相同
        name = "小明";   //构造方法会在对象创建时执行，我们可以将各种需要初始化的操作都在这里进行处理
        age = 18;
        sex = "男";
    }
}</code></pre>
            </div>
        </section>

        <!-- Slide 26: Constructor Invocation -->
        <section class="slide">
            <div class="slide-content">
                <h2>构造方法调用</h2>
                <p>构造方法会在new的时候自动执行：</p>
                <pre><code class="language-java">public static void main(String[] args) {
    Person p = new Person();   //这里的new Person()其实就是在调用无参构造方法
    System.out.println(p.name);
}</code></pre>
                <p>当然，我们也可以为构造方法设定参数：</p>
                <pre><code class="language-java">public class Person {
    String name;
    int age;
    String sex;

    Person(String name, int age, String sex){   //跟普通方法是一样的
        this.name = name;
        this.age = age;
        this.sex = sex;
    }
}</code></pre>
                <p>注意，在我们自己定义一个构造方法之后，会覆盖掉默认的那一个无参构造方法，除非我们手动重载一个无参构造，否则要创建这个类的对象，必须调用我们自己定义的构造方法：</p>
                <pre><code class="language-java">public static void main(String[] args) {
    Person p = new Person("小明", 18, "男");   //调用自己定义的带三个参数的构造方法
    System.out.println(p.name);
}</code></pre>
                <p>我们可以去看看反编译的结果，会发现此时没有无参构造了，而是只剩下我们自己编写的。</p>
            </div>
        </section>

        <!-- Slide 27: Member Variable Initialization -->
        <section class="slide">
            <div class="slide-content">
                <h2>成员变量初始化</h2>
                <p>当然，要给成员变量设定初始值，我们不仅可以通过构造方法，也可以直接在定义时赋值：</p>
                <pre><code class="language-java">public class Person {
    String name = "未知";   //直接赋值，那么对象构造好之后，属性默认就是这个值
    int age = 10;
    String sex = "男";
}</code></pre>
                <p>这里需要特别注意，成员变量的初始化，并不是在构造方法之前之后，而是在这之前就已经完成了：</p>
                <pre><code class="language-java">Person(String name, int age, String sex){
    System.out.println(age);    //在赋值之前看看是否有初始值
    this.name = name;
    this.age = age;
    this.sex = sex;
}</code></pre>
            </div>
        </section>

        <!-- Slide 28: Code Block -->
        <section class="slide">
            <div class="slide-content">
                <h2>代码块</h2>
                <p>我们也可以在类中添加代码块，代码块同样会在对象构造之前进行，在成员变量初始化之后执行：</p>
                <pre><code class="language-java">public class Person {
    String name;
    int age;
    String sex;

    {
        System.out.println("我是代码块");   //代码块中的内容会在对象创建时仅执行一次
    }

    Person(String name, int age, String sex){
        System.out.println("我被构造了");
        this.name = name;
        this.age = age;
        this.sex = sex;
    }
}</code></pre>
                <p>只不过一般情况下使用代码块的频率比较低，标准情况下还是通过构造方法进行进行对象初始化工作，所以说这里做了解就行了。</p>
            </div>
        </section>

        <!-- Slide 29: Static Variables and Methods -->
        <section class="slide">
            <div class="slide-content">
                <h2>静态变量</h2>
                <p>静态的内容可以理解为是属于类的，是所有对象共享的。我们使用<code>static</code>关键字来声明。</p>
                <pre><code class="language-java">public class Person {
    String name;
    int age;
    static String info; // 静态变量
}</code></pre>
                <p>一个对象改变了静态变量的值，其他对象读取的就是被改变的值。</p>
                <pre><code class="language-java">public static void main(String[] args) {
    Person p1 = new Person();
    Person p2 = new Person();
    p1.info = "info:1";
    System.out.println(p2.info); // 输出: info:1
}</code></pre>
                <p>通常，我们通过类名来访问静态成员：</p>
                <pre><code class="language-java">public static void main(String[] args) {
    Person.info = "info:2";
    System.out.println(Person.info);
}</code></pre>
            </div>
        </section>

        <!-- Slide 30: Static Methods -->
        <section class="slide">
            <div class="slide-content">
                <h2>静态方法</h2>
                <p>静态方法同样属于类，而不是具体的某个对象。</p>
                <pre><code class="language-java">static void test(){
    System.out.println("我是静态方法");
}</code></pre>
                <p>在静态方法中，无法直接访问非静态的成员变量或使用<code>this</code>关键字，因为它们都与具体对象相关。但是，静态方法可以访问静态变量。</p>
                <pre><code class="language-java">static String info;

static void test(){
    System.out.println("静态变量的值为："+info);
}</code></pre>
            </div>
        </section>
        <!-- Static Variable Animation Demo -->
        <section class="slide">
            <div class="slide-content">
                <h2>静态变量动画演示</h2>
                <p>静态变量属于类，被所有对象实例共享。让我们通过动画来理解这个概念：</p>
                
                <div class="static-variable-animation">
                    <div class="animation-container">
                        <!-- Class Template -->
                        <div class="class-template">
                            <div class="class-title">Student 类</div>
                            <div class="class-content">
                                <div class="static-variable">
                                    <span class="var-label">static int count = 0;</span>
                                    <div class="static-counter" id="staticCounter">0</div>
                                </div>
                                <div class="instance-variables">
                                    <div class="var-item">String name;</div>
                                    <div class="var-item">int age;</div>
                                </div>
                            </div>
                        </div>

                        <!-- Objects Container -->
                        <div class="objects-container">
                            <div class="object-instance" id="student1">
                                <div class="object-title">student1</div>
                                <div class="object-values">
                                    <div>name: "张三"</div>
                                    <div>age: 20</div>
                                </div>
                                <div class="static-reference">
                                    <span class="reference-arrow">count → </span>
                                    <span class="shared-value" id="sharedValue1">0</span>
                                </div>
                            </div>

                            <div class="object-instance" id="student2">
                                <div class="object-title">student2</div>
                                <div class="object-values">
                                    <div>name: "李四"</div>
                                    <div>age: 21</div>
                                </div>
                                <div class="static-reference">
                                    <span class="reference-arrow">count → </span>
                                    <span class="shared-value" id="sharedValue2">0</span>
                                </div>
                            </div>

                            <div class="object-instance" id="student3">
                                <div class="object-title">student3</div>
                                <div class="object-values">
                                    <div>name: "王五"</div>
                                    <div>age: 19</div>
                                </div>
                                <div class="static-reference">
                                    <span class="reference-arrow">count → </span>
                                    <span class="shared-value" id="sharedValue3">0</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="animation-controls">
                        <button class="control-btn" onclick="createStudent()">创建新学生对象</button>
                        <button class="control-btn" onclick="incrementCount()">修改 count++</button>
                        <button class="control-btn" onclick="resetDemo()">重置演示</button>
                    </div>

                    <div class="explanation-text">
                        <p><strong>观察要点：</strong></p>
                        <ul>
                            <li>当创建新对象时，static变量count会自动增加</li>
                            <li>所有对象实例都共享同一个static变量</li>
                            <li>修改static变量会影响所有对象的访问结果</li>
                        </ul>
                    </div>
                </div>

                <style>
                .static-variable-animation {
                    background: linear-gradient(135deg, #FFFFFF, #F8FAFC);
                    border: 1px solid var(--border-color);
                    border-radius: 16px;
                    padding: 20px;
                    margin: 20px 0;
                    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
                }

                .static-variable-animation .animation-container {
                    display: flex;
                    gap: 30px;
                    margin-bottom: 30px;
                    align-items: flex-start;
                }

                .static-variable-animation .class-template {
                    background: linear-gradient(135deg, #E1F5FE, #B3E5FC);
                    border: 2px solid var(--primary-color);
                    border-radius: 12px;
                    padding: 20px;
                    min-width: 280px;
                    text-align: center;
                }

                .static-variable-animation .class-title {
                    color: var(--accent-color);
                    font-size: 1.4em;
                    font-weight: bold;
                    margin-bottom: 15px;
                }

                .static-variable-animation .static-variable {
                    background: #FFE0B2;
                    border: 2px solid #FF9800;
                    border-radius: 8px;
                    padding: 10px;
                    margin: 10px 0;
                    position: relative;
                }

                .static-variable-animation .var-label {
                    font-family: 'Roboto Mono', monospace;
                    font-size: 0.9em;
                    color: #E65100;
                    font-weight: bold;
                }

                .static-variable-animation .static-counter {
                    font-size: 2em;
                    font-weight: bold;
                    color: #FF5722;
                    margin-top: 5px;
                    transition: all 0.5s ease;
                }

                .static-variable-animation .static-counter.highlight {
                    transform: scale(1.3);
                    color: #D32F2F;
                    text-shadow: 0 0 10px rgba(211, 47, 47, 0.5);
                }

                .static-variable-animation .instance-variables {
                    margin-top: 15px;
                    text-align: left;
                }

                .static-variable-animation .var-item {
                    font-family: 'Roboto Mono', monospace;
                    font-size: 0.9em;
                    color: var(--text-color);
                    margin: 5px 0;
                    padding: 5px;
                    background: rgba(255, 255, 255, 0.7);
                    border-radius: 4px;
                }

                .static-variable-animation .objects-container {
                    flex: 1;
                    display: flex;
                    flex-direction: column;
                    gap: 15px;
                }

                .static-variable-animation .object-instance {
                    background: linear-gradient(135deg, #F3E5F5, #E1BEE7);
                    border: 2px solid var(--accent-color);
                    border-radius: 10px;
                    padding: 15px;
                    opacity: 0;
                    transform: translateX(50px);
                    transition: all 0.6s ease;
                }

                .static-variable-animation .object-instance.active {
                    opacity: 1;
                    transform: translateX(0);
                }

                .static-variable-animation .object-title {
                    color: var(--accent-color);
                    font-weight: bold;
                    font-size: 1.1em;
                    margin-bottom: 10px;
                }

                .static-variable-animation .object-values {
                    font-family: 'Roboto Mono', monospace;
                    font-size: 0.9em;
                    margin-bottom: 10px;
                }

                .static-variable-animation .static-reference {
                    background: rgba(255, 152, 0, 0.1);
                    border: 1px solid #FF9800;
                    border-radius: 6px;
                    padding: 8px;
                    font-family: 'Roboto Mono', monospace;
                    font-size: 0.9em;
                }

                .static-variable-animation .reference-arrow {
                    color: #FF5722;
                    font-weight: bold;
                }

                .static-variable-animation .shared-value {
                    color: #D32F2F;
                    font-weight: bold;
                    font-size: 1.2em;
                    transition: all 0.3s ease;
                }

                .static-variable-animation .shared-value.highlight {
                    transform: scale(1.2);
                    color: #B71C1C;
                    text-shadow: 0 0 8px rgba(183, 28, 28, 0.6);
                }

                .static-variable-animation .animation-controls {
                    display: flex;
                    justify-content: center;
                    gap: 15px;
                    margin: 20px 0;
                }

                .static-variable-animation .control-btn {
                    background-color: var(--primary-color);
                    color: white;
                    border: none;
                    padding: 12px 20px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 0.9em;
                    transition: all 0.3s ease;
                }

                .static-variable-animation .control-btn:hover {
                    background-color: var(--accent-color);
                    transform: translateY(-2px);
                    box-shadow: 0 4px 12px rgba(208, 101, 25, 0.3);
                }

                .static-variable-animation .explanation-text {
                    background: #F5F5F5;
                    border-left: 4px solid var(--primary-color);
                    padding: 15px;
                    border-radius: 0 8px 8px 0;
                    margin-top: 20px;
                }

                .static-variable-animation .explanation-text ul {
                    margin: 10px 0;
                    padding-left: 20px;
                }

                .static-variable-animation .explanation-text li {
                    margin: 8px 0;
                    font-size: 1em;
                }
                </style>

                <script>
                let currentStudentCount = 0;
                let staticCount = 0;

                function createStudent() {
                    if (currentStudentCount >= 3) return;
                    
                    currentStudentCount++;
                    staticCount++;
                    
                    // 显示对象
                    const student = document.getElementById(`student${currentStudentCount}`);
                    student.classList.add('active');
                    
                    // 更新静态计数器
                    updateStaticCounter();
                    
                    // 延迟更新共享值以显示动画效果
                    setTimeout(() => {
                        updateSharedValues();
                    }, 300);
                }

                function incrementCount() {
                    staticCount++;
                    updateStaticCounter();
                    updateSharedValues();
                }

                function updateStaticCounter() {
                    const counter = document.getElementById('staticCounter');
                    counter.textContent = staticCount;
                    counter.classList.add('highlight');
                    
                    setTimeout(() => {
                        counter.classList.remove('highlight');
                    }, 500);
                }

                function updateSharedValues() {
                    for (let i = 1; i <= currentStudentCount; i++) {
                        const sharedValue = document.getElementById(`sharedValue${i}`);
                        sharedValue.textContent = staticCount;
                        sharedValue.classList.add('highlight');
                        
                        setTimeout(() => {
                            sharedValue.classList.remove('highlight');
                        }, 500);
                    }
                }

                function resetDemo() {
                    currentStudentCount = 0;
                    staticCount = 0;
                    
                    // 重置静态计数器
                    document.getElementById('staticCounter').textContent = '0';
                    
                    // 隐藏所有对象
                    for (let i = 1; i <= 3; i++) {
                        const student = document.getElementById(`student${i}`);
                        student.classList.remove('active');
                        document.getElementById(`sharedValue${i}`).textContent = '0';
                    }
                }
                </script>
            </div>
        </section>

        <!-- Slide 31: Static Blocks and Initialization Order -->
        <section class="slide">
            <div class="slide-content">
                <h2>静态代码块和初始化顺序</h2>
                <p>静态代码块可用于初始化静态变量，它在类加载时执行。</p>
                <pre><code class="language-java">public class Person {
    String name = test();
    { System.out.println("我是普通代码块"); }
    Person(){ System.out.println("我是构造方法"); }
    String test(){ System.out.println("我是成员变量初始化"); return "小明"; }

    static String info = init();
    static { System.out.println("我是静态代码块"); }
    static String init(){ System.out.println("我是静态变量初始化"); return "test"; }
}</code></pre>
                <p>当创建一个对象时，执行顺序如下：</p>
                <ol>
                    <li>静态变量初始化 (init)</li>
                    <li>静态代码块</li>
                    <li>成员变量初始化 (test)</li>
                    <li>普通代码块</li>
                    <li>构造方法</li>
                </ol>
                <p>如果只访问静态成员（如<code>Person.info</code>），则只会执行静态部分的初始化。</p>
            </div>
        </section>

        <!-- Slide 32: Class Loading -->
        <section class="slide">
            <div class="slide-content">
                <h2>类的加载时机</h2>
                <p>JVM在需要时才会加载类（懒加载）。以下情况会触发类加载：</p>
                <ul>
                    <li>访问类的静态变量，或为静态变量赋值</li>
                    <li>创建类的实例 (<code>new</code>)</li>
                    <li>调用类的静态方法</li>
                    <li>初始化子类时（会先初始化父类）</li>
                    <li>（反射操作等）</li>
                </ul>
                <p class="conclusion">有关类与对象的基本内容，我们就全部讲解完毕了。</p>
            </div>
        </section>

        <!-- Slide 33: Packages and Access Control -->
        <section class="slide">
            <div class="slide-content">
                <h2>包和访问控制</h2>
                <p>通过前面的学习，我们知道该如何创建和使用类。现在我们来学习如何组织和管理这些类。</p>
                <h3>包声明和导入</h3>
                <p>包（Package）用于组织类，类似于文件夹。它可以避免类名冲突，并更好地管理代码结构。</p>
                <p>包的命名规则通常是反向的域名，例如 <code>com.baidu</code>。</p>
                <pre><code class="language-java">package com.test; // 将当前类放入com.test包中

public class Main {
    public static void main(String[] args) {
        // ...
    }
}</code></pre>
                <p>要使用其他包中的类，需要使用 <code>import</code> 关键字导入。</p>
                <pre><code class="language-java">import com.test.entity.Person; // 导入Person类
import com.test.entity.*;      // 导入entity包下的所有类

public class Main {
    public static void main(String[] args) {
        Person person = new Person();
    }
}</code></pre>
                <p class="conclusion">Java会默认导入 <code>java.lang</code> 包下的所有类，因此像 <code>String</code> 和 <code>System</code> 这样的类无需手动导入。</p>
            </div>
        </section>

        <!-- Slide 34: Access Control -->
        <section class="slide">
            <div class="slide-content">
                <h2>访问权限控制</h2>
                <p>Java提供了访问权限修饰符，用于控制类、方法和变量的可见性，就像保护个人隐私一样。</p>
                <div class="access-levels">
                    <ul>
                        <li><code>public</code>：公共的，任何地方都可以访问。</li>
                        <li><code>protected</code>：受保护的，同包、子类中可以访问。</li>
                        <li><em>默认（无修饰符）</em>：同包内可以访问。</li>
                        <li><code>private</code>：私有的，只有在当前类内部可以访问。</li>
                    </ul>
                </div>
                <table class="access-modifier-table">
                    <thead>
                        <tr>
                            <th>修饰符</th>
                            <th>当前类</th>
                            <th>同包</th>
                            <th>子类</th>
                            <th>不同包</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>public</code></td>
                            <td>✅</td>
                            <td>✅</td>
                            <td>✅</td>
                            <td>✅</td>
                        </tr>
                        <tr>
                            <td><code>protected</code></td>
                            <td>✅</td>
                            <td>✅</td>
                            <td>✅</td>
                            <td>❌</td>
                        </tr>
                        <tr>
                            <td><em>默认</em></td>
                            <td>✅</td>
                            <td>✅</td>
                            <td>❌</td>
                            <td>❌</td>
                        </tr>
                        <tr>
                            <td><code>private</code></td>
                            <td>✅</td>
                            <td>❌</td>
                            <td>❌</td>
                            <td>❌</td>
                        </tr>
                    </tbody>
                </table>
                <p>例如，如果一个属性没有访问修饰符，它只能在同一个包中被访问。</p>
            </div>
        </section>

        <!-- Slide 35: Access Control Example -->
        <section class="slide">
            <div class="slide-content">
                <h2>访问权限控制示例</h2>
                <p>如果一个成员变量是默认权限，在其他包中就无法访问。我们可以通过添加 <code>public</code> 来开放权限。</p>
                <pre><code class="language-java">public class Person {
    public String name; // public修饰后，可以在任何地方访问
    int age; // 默认权限，只能在同包内访问
}</code></pre>
                <p>同样，类的访问权限也可以被控制。一个没有 <code>public</code> 修饰的类只能在同包内使用。</p>
                <pre><code class="language-java">class Person { // 默认权限的类
    // ...
}</code></pre>
                <div class="important-note">
                    <h4>静态导入</h4>
                    <p>如果一个类中有公共的静态方法或变量，可以使用 <code>import static</code> 直接导入它们，从而无需通过类名来调用。</p>
                    <pre><code class="language-java">import static com.test.entity.Person.test;

public class Main {
    public static void main(String[] args) {
        test(); // 直接调用静态方法
    }
}</code></pre>
                </div>
            </div>
        </section>

        <!-- Access Control Animation Demo -->
        <section class="slide">
            <div class="slide-content">
                <h2>访问权限控制动画演示</h2>
                <p>通过文件夹和文件的形式，直观展示Java中不同访问修饰符的权限控制效果：</p>
                
                <div class="access-control-animation">
                    <div class="package-structure">
                        <!-- Package A -->
                        <div class="package-folder" id="packageA">
                            <div class="folder-header">
                                <span class="folder-icon">📁</span>
                                <span class="folder-name">com.example.packageA</span>
                            </div>
                            <div class="folder-content">
                                <div class="java-file" id="parentClass">
                                    <div class="file-header">
                                        <span class="file-icon">☕</span>
                                        <span class="file-name">Parent.java</span>
                                    </div>
                                    <div class="class-members">
                                        <div class="member public" data-access="public">
                                            <span class="access-modifier">public</span> String publicField
                                        </div>
                                        <div class="member protected" data-access="protected">
                                            <span class="access-modifier">protected</span> String protectedField
                                        </div>
                                        <div class="member default" data-access="default">
                                            <span class="access-modifier">default</span> String defaultField
                                        </div>
                                        <div class="member private" data-access="private">
                                            <span class="access-modifier">private</span> String privateField
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="java-file" id="samePackageClass">
                                    <div class="file-header">
                                        <span class="file-icon">☕</span>
                                        <span class="file-name">SamePackage.java</span>
                                    </div>
                                    <div class="access-attempts" id="samePackageAttempts">
                                        <!-- 动态生成访问尝试 -->
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Package B -->
                        <div class="package-folder" id="packageB">
                            <div class="folder-header">
                                <span class="folder-icon">📁</span>
                                <span class="folder-name">com.example.packageB</span>
                            </div>
                            <div class="folder-content">
                                <div class="java-file" id="childClass">
                                    <div class="file-header">
                                        <span class="file-icon">☕</span>
                                        <span class="file-name">Child.java</span>
                                        <span class="extends-label">extends Parent</span>
                                    </div>
                                    <div class="access-attempts" id="childAttempts">
                                        <!-- 动态生成访问尝试 -->
                                    </div>
                                </div>
                                
                                <div class="java-file" id="otherClass">
                                    <div class="file-header">
                                        <span class="file-icon">☕</span>
                                        <span class="file-name">Other.java</span>
                                    </div>
                                    <div class="access-attempts" id="otherAttempts">
                                        <!-- 动态生成访问尝试 -->
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="animation-controls">
                        <button class="control-btn" onclick="testSamePackageAccess()">同包访问测试</button>
                        <button class="control-btn" onclick="testChildClassAccess()">子类访问测试</button>
                        <button class="control-btn" onclick="testOtherClassAccess()">其他类访问测试</button>
                        <button class="control-btn" onclick="resetAccessDemo()">重置演示</button>
                    </div>

                    <div class="access-legend">
                        <h4>访问权限说明：</h4>
                        <div class="legend-items">
                            <div class="legend-item">
                                <span class="legend-color public"></span>
                                <span>public - 所有类都可访问</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-color protected"></span>
                                <span>protected - 同包或子类可访问</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-color default"></span>
                                <span>default - 仅同包可访问</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-color private"></span>
                                <span>private - 仅本类可访问</span>
                            </div>
                        </div>
                    </div>

                    <div class="test-results" id="testResults">
                        <h4>测试结果：</h4>
                        <div class="results-content" id="resultsContent">
                            点击上方按钮开始测试访问权限...
                        </div>
                    </div>
                </div>

                <style>
                .access-control-animation {
                    background: linear-gradient(135deg, #F8F9FA, #E9ECEF);
                    border: 1px solid var(--border-color);
                    border-radius: 16px;
                    padding: 20px;
                    margin: 20px 0;
                    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
                }

                .package-structure {
                    display: flex;
                    gap: 30px;
                    margin-bottom: 30px;
                    justify-content: space-around;
                }

                .package-folder {
                    background: #FFFFFF;
                    border: 2px solid #6C757D;
                    border-radius: 12px;
                    padding: 15px;
                    min-width: 350px;
                    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
                }

                .folder-header {
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    margin-bottom: 15px;
                    padding: 10px;
                    background: linear-gradient(135deg, #E3F2FD, #BBDEFB);
                    border-radius: 8px;
                    font-weight: bold;
                    color: #1976D2;
                }

                .folder-icon {
                    font-size: 1.2em;
                }

                .folder-content {
                    display: flex;
                    flex-direction: column;
                    gap: 15px;
                }

                .java-file {
                    background: #F8F9FA;
                    border: 1px solid #DEE2E6;
                    border-radius: 8px;
                    padding: 12px;
                    transition: all 0.3s ease;
                }

                .java-file:hover {
                    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
                }

                .file-header {
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    margin-bottom: 10px;
                    font-weight: bold;
                    color: #495057;
                }

                .file-icon {
                    font-size: 1.1em;
                }

                .extends-label {
                    background: #E8F5E8;
                    color: #2E7D32;
                    padding: 2px 8px;
                    border-radius: 4px;
                    font-size: 0.8em;
                    margin-left: auto;
                }

                .class-members {
                    display: flex;
                    flex-direction: column;
                    gap: 8px;
                }

                .member {
                    padding: 8px 12px;
                    border-radius: 6px;
                    font-family: 'Roboto Mono', monospace;
                    font-size: 0.9em;
                    transition: all 0.3s ease;
                }

                .member.public {
                    background: #E8F5E8;
                    border-left: 4px solid #4CAF50;
                }

                .member.protected {
                    background: #FFF3E0;
                    border-left: 4px solid #FF9800;
                }

                .member.default {
                    background: #E3F2FD;
                    border-left: 4px solid #2196F3;
                }

                .member.private {
                    background: #FFEBEE;
                    border-left: 4px solid #F44336;
                }

                .access-modifier {
                    font-weight: bold;
                    margin-right: 8px;
                }

                .access-attempts {
                    min-height: 120px;
                    display: flex;
                    flex-direction: column;
                    gap: 6px;
                }

                .access-attempt {
                    padding: 6px 10px;
                    border-radius: 4px;
                    font-family: 'Roboto Mono', monospace;
                    font-size: 0.85em;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    opacity: 0;
                    transform: translateX(-20px);
                    transition: all 0.4s ease;
                }

                .access-attempt.show {
                    opacity: 1;
                    transform: translateX(0);
                }

                .access-attempt.success {
                    background: #E8F5E8;
                    border-left: 3px solid #4CAF50;
                    color: #2E7D32;
                }

                .access-attempt.failure {
                    background: #FFEBEE;
                    border-left: 3px solid #F44336;
                    color: #C62828;
                }

                .access-icon {
                    font-size: 1.1em;
                }

                .animation-controls {
                    display: flex;
                    justify-content: center;
                    gap: 15px;
                    margin: 25px 0;
                    flex-wrap: wrap;
                }

                .control-btn {
                    background-color: var(--primary-color);
                    color: white;
                    border: none;
                    padding: 12px 20px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 0.9em;
                    transition: all 0.3s ease;
                    min-width: 140px;
                }

                .control-btn:hover {
                    background-color: var(--accent-color);
                    transform: translateY(-2px);
                    box-shadow: 0 4px 12px rgba(208, 101, 25, 0.3);
                }

                .access-legend {
                    background: #F8F9FA;
                    border: 1px solid #DEE2E6;
                    border-radius: 8px;
                    padding: 15px;
                    margin: 20px 0;
                }

                .access-legend h4 {
                    margin: 0 0 12px 0;
                    color: var(--text-color);
                }

                .legend-items {
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                    gap: 10px;
                }

                .legend-item {
                    display: flex;
                    align-items: center;
                    gap: 10px;
                    font-size: 0.9em;
                }

                .legend-color {
                    width: 16px;
                    height: 16px;
                    border-radius: 3px;
                }

                .legend-color.public { background: #4CAF50; }
                .legend-color.protected { background: #FF9800; }
                .legend-color.default { background: #2196F3; }
                .legend-color.private { background: #F44336; }

                .test-results {
                    background: #FFFFFF;
                    border: 1px solid #DEE2E6;
                    border-radius: 8px;
                    padding: 15px;
                    margin-top: 20px;
                }

                .test-results h4 {
                    margin: 0 0 12px 0;
                    color: var(--text-color);
                }

                .results-content {
                    font-family: 'Roboto Mono', monospace;
                    font-size: 0.9em;
                    line-height: 1.6;
                    color: #495057;
                }

                @media (max-width: 768px) {
                    .package-structure {
                        flex-direction: column;
                        gap: 20px;
                    }
                    
                    .package-folder {
                        min-width: auto;
                    }
                    
                    .animation-controls {
                        flex-direction: column;
                        align-items: center;
                    }
                    
                    .control-btn {
                        width: 200px;
                    }
                }
                </style>

                <script>
                const accessRules = {
                    public: { samePackage: true, child: true, other: true },
                    protected: { samePackage: true, child: true, other: false },
                    default: { samePackage: true, child: false, other: false },
                    private: { samePackage: false, child: false, other: false }
                };

                function createAccessAttempt(field, canAccess, delay = 0) {
                    const attempt = document.createElement('div');
                    attempt.className = `access-attempt ${canAccess ? 'success' : 'failure'}`;
                    
                    const icon = canAccess ? '✅' : '❌';
                    const status = canAccess ? 'SUCCESS' : 'DENIED';
                    
                    attempt.innerHTML = `
                        <span class="access-icon">${icon}</span>
                        <span>${field}Field - ${status}</span>
                    `;
                    
                    setTimeout(() => {
                        attempt.classList.add('show');
                    }, delay);
                    
                    return attempt;
                }

                function testSamePackageAccess() {
                    clearAccessAttempts();
                    const container = document.getElementById('samePackageAttempts');
                    
                    let delay = 0;
                    ['public', 'protected', 'default', 'private'].forEach(access => {
                        const canAccess = accessRules[access].samePackage;
                        const attempt = createAccessAttempt(access, canAccess, delay);
                        container.appendChild(attempt);
                        delay += 200;
                    });
                    
                    updateResults('同包访问测试', '同包中的类可以访问 public、protected、default 成员，但不能访问 private 成员。');
                }

                function testChildClassAccess() {
                    clearAccessAttempts();
                    const container = document.getElementById('childAttempts');
                    
                    let delay = 0;
                    ['public', 'protected', 'default', 'private'].forEach(access => {
                        const canAccess = accessRules[access].child;
                        const attempt = createAccessAttempt(access, canAccess, delay);
                        container.appendChild(attempt);
                        delay += 200;
                    });
                    
                    updateResults('子类访问测试', '不同包的子类可以访问 public、protected 成员，但不能访问 default、private 成员。');
                }

                function testOtherClassAccess() {
                    clearAccessAttempts();
                    const container = document.getElementById('otherAttempts');
                    
                    let delay = 0;
                    ['public', 'protected', 'default', 'private'].forEach(access => {
                        const canAccess = accessRules[access].other;
                        const attempt = createAccessAttempt(access, canAccess, delay);
                        container.appendChild(attempt);
                        delay += 200;
                    });
                    
                    updateResults('其他类访问测试', '不同包的非子类只能访问 public 成员，其他所有成员都无法访问。');
                }

                function clearAccessAttempts() {
                    ['samePackageAttempts', 'childAttempts', 'otherAttempts'].forEach(id => {
                        const container = document.getElementById(id);
                        container.innerHTML = '';
                    });
                }

                function updateResults(testName, description) {
                    const resultsContent = document.getElementById('resultsContent');
                    resultsContent.innerHTML = `
                        <strong>${testName}完成</strong><br>
                        ${description}<br><br>
                        <em>观察上方的访问尝试结果，理解不同访问修饰符的权限控制效果。</em>
                    `;
                }

                function resetAccessDemo() {
                    clearAccessAttempts();
                    const resultsContent = document.getElementById('resultsContent');
                    resultsContent.textContent = '点击上方按钮开始测试访问权限...';
                }
                </script>
            </div>
        </section>

        <!-- Slide 36: Array Introduction -->
        <section class="slide">
            <div class="slide-content">
                <h2>数组：特殊的数据结构</h2>
                <p>假设需要记录100个数字，定义100个变量显然不切实际。此时，我们可以使用<strong>数组</strong>来存放一组相同类型的数据。</p>
                <img src="./images/5-array.png" alt="Array Diagram" style="width: 80%; display: block; margin: 1rem auto;">
                <p>数组是相同类型数据的有序集合，可以存放任何相同类型的一组内容，包括基本类型和引用类型。其中的每个数据称为数组的一个<strong>元素</strong>。</p>
            </div>
        </section>

        <!-- Slide 37: One-Dimensional Array -->
        <section class="slide">
            <div class="slide-content">
                <h2>一维数组的定义与创建</h2>
                <p>数组本身也是一个对象，即使是基本类型的数组，也以对象形式存在。因此，创建数组需要使用 <code>new</code> 关键字。</p>
                <pre><code class="language-java">public static void main(String[] args) {
    // 推荐的定义方式
    int[] array = new int[10]; // 创建一个长度为10的int数组

    // 其他定义方式
    int array2[] = new int[10]; // C语言风格，不推荐
    int[] array3 = new int[]{1, 2, 3}; // 静态初始化
    int[] array4 = {4, 5, 6}; // 静态初始化（仅限定义时）
}</code></pre>
                <div class="important-note">
                    <h4>关键点</h4>
                    <ul>
                        <li>创建数组时必须指定长度。</li>
                        <li>数组长度一旦确定，不可更改。</li>
                        <li>数组元素有默认值（数值为0，布尔为false，引用为null）。</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Slide 38: Accessing Array Elements -->
        <section class="slide">
            <div class="slide-content">
                <h2>访问和操作数组元素</h2>
                <p>通过<strong>下标</strong>（从0开始）可以访问和修改数组中的元素。数组的长度可以通过 <code>.length</code> 属性获取。</p>
                <pre><code class="language-java">public static void main(String[] args) {
    int[] array = new int[10];
    
    // 访问并打印第一个元素
    System.out.println("数组的第一个元素为：" + array[0]); // 输出: 0
    
    // 修改第一个元素的值
    array[0] = 888;
    System.out.println("修改后，第一个元素为：" + array[0]); // 输出: 888
    
    // 获取数组长度
    System.out.println("当前数组长度为：" + array.length); // 输出: 10
}</code></pre>
                <p class="warning">注意：数组下标访问不能越界（小于0或大于等于数组长度），否则会抛出 <code>ArrayIndexOutOfBoundsException</code> 异常。</p>
            </div>
        </section>

        <!-- Slide 39: Traversing Arrays -->
        <section class="slide">
            <div class="slide-content">
                <h2>遍历数组</h2>
                <p>遍历数组是常见的操作，可以使用传统的for循环或增强的for-each循环。</p>
                <h4>传统for循环</h4>
                <pre><code class="language-java">public static void main(String[] args) {
    int[] array = {1, 2, 3, 4, 5};
    for (int i = 0; i < array.length; i++) {
        System.out.print(array[i] + " ");
    }
}</code></pre>
                <h4>增强for-each循环</h4>
                <p>for-each循环语法更简洁，适用于只需读取数组元素而无需修改的场景。</p>
                <pre><code class="language-java">public static void main(String[] args) {
    int[] array = {1, 2, 3, 4, 5};
    for (int element : array) { // 依次取出数组中的每个元素
        System.out.print(element + " ");
    }
}</code></pre>
                <p class="conclusion">for-each循环是编译器的语法糖，其底层实现仍然是传统的for循环。</p>
            </div>
        </section>

        <!-- Slide 40: Multi-Dimensional Arrays -->
        <section class="slide">
            <div class="slide-content">
                <h2>多维数组</h2>
                <p>多维数组是数组的数组。例如，二维数组可以看作一个矩阵。</p>
                <pre><code class="language-java">public static void main(String[] args) {
    // 创建一个3行2列的二维数组
    int[][] matrix = {
        {1, 2},
        {3, 4},
        {5, 6}
    };

    // 访问第三行第二列的元素
    System.out.println(matrix[2][1]); // 输出: 6

    // 遍历二维数组
    for (int i = 0; i < matrix.length; i++) {
        for (int j = 0; j < matrix[i].length; j++) {
            System.out.print(matrix[i][j] + " ");
        }
        System.out.println();
    }
}</code></pre>
                <p>可以创建更高维度的数组，但最常用的是二维数组。</p>
            </div>
        </section>

        <!-- Slide 41: Varargs -->
        <section class="slide">
            <div class="slide-content">
                <h2>可变长参数 (Varargs)</h2>
                <p>可变长参数允许方法接受任意数量的同类型参数。它本质上是一个语法糖，底层实现为数组。</p>
                <pre><code class="language-java">public class Calculator {
    // 使用...定义可变长参数
    public int sum(int... numbers) {
        int total = 0;
        for (int num : numbers) {
            total += num;
        }
        return total;
    }
}

// 调用
Calculator calc = new Calculator();
calc.sum(1, 2);          // 传入2个参数
calc.sum(1, 2, 3, 4, 5); // 传入5个参数
calc.sum();              // 不传入参数
</code></pre>
                <div class="important-note">
                    <h4>使用规则</h4>
                    <ul>
                        <li>一个方法最多只能有一个可变长参数。</li>
                        <li>可变长参数必须是方法参数列表中的最后一个。</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Slide 42: String Introduction -->
        <section class="slide">
            <div class="slide-content">
                <h2>字符串 (String)</h2>
                <p><code>String</code> 是Java中一个非常特殊的类，用于表示一系列字符。字符串是<strong>不可变</strong>的，一旦创建，其内容无法修改。</p>
                <pre><code class="language-java">public static void main(String[] args) {
    // 1. 直接使用双引号创建（推荐）
    String str1 = "Hello World";

    // 2. 使用构造方法创建
    String str2 = new String("Hello World");

    // "==" 比较的是引用地址
    System.out.println(str1 == str2); // false

    // .equals() 比较的是内容
    System.out.println(str1.equals(str2)); // true
}</code></pre>
                <p class="conclusion">为了优化性能，内容相同的字符串字面量在内存中通常只有一个实例。因此，比较字符串内容时，务必使用 <code>.equals()</code> 方法。</p>
            </div>
        </section>

        <!-- Slide 43: Common String Methods -->
        <section class="slide">
            <div class="slide-content">
                <h2>常用的String方法</h2>
                <p><code>String</code> 类提供了丰富的方法来操作字符串。</p>
                <pre><code class="language-java">public static void main(String[] args) {
    String str = "Hello, World!";

    // 获取长度
    System.out.println("长度: " + str.length());

    // 截取子串
    String sub = str.substring(7, 12); // "World"
    System.out.println("子串: " + sub);

    // 分割字符串
    String[] parts = str.split(", "); // ["Hello", "World!"]
    for (String part : parts) {
        System.out.println("分割部分: " + part);
    }

    // 转换为字符数组
    char[] chars = str.toCharArray();
    System.out.println("第一个字符: " + chars[0]);
}</code></pre>
                <p>由于字符串不可变，所有修改字符串内容的方法（如 <code>substring</code>, <code>split</code>）都会返回一个新的 <code>String</code> 对象。</p>
            </div>
        </section>

        <!-- Slide 44: StringBuilder -->
        <section class="slide">
            <div class="slide-content">
                <h2>StringBuilder：可变的字符串</h2>
                <p>当需要频繁拼接或修改字符串时，使用 <code>String</code> 会产生大量临时对象，效率较低。此时应使用 <code>StringBuilder</code>。</p>
                <pre><code class="language-java">public static void main(String[] args) {
    // 创建一个空的StringBuilder
    StringBuilder builder = new StringBuilder();

    // 使用append方法进行拼接
    builder.append("你好");
    builder.append("，世界！");
    builder.append(2024);

    // 编辑完成后，使用toString()转换为String
    String result = builder.toString();
    System.out.println(result); // "你好，世界！2024"

    // 其他编辑操作
    builder.delete(5, 9); // 删除"2024"
    System.out.println(builder.toString()); // "你好，世界！"
}</code></pre>
                <p class="conclusion">在循环或大量拼接场景下，<code>StringBuilder</code> 是构建字符串的最佳选择。</p>
            </div>
        </section>

        <!-- Slide 45: Regular Expressions -->
        <section class="slide">
            <div class="slide-content">
                <h2>正则表达式 (Regular Expression)</h2>
                <p>正则表达式是一种描述字符串匹配模式的强大工具，可用于验证、查找、替换字符串。</p>
                <p>例如，验证一个字符串是否由一个或多个 'o' 组成：</p>
                <pre><code class="language-java">public static void main(String[] args) {
    String str1 = "oooo";
    String str2 = "o";
    String str3 = "oops";

    // "o+" 是一个正则表达式，+ 表示匹配前面的字符一次或多次
    System.out.println(str1.matches("o+")); // true
    System.out.println(str2.matches("o+")); // true
    System.out.println(str3.matches("o+")); // false
}</code></pre>
                <p><a href="5-oop-reg.html">正则表达式</a>语法复杂但功能强大，是处理文本的重要技能。</p>
            </div>
        </section>

        <!-- Slide 46: Common Utility Classes -->
        <section class="slide">
            <div class="slide-content">
                <h2>常用工具类介绍</h2>
                <p>除了数组和字符串，Java还提供了许多常用的<strong>工具类</strong>，这些类封装了特定场景下的常用功能，通常包含大量静态方法，可以直接通过类名调用。</p>
                <ul>
                    <li><strong>数学工具类 (Math)</strong>: 提供高级数学运算功能。</li>
                    <li><strong>随机数工具类 (Random)</strong>: 用于生成伪随机数。</li>
                    <li><strong>数组工具类 (Arrays)</strong>: 提供操作数组的便捷方法。</li>
                </ul>
                <p class="conclusion">善用工具类可以大大简化代码编写，提高开发效率。</p>
            </div>
        </section>

        <!-- Slide 47: Math Utility Class -->
        <section class="slide">
            <div class="slide-content">
                <h2>数学工具类 (Math)</h2>
                <p><code>Math</code> 类位于 <code>java.lang</code> 包中，无需导入即可直接使用。它提供了丰富的静态方法来执行高级数学运算。</p>
                <pre><code class="language-java">public static void main(String[] args) {
    // 幂运算
    System.out.println(Math.pow(5, 3)); // 5的3次方，结果: 125.0

    // 基本运算
    Math.abs(-1);    // 绝对值
    Math.max(19, 20);  // 最大值
    Math.min(2, 4);    // 最小值
    Math.sqrt(9);    // 平方根

    // 三角函数 (参数为弧度)
    Math.sin(Math.PI / 2); // sin(π/2)
    Math.cos(Math.PI);     // cos(π)

    // 对数运算
    Math.log(Math.E);    // 自然对数 (ln)
    Math.log10(100);   // 以10为底的对数

    // 取整运算
    Math.ceil(4.5);  // 向上取整，结果: 5.0
    Math.floor(5.6); // 向下取整，结果: 5.0
}</code></pre>
                <p class="warning">由于浮点数精度问题，<code>Math.sin(Math.PI)</code> 的结果可能是一个非常接近0的极小数，而非精确的0。</p>
            </div>
        </section>

        <!-- Slide 48: Random Number Generation -->
        <section class="slide">
            <div class="slide-content">
                <h2>随机数生成 (Random)</h2>
                <p><code>Random</code> 类位于 <code>java.util</code> 包中，用于生成伪随机数。使用前需要创建 <code>Random</code> 对象。</p>
                <pre><code class="language-java">import java.util.Random;

public static void main(String[] args) {
    Random random = new Random();
    for (int i = 0; i < 10; i++) {
        // 生成0到99之间的随机整数
        System.out.print(random.nextInt(100) + " ");
    }
}</code></pre>
                <div class="important-note">
                    <h4>关于“伪随机”</h4>
                    <p>程序生成的随机数是“伪随机”的，它们基于一个初始种子通过复杂的算法计算得出。虽然在统计上看起来是随机的，但如果种子相同，生成的序列也相同。这与物理世界中的“真随机”不同。</p>
                </div>
            </div>
        </section>

        <!-- Slide 49: Arrays Utility Class -->
        <section class="slide">
            <div class="slide-content">
                <h2>数组工具类 (Arrays)</h2>
                <p><code>Arrays</code> 类同样位于 <code>java.util</code> 包，提供了大量静态方法来简化数组操作。</p>
                <pre><code class="language-java">import java.util.Arrays;

public static void main(String[] args) {
    int[] arr = {1, 4, 5, 8, 2, 0, 9, 7, 3, 6};

    // 1. 数组转字符串
    System.out.println(Arrays.toString(arr));

    // 2. 排序 (从小到大)
    Arrays.sort(arr);
    System.out.println("排序后: " + Arrays.toString(arr));

    // 3. 填充数组
    int[] filledArr = new int[5];
    Arrays.fill(filledArr, 66);
    System.out.println("填充后: " + Arrays.toString(filledArr));

    // 4. 拷贝数组
    int[] copiedArr = Arrays.copyOf(arr, arr.length);

    // 5. 比较数组内容
    System.out.println("内容是否相等: " + Arrays.equals(arr, copiedArr));
}</code></pre>
                <p class="conclusion">对于多维数组，应使用 <code>deepToString()</code>, <code>deepEquals()</code> 等方法进行深度操作。</p>
            </div>
        </section>

        <!-- Slide 50: Binary Search -->
        <section class="slide">
            <div class="slide-content">
                <h2>二分搜索 (Binary Search)</h2>
                <p><code>Arrays.binarySearch</code> 方法可以在<strong>已排序</strong>的数组中高效地查找元素。如果找到，返回元素下标；否则，返回一个负数。</p>
                <pre><code class="language-java">import java.util.Arrays;

public static void main(String[] args) {
    int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // 在有序数组中查找元素5
    int index = Arrays.binarySearch(arr, 5);
    System.out.println("元素5的下标是: " + index); // 输出: 4

    // 查找不存在的元素
    int notFoundIndex = Arrays.binarySearch(arr, 11);
    System.out.println("未找到时返回值: " + notFoundIndex); // 负数
}</code></pre>
                <div class="important-note">
                    <h4>算法原理</h4>
                    <p>二分搜索通过反复将搜索范围减半来快速定位目标值。由于其高效性（时间复杂度为 O(log n)），它是处理大规模有序数据查找的核心算法之一。</p>
                </div>
            </div>
        </section>

        <!-- Slide 51: Practical Exercises -->
        <section class="slide">
            <div class="slide-content">
                <h2>实战练习</h2>
                <p>理论学习后，通过编码实践来巩固知识至关重要。以下是一些经典的算法问题，请尝试自己实现。</p>
                <div class="exercise-list">
                    <div class="exercise-item">
                        <h4>冒泡排序算法</h4>
                        <p>将一个乱序的整数数组按照从小到大的顺序排列。</p>
                    </div>
                    <div class="exercise-item">
                        <h4>二分搜索算法</h4>
                        <p>在一个有序数组中查找指定目标值，并返回其下标。</p>
                    </div>
                    <div class="exercise-item">
                        <h4>青蛙跳台阶问题</h4>
                        <p>计算一只青蛙跳上n级台阶（每次可跳1或2阶）共有多少种方案。</p>
                    </div>
                    <div class="exercise-item">
                        <h4>回文串判断</h4>
                        <p>判断一个字符串是否正读和反读都一样。</p>
                    </div>
                    <div class="exercise-item">
                        <h4>汉诺塔求解</h4>
                        <p>输出解决N阶汉诺塔问题的每一步移动操作。</p>
                    </div>
                </div>
                <p class="conclusion">这些练习不仅能加深对Java语法的理解，还能锻炼逻辑思维和解决问题的能力。</p>
            </div>
        </section>

        <!-- Slide 52: Java Module System -->
        <section class="slide">
            <div class="slide-content">
                <h2>模块系统 (Java 9+)</h2>
                <p>从Java 9开始，引入了<strong>模块系统</strong>，旨在解决大型应用中依赖关系复杂、类路径混乱的问题。</p>
                <div class="concept-comparison">
                    <div class="concept-item">
                        <h4>模块化之前</h4>
                        <p>所有依赖（JAR包）都放在类路径上，导致：</p>
                        <ul>
                            <li><strong>强封装性缺失</strong>: 无法隐藏不应暴露的包。</li>
                            <li><strong>依赖关系模糊</strong>: 难以清晰地了解项目依赖。</li>
                            <li><strong>巨大的运行时</strong>: 即使只用到一小部分功能，也需引入整个JAR包。</li>
                        </ul>
                    </div>
                    <div class="concept-item">
                        <h4>模块化之后</h4>
                        <p>通过 <code>module-info.java</code> 文件明确定义模块边界：</p>
                        <ul>
                            <li><code>requires</code>: 声明依赖哪些其他模块。</li>
                            <li><code>exports</code>: 声明将哪些包暴露给其他模块使用。</li>
                        </ul>
                        <p>这带来了更好的封装性、更清晰的依赖和更小的运行时镜像。</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- UI Elements -->
        <div class="progress-bar-container">
            <div id="progress-bar"></div>
        </div>
        <div class="controls">
            <button id="prevBtn">上一页</button>
            <span id="slide-counter">1 / X</span>
            <button id="nextBtn">下一页</button>
        </div>
    </main>

    <script src="./js/animation.js"></script>
    <script src="./js/ppt.js"></script>
    <script src="../prism/prism.js"></script>
    <script src="../prism/prism-autoloader.min.js"></script>
</body>
</html>