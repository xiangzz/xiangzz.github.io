<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JUnit单元测试详解</title>
    <link rel="stylesheet" href="./css/style.css">
    <link rel="stylesheet" href="./css/hacker-cmd.css">
    <link rel="stylesheet" href="../prism/prism.css">
</head>
<body>

    <main id="presentation">
        <!-- Slide 1: Title -->
        <section class="slide title-slide active">
            <h1>JUnit单元测试</h1>
            <p>面向对象程序设计（Java）</p>
            <strong>掌握测试驱动开发，提升代码质量和可靠性</strong>
        </section>

        <!-- Slide 2: Testing Basics -->
        <section class="slide">
            <div class="slide-content">
                <h2>测试基础概念</h2>
                <p><strong>什么是单元测试？</strong></p>
                <ul>
                    <li>单元测试是针对程序中最小可测试单元进行的测试</li>
                    <li>在Java中，通常是一个类或一个方法</li>
                    <li>目的是验证代码单元是否按预期工作</li>
                </ul>

                <p><strong>为什么需要测试？</strong></p>
                <ul>
                    <li>🔍 <strong>发现问题</strong>：在开发阶段及早发现bug</li>
                    <li>🛡️ <strong>防止回归</strong>：确保新修改不影响现有功能</li>
                    <li>📚 <strong>文档作用</strong>：测试用例展示了代码的预期行为</li>
                    <li>🏗️ <strong>重构保障</strong>：为代码重构提供安全网</li>
                </ul>

                <p><strong>测试的基本原则</strong></p>
                <ul>
                    <li><strong>独立性</strong>：测试之间不应相互依赖</li>
                    <li><strong>可重复性</strong>：多次运行应得到相同结果</li>
                    <li><strong>快速性</strong>：单元测试应该快速执行</li>
                </ul>
            </div>
        </section>

        <!-- Slide 3: JUnit Introduction -->
        <section class="slide">
            <div class="slide-content">
                <h2>JUnit简介</h2>
                <p><strong>JUnit是什么？</strong></p>
                <ul>
                    <li>Java最流行的单元测试框架</li>
                    <li>提供测试编写、执行和验证的标准方法</li>
                    <li>与IDEA、Maven、Gradle等工具深度集成</li>
                </ul>

                <h3>🚀 JUnit版本对比</h3>
                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <thead>
                        <tr style="background: #f8f9fa;">
                            <th style="border: 1px solid #ddd; padding: 0.8rem; text-align: left;">特性</th>
                            <th style="border: 1px solid #ddd; padding: 0.8rem; text-align: left;">JUnit 4</th>
                            <th style="border: 1px solid #ddd; padding: 0.8rem; text-align: left;">JUnit 5</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 0.8rem;"><strong>包名</strong></td>
                            <td style="border: 1px solid #ddd; padding: 0.8rem;">org.junit.*</td>
                            <td style="border: 1px solid #ddd; padding: 0.8rem;">org.junit.jupiter.*</td>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 0.8rem;"><strong>注解</strong></td>
                            <td style="border: 1px solid #ddd; padding: 0.8rem;">@Test, @Before, @After</td>
                            <td style="border: 1px solid #ddd; padding: 0.8rem;">@Test, @BeforeEach, @AfterEach</td>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 0.8rem;"><strong>参数化测试</strong></td>
                            <td style="border: 1px solid #ddd; padding: 0.8rem;">需要额外依赖</td>
                            <td style="border: 1px solid #ddd; padding: 0.8rem;">内置支持</td>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 0.8rem;"><strong>推荐程度</strong></td>
                            <td style="border: 1px solid #ddd; padding: 0.8rem;">📅 旧项目兼容</td>
                            <td style="border: 1px solid #ddd; padding: 0.8rem;">🌟 新项目首选</td>
                        </tr>
                    </tbody>
                </table>

                <h3>⚙️ Maven依赖配置</h3>
                <pre><code class="language-xml">&lt;!-- JUnit 5 依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
    &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;
    &lt;version&gt;5.10.0&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
            </div>
        </section>

        <!-- Slide 4: First JUnit Test - Part 1 -->
        <section class="slide">
            <div class="slide-content">
                <h2>第一个JUnit测试 (1)</h2>
                <p>让我们从一个简单的计算器类开始，编写第一个测试。</p>

                <h3>📝 被测试的类</h3>
                <pre><code class="language-java">// src/main/java/com/example/Calculator.java
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }

    public int subtract(int a, int b) {
        return a - b;
    }

    public int multiply(int a, int b) {
        return a * b;
    }
}</code></pre>

                <p class="conclusion">
                    这是我们要测试的简单计算器类，包含基本的算术运算方法。
                    接下来我们将为它编写第一个测试。
                </p>
            </div>
        </section>

        <!-- Slide 5: First JUnit Test - Part 2 -->
        <section class="slide">
            <div class="slide-content">
                <h2>第一个JUnit测试 (2)</h2>
                <h3>🧪 编写测试类</h3>
                <pre><code class="language-java">// src/test/java/com/example/CalculatorTest.java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class CalculatorTest {

    @Test
    void testAdd() {
        // Arrange（准备）
        Calculator calculator = new Calculator();
        int a = 3;
        int b = 5;
        int expected = 8;

        // Act（执行）
        int result = calculator.add(a, b);

        // Assert（验证）
        assertEquals(expected, result);
    }
}</code></pre>

                <h3>🎯 AAA模式说明</h3>
                <ul>
                    <li><strong>Arrange</strong>：准备测试数据和对象</li>
                    <li><strong>Act</strong>：执行被测试的方法</li>
                    <li><strong>Assert</strong>：验证结果是否符合预期</li>
                </ul>

                <p class="conclusion">
                    在IDEA中，右键点击测试类或测试方法，选择"Run 'CalculatorTest'"即可执行测试。
                    绿色✅表示测试通过，红色❌表示测试失败。
                </p>
            </div>
        </section>

        <!-- Slide 6: Common Assertions -->
        <section class="slide">
            <div class="slide-content">
                <h2>常用断言方法</h2>
                <p>JUnit提供了丰富的断言方法来验证测试结果。以下是常用的断言：</p>

                <h3>🔢 数值和对象比较</h3>
                <pre><code class="language-java">@Test
void testAssertions() {
    // 相等性断言
    assertEquals(4, 2 + 2);
    assertEquals("hello", "HELLO".toLowerCase());

    // 不等性断言
    assertNotEquals(5, 2 + 2);
    assertNotEquals("hello", "HELLO");

    // 对象相等性（重写equals()方法）
    String str1 = new String("test");
    String str2 = new String("test");
    assertEquals(str1, str2); // 比较内容
    assertNotSame(str1, str2); // 不是同一个对象
}</code></pre>

                <p class="conclusion">
                    <code>assertEquals</code> 比较内容，<code>assertNotSame</code> 比较对象引用地址。
                </p>
            </div>
        </section>

        <!-- Slide 7: More Assertions -->
        <section class="slide">
            <div class="slide-content">
                <h2>更多断言方法</h2>

                <h3>✅ 布尔条件断言</h3>
                <pre><code class="language-java">@Test
void testBooleanAssertions() {
    String text = "Hello World";

    // 条件断言
    assertTrue(text.contains("Hello"));
    assertFalse(text.isEmpty());

    // 空值断言
    String nullStr = null;
    String emptyStr = "";

    assertNull(nullStr);
    assertNotNull(emptyStr);
}</code></pre>

                <h3>⚠️ 异常断言</h3>
                <pre><code class="language-java">@Test
void testException() {
    // 测试是否抛出指定异常
    assertThrows(IllegalArgumentException.class, () -> {
        divideByZero();
    });

    // 也可以获取异常对象进行进一步验证
    Exception exception = assertThrows(ArithmeticException.class, () -> {
        int result = 10 / 0;
    });

    assertEquals("/ by zero", exception.getMessage());
}

private void divideByZero() {
    throw new IllegalArgumentException("不能除以零");
}</code></pre>
            </div>
        </section>

        <!-- Slide 8: Test Lifecycle -->
        <section class="slide">
            <div class="slide-content">
                <h2>测试生命周期</h2>
                <p>JUnit提供了多个注解来控制测试方法的执行顺序和资源管理。</p>

                <h3>🔄 生命周期注解</h3>
                <pre><code class="language-java">import org.junit.jupiter.api.*;

class LifecycleTest {

    @BeforeAll
    static void setupAll() {
        System.out.println("🔧 在所有测试开始前执行一次");
        // 适合初始化昂贵的资源（数据库连接等）
    }

    @BeforeEach
    void setUp() {
        System.out.println("⚡ 在每个测试方法前执行");
        // 适合准备测试数据
    }

    @Test
    void test1() {
        System.out.println("📝 执行测试1");
    }

    @AfterEach
    void tearDown() {
        System.out.println("🧹 在每个测试方法后执行");
        // 适合清理测试数据
    }

    @AfterAll
    static void tearDownAll() {
        System.out.println("🏁 在所有测试结束后执行一次");
        // 适合释放昂贵的资源
    }
}</code></pre>

                <p class="conclusion">
                    <strong>最佳实践</strong>：使用@BeforeEach/@AfterEach保证测试独立性，
                    使用@BeforeAll/@AfterAll提高性能（如数据库连接）。
                </p>
            </div>
        </section>

        <!-- Slide 9: Parameterized Tests - Part 1 -->
        <section class="slide">
            <div class="slide-content">
                <h2>参数化测试 (1)</h2>
                <p>参数化测试允许我们使用不同的输入参数多次运行同一个测试方法。</p>

                <h3>🎯 @ValueSource 数据源</h3>
                <pre><code class="language-java">import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

class ParameterizedTestExample {

    @ParameterizedTest
    @ValueSource(strings = {"racecar", "madam", "level", "rotor"})
    void testPalindromes(String word) {
        assertTrue(isPalindrome(word));
    }

    @ParameterizedTest
    @ValueSource(ints = {1, 2, 3, 4, 5})
    void testPositiveNumbers(int number) {
        assertTrue(number > 0);
    }

    private boolean isPalindrome(String word) {
        return word.equals(new StringBuilder(word).reverse().toString());
    }
}</code></pre>

                <p class="conclusion">
                    <code>@ValueSource</code> 适合测试简单的单参数场景，
                    如字符串数组、数值数组等。
                </p>
            </div>
        </section>

        <!-- Slide 10: Parameterized Tests - Part 2 -->
        <section class="slide">
            <div class="slide-content">
                <h2>参数化测试 (2)</h2>
                <h3>📋 @CsvSource 数据源</h3>
                <pre><code class="language-java">@ParameterizedTest
@CsvSource({
    "2, 3, 5",        // a=2, b=3, expected=5
    "0, 0, 0",        // a=0, b=0, expected=0
    "-1, 1, 0",       // a=-1, b=1, expected=0
    "10, -5, 5"       // a=10, b=-5, expected=5
})
void testAdd(int a, int b, int expected) {
    Calculator calculator = new Calculator();
    assertEquals(expected, calculator.add(a, b));
}</code></pre>

                <h3>🏭 @MethodSource 数据源</h3>
                <pre><code class="language-java">@ParameterizedTest
@MethodSource("provideTestData")
void testMultiply(int a, int b, int expected) {
    Calculator calculator = new Calculator();
    assertEquals(expected, calculator.multiply(a, b));
}

static Stream<Arguments> provideTestData() {
    return Stream.of(
        Arguments.of(2, 3, 6),
        Arguments.of(0, 5, 0),
        Arguments.of(-2, 4, -8),
        Arguments.of(10, 10, 100)
    );
}</code></pre>

                <p><strong>注意</strong>：使用参数化测试需要添加依赖：<code>junit-jupiter-params</code></p>

                <p class="conclusion">
                    <code>@CsvSource</code> 适合多参数测试，<code>@MethodSource</code> 适合复杂的测试数据生成逻辑。
                </p>
            </div>
        </section>

        <!-- Slide 11: Test Suites and Grouping -->
        <section class="slide">
            <div class="slide-content">
                <h2>测试套件和分组</h2>
                <p>当测试数量增多时，我们需要组织和分类测试。JUnit提供了标签（@Tag）和测试套件功能。</p>

                <h3>🏷️ 使用@Tag分组测试</h3>
                <pre><code class="language-java">import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;

@Tag("slow")  // 标记为慢速测试
class SlowTests {
    @Test
    @Tag("database")  // 可以有多个标签
    void testDatabaseConnection() {
        // 模拟耗时的数据库操作
        System.out.println("连接数据库测试...");
    }
}

@Tag("fast")
@Tag("unit")
class FastTests {
    @Test
    void testStringOperations() {
        assertEquals("HELLO", "hello".toUpperCase());
    }

    @Test
    void testMathOperations() {
        assertEquals(4, Math.addExact(2, 2));
    }
}</code></pre>

                <p class="conclusion">
                    使用标签可以有效管理大型项目的测试，在CI/CD中特别有用（如只运行快速测试）。
                </p>
            </div>
        </section>

        <!-- Slide 12: Mock Testing - Part 1 -->
        <section class="slide">
            <div class="slide-content">
                <h2>Mock测试 (1) - 为什么需要Mock</h2>
                <p>在单元测试中，我们经常需要测试依赖其他组件的类。Mock技术让我们能够隔离这些依赖，专注测试目标类的逻辑。</p>

                <h3>🤔 为什么需要使用Mock？</h3>
                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <thead>
                        <tr style="background: #f8f9fa;">
                            <th style="border: 1px solid #ddd; padding: 0.8rem; text-align: left;">场景</th>
                            <th style="border: 1px solid #ddd; padding: 0.8rem; text-align: left;">问题描述</th>
                            <th style="border: 1px solid #ddd; padding: 0.8rem; text-align: left;">Mock解决方案</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 0.8rem;"><strong>外部依赖</strong></td>
                            <td style="border: 1px solid #ddd; padding: 0.8rem;">依赖数据库、网络API、文件系统</td>
                            <td style="border: 1px solid #ddd; padding: 0.8rem;">创建Mock对象，避免真实调用</td>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 0.8rem;"><strong>性能问题</strong></td>
                            <td style="border: 1px solid #ddd; padding: 0.8rem;">依赖组件执行缓慢（如数据库查询）</td>
                            <td style="border: 1px solid #ddd; padding: 0.8rem;">Mock对象瞬时响应，测试快速执行</td>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 0.8rem;"><strong>不稳定因素</strong></td>
                            <td style="border: 1px solid #ddd; padding: 0.8rem;">外部服务可能宕机或返回错误</td>
                            <td style="border: 1px solid #ddd; padding: 0.8rem;">Mock行为可控，测试结果稳定</td>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 0.8rem;"><strong>成本问题</strong></td>
                            <td style="border: 1px solid #ddd; padding: 0.8rem;">调用第三方API需要付费</td>
                            <td style="border: 1px solid #ddd; padding: 0.8rem;">Mock免费使用，降低测试成本</td>
                        </tr>
                    </tbody>
                </table>

                <h3>🎭 什么是Mock对象？</h3>
                <ul>
                    <li><strong>行为可控制</strong>：可以预定义方法的返回值和异常</li>
                    <li><strong>调用可验证</strong>：可以验证方法是否被调用，调用次数和参数</li>
                    <li><strong>轻量级</strong>：不需要真实的依赖环境</li>
                    <li><strong>隔离性</strong>：确保测试只关注目标类的逻辑</li>
                </ul>

                <p class="conclusion">
                    Mock测试的核心思想是"隔离"，让我们专注于测试目标类的逻辑，而不受外部依赖的影响。
                </p>
            </div>
        </section>

        <!-- Slide 13: Mock Testing - Part 2 -->
        <section class="slide">
            <div class="slide-content">
                <h2>Mock测试 (2) - Mock工具和数据生成</h2>

                <h3>🛠️ Mock工具对比</h3>
                <pre><code class="language-xml"><!-- 1. Mockito - 最流行的Mock框架 -->
&lt;dependency&gt;
    &lt;groupId&gt;org.mockito&lt;/groupId&gt;
    &lt;artifactId&gt;mockito-core&lt;/artifactId&gt;
    &lt;version&gt;5.5.0&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;

<!-- 2. EasyMock - 传统Mock框架 -->
&lt;dependency&gt;
    &lt;groupId&gt;org.easymock&lt;/groupId&gt;
    &lt;artifactId&gt;easymock&lt;/artifactId&gt;
    &lt;version&gt;5.2.0&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;

<!-- 3. PowerMock - 支持静态方法和私有方法Mock -->
&lt;dependency&gt;
    &lt;groupId&gt;org.powermock&lt;/groupId&gt;
    &lt;artifactId&gt;powermock-module-junit4&lt;/artifactId&gt;
    &lt;version&gt;2.0.9&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>

                <h3>📚 快速创建Mock数据的工具</h3>
                <pre><code class="language-xml"><!-- 1. Faker - 生成真实感数据 -->
&lt;dependency&gt;
    &lt;groupId&gt;com.github.javafaker&lt;/groupId&gt;
    &lt;artifactId&gt;javafaker&lt;/artifactId&gt;
    &lt;version&gt;1.0.2&lt;/version&gt;
&lt;/dependency&gt;

<!-- 2. DataFactory - 测试数据生成工厂 -->
&lt;dependency&gt;
    &lt;groupId&gt;org.fluttercode.datafactory&lt;/groupId&gt;
    &lt;artifactId&gt;datafactory&lt;/artifactId&gt;
    &lt;version&gt;0.8&lt;/version&gt;
&lt;/dependency&gt;</code></pre>

                <h3>💡 使用示例</h3>
                <pre><code class="language-java">// Faker使用示例
Faker faker = new Faker();
String name = faker.name().fullName();           // "张三"
String email = faker.internet().emailAddress(); // "zhangsan@example.com"
int age = faker.number().numberBetween(18, 65);  // 25-65之间的随机数</code></pre>

                <p class="conclusion">
                    推荐优先使用 Mockito，配合 Faker 生成真实的测试数据。
                </p>
            </div>
        </section>

        <!-- Slide 14: Mock Testing - Part 3 -->
        <section class="slide">
            <div class="slide-content">
                <h2>Mock测试 (3) - Mockito基础使用</h2>

                <h3>📦 Mockito基础示例</h3>
                <pre><code class="language-java">import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import static org.mockito.Mockito.*;

class EmailServiceTest {

    @Test
    void testSendWelcomeEmail() {
        // 创建Mock对象
        EmailService emailService = mock(EmailService.class);
        UserService userService = new UserService(emailService);

        // 定义Mock行为
        when(emailService.sendEmail(anyString(), anyString())).thenReturn(true);

        // 执行测试
        boolean result = userService.registerUser("test@example.com");

        // 验证结果
        assertTrue(result);

        // 验证Mock对象的方法调用
        verify(emailService).sendEmail("test@example.com", "Welcome!");
    }

    @Test
    void testSendEmailFailure() {
        // 测试失败场景
        EmailService emailService = mock(EmailService.class);
        UserService userService = new UserService(emailService);

        // 定义失败行为
        when(emailService.sendEmail(anyString(), anyString())).thenReturn(false);

        // 执行并验证失败
        boolean result = userService.registerUser("invalid@example.com");
        assertFalse(result);

        // 验证调用次数
        verify(emailService, times(1)).sendEmail(anyString(), anyString());
    }
}</code></pre>

                <p class="conclusion">
                    Mockito的核心语法：创建Mock → 定义行为 → 执行测试 → 验证结果。
                </p>
            </div>
        </section>

        <!-- Slide 15: Mock Testing - Part 4 -->
        <section class="slide">
            <div class="slide-content">
                <h2>Mock测试 (4) - 高级Mock技巧</h2>

                <h3>🔍 常用Mock方法详解</h3>
                <pre><code class="language-java">// 创建Mock对象
List<String> mockList = mock(List.class);

// 定义返回值
when(mockList.get(0)).thenReturn("Hello");
when(mockList.size()).thenReturn(1);

// 定义异常情况
when(mockList.get(1)).thenThrow(new IndexOutOfBoundsException());

// 链式调用定义
when(mockList.get(0)).thenReturn("First").thenReturn("Second");
// 第一次调用返回"First"，第二次及以后返回"Second"

// 验证调用
verify(mockList).get(0);                    // 验证get(0)被调用1次
verify(mockList, times(2)).add(any());      // 验证add()被调用2次
verify(mockList, never()).clear();          // 验证clear()从未被调用</code></pre>

                <h3>💡 高级Mock技巧</h3>
                <pre><code class="language-java">// 1. Spy - 部分Mock，保留真实方法
List<String> spyList = spy(new ArrayList<>());
spyList.add("real");              // 调用真实方法
when(spyList.size()).thenReturn(100);  // Mock size方法

// 2. 参数捕获 - 验证调用时的参数
ArgumentCaptor<String> captor = ArgumentCaptor.forClass(String.class);
verify(emailService).sendEmail(captor.capture(), anyString());
String capturedEmail = captor.getValue();  // 获取捕获的参数

// 3. Answer - 自定义返回逻辑
when(mockList.get(anyInt())).thenAnswer(invocation -> {
    Integer index = invocation.getArgument(0);
    return "Item " + index;
});

// 4. Void方法Mock
doNothing().when(mockList).clear();        // Void方法不执行任何操作
doThrow(new RuntimeException()).when(mockList).clear();  // Void方法抛异常</code></pre>

                <p class="conclusion">
                    <strong>Mock最佳实践</strong>：优先使用Mockito，配合Faker生成测试数据，
                    使用Builder模式创建复杂对象，让Mock测试既真实又高效！
                </p>
            </div>
        </section>

        <!-- Slide 16: Maven与JUnit集成 - Part 1 -->
        <section class="slide">
            <div class="slide-content">
                <h2>Maven与JUnit集成 (1)</h2>
                <p>在实际开发中，我们通常使用Maven来管理项目依赖和构建过程。理解Maven如何与JUnit协作是重要的技能。</p>

                <h3>🔗 Maven与JUnit的关系</h3>
                <pre><code class="language-text">Maven构建生命周期：
validate → compile → test → package → verify → install → deploy
                          ↑
                      JUnit在这里执行</code></pre>

                <h3>📁 Maven标准项目结构</h3>
                <pre><code class="language-text">my-project/
├── pom.xml                    # Maven配置文件
├── src/
│   ├── main/                 # 源代码
│   │   ├── java/
│   │   └── resources/
│   └── test/                 # 测试代码 (JUnit在这里运行)
│       ├── java/
│       └── resources/
└── target/                   # 编译输出目录
    ├── classes/              # 源代码编译结果
    └── test-classes/         # 测试代码编译结果</code></pre>

                <p class="conclusion">
                    Maven会自动在 <code>mvn test</code> 阶段扫描并运行所有JUnit测试。
                </p>
            </div>
        </section>

        <!-- Slide 17: Maven与JUnit集成 - Part 2 -->
        <section class="slide">
            <div class="slide-content">
                <h2>Maven与JUnit集成 (2)</h2>

                <h3>🚀 在IDEA中运行Maven测试</h3>
                <pre><code class="language-text">IDEA Maven工具窗口操作：

方法1：使用Maven工具栏
1. 打开右侧Maven工具窗口
2. 展开 Lifecycle
3. 双击 "test" 命令
4. Maven会自动运行所有JUnit测试

方法2：使用快捷键
- Ctrl + Shift + F10 (运行所有测试)
- Ctrl + Shift + T (创建测试类)</code></pre>

                <h3>⚙️ Maven surefire插件配置</h3>
                <pre><code class="language-xml">&lt;!-- pom.xml中的配置 --&gt;
&lt;build&gt;
    &lt;plugins&gt;
        &lt;!-- Maven Surefire Plugin - 负责运行单元测试 --&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
            &lt;version&gt;3.1.2&lt;/version&gt;
            &lt;configuration&gt;
                &lt;includes&gt;
                    &lt;include&gt;**/*Test.java&lt;/include&gt;
                    &lt;include&gt;**/*Tests.java&lt;/include&gt;
                &lt;/includes&gt;
                &lt;excludes&gt;
                    &lt;exclude&gt;**/*IntegrationTest.java&lt;/exclude&gt;
                &lt;/excludes&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre>

                <p class="conclusion">
                    <strong>核心要点</strong>：Maven的<code>mvn test</code>命令会自动扫描并运行所有JUnit测试，
                    理解这个集成机制对于现代Java开发至关重要！
                </p>
            </div>
        </section>

        <!-- Slide 18: IDEA Testing Tips -->
        <section class="slide">
            <div class="slide-content">
                <h2>IDEA中的测试技巧</h2>
                <p>JetBrains IDEA提供了强大的测试支持，掌握这些技巧可以大大提高测试效率。</p>

                <h3>⚡ 快速创建测试类</h3>
                <pre><code class="language-text">快捷键：Ctrl + Shift + T (Windows/Linux)
        或   ⌘ + Shift + T (macOS)

1. 在源代码类中按下快捷键
2. 选择 "Create New Test..."
3. 选择要测试的方法
4. 选择测试库（JUnit 5）
5. 选择生成位置（通常在src/test/java）
6. 自动生成测试方法模板</code></pre>

                <h3>🎯 运行测试的多种方式</h3>
                <pre><code class="language-text">运行单个测试方法：
- 右键点击测试方法 → Run 'testMethod()'
- 点击方法左侧的绿色箭头

运行整个测试类：
- 右键点击类名 → Run 'ClassName'
- 在类内右键 → Run Tests in 'ClassName'</code></pre>

                <p class="conclusion">
                    IDEA的测试功能让编写和运行测试变得简单高效，
                    多使用快捷键和可视化工具可以显著提升开发体验。
                </p>
            </div>
        </section>

        <!-- Slide 19: Testing Best Practices -->
        <section class="slide">
            <div class="slide-content">
                <h2>测试最佳实践</h2>
                <p>编写高质量、可维护的测试需要遵循一些重要的原则和模式。</p>

                <h3>📝 测试命名规范</h3>
                <pre><code class="language-java">// ❌ 不好的命名
@Test
void test1() { }
@Test
void testCalculator() { }

// ✅ 好的命名（遵循：methodName_condition_expectedResult）
@Test
void add_twoPositiveNumbers_returnsCorrectSum() { }
@Test
void divide_byZero_throwsArithmeticException() { }
@Test
void withdraw_insufficientBalance_throwsException() { }

// 或者使用 given_when_then 格式
@Test
void givenValidAmount_whenDeposit_thenBalanceIncreases() { }</code></pre>

                <h3>🏗️ AAA模式（Arrange-Act-Assert）</h3>
                <pre><code class="language-java">@Test
void transferMoney_sufficientBalance_updatesBothAccounts() {
    // Arrange（准备）- 设置测试数据和初始状态
    Account fromAccount = new Account(1000);
    Account toAccount = new Account(500);
    Bank bank = new Bank();
    bank.addAccount(fromAccount);
    bank.addAccount(toAccount);

    // Act（执行）- 调用被测试的方法
    bank.transferMoney(fromAccount, toAccount, 300);

    // Assert（验证）- 检查结果是否符合预期
    assertEquals(700, fromAccount.getBalance());
    assertEquals(800, toAccount.getBalance());
}</code></pre>

                <p class="conclusion">
                    好的测试不仅是质量的保障，更是代码的活文档。
                    遵循这些实践原则，让测试成为开发的有力工具！
                </p>
            </div>
        </section>

        <!-- UI Elements -->
        <div class="progress-bar-container">
            <div id="progress-bar"></div>
        </div>
        <div class="controls">
            <button id="prevBtn">上一页</button>
            <span id="slide-counter">1 / X</span>
            <button id="nextBtn">下一页</button>
        </div>
    </main>

    <script src="../prism/prism.js"></script>
    <script src="../prism/prism-autoloader.min.js"></script>
    <script src="./js/ppt.js"></script>
    <script src="./js/nav.js"></script>
</body>
</html>