<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>封装、继承与多态</title>
    <link rel="stylesheet" href="./css/style.css">
    <link rel="stylesheet" href="./css/hacker-cmd.css">
    <link rel="stylesheet" href="../prism/prism.css">
</head>
<body>

    <main id="presentation">
        <!-- Slide 1: Title -->
        <section class="slide title-slide active">
            <h1>封装、继承与多态</h1>
            <p>面向对象程序设计的三大基石</p>
            <strong>深入理解Java对象的世界观</strong>
        </section>

        <!-- Slide 2: Introduction -->
        <section class="slide">
            <div class="slide-content">
                <h2>面向对象的三大特性</h2>
                <p>封装、继承和多态是Java面向对象编程的核心，它们共同构建了清晰、可维护和可扩展的软件世界。</p>
                <ul>
                    <li><strong>封装 (Encapsulation):</strong> 将数据（属性）和操作数据的方法（行为）捆绑在一起，并对外部隐藏内部实现细节，只提供公共的访问接口。</li>
                    <li><strong>继承 (Inheritance):</strong> 允许一个类（子类）获取另一个类（父类）的属性和方法，实现了代码的复用，并为多态提供了基础。</li>
                    <li><strong>多态 (Polymorphism):</strong> 同一个消息（方法调用）可以根据发送对象的不同而表现出不同的行为。它极大地增强了程序的灵活性和可扩展性。</li>
                </ul>
                <p class="conclusion">正是这三大特性，让我们的Java程序更加生动和强大。</p>
            </div>
        </section>

        <!-- Slide 3: Encapsulation -->
        <section class="slide">
            <div class="slide-content">
                <h2>类的封装：构建安全的“数据胶囊”</h2>
                <p>封装的核心思想是“高内聚，低耦合”。它确保了对象内部数据的安全性，使用者无需关心实现细节，只需通过预定义的接口与对象交互。</p>
                <p>如果不封装，类的内部变量可以被随意读写，这可能导致数据不一致或逻辑混乱，给系统带来风险。</p>
                <p class="conclusion">最佳实践：将成员变量设为 <code>private</code>，并通过公共的 <code>public</code> Getter 和 Setter 方法来控制访问。</p>
<pre><code class="language-java">
public class Person {
    private String name; // 设为私有，只能在类内部访问
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() { // Getter: 对外提供读取name的通道
        return name;
    }

    public void setName(String name) { // Setter: 对外提供修改name的通道
        // 可以在这里加入控制逻辑
        if(name != null && !name.isEmpty()) {
            this.name = name;
        }
    }
    
    public int getAge() {
        return age;
    }
}
</code></pre>
            </div>
        </section>

        <!-- Slide 4: Encapsulation Example -->
        <section class="slide">
            <div class="slide-content">
                <h2>封装的力量：在访问中加入控制逻辑</h2>
                <p>封装的真正威力在于，我们可以在Getter和Setter方法中添加额外的逻辑，从而完全掌控属性的读写过程。</p>
                <p>例如，我们可以规定名字不允许包含特定字符，或者年龄不能被设置为负数。</p>
<pre><code class="language-java">
public class Person {
    private String name;
    private int age;

    // ... 构造方法 ...

    public void setName(String name) {
        // 名字不能为空，且不能包含"小"字
        if (name == null || name.contains("小")) {
            System.out.println("无效的名字！");
            return;
        }
        this.name = name;
    }

    public void setAge(int age) {
        // 年龄必须在 0 到 120 之间
        if (age < 0 || age > 120) {
            System.out.println("无效的年龄！");
            return;
        }
        this.age = age;
    }
    
    // ... Getters ...
}
</code></pre>
                <p class="conclusion">通过这种方式，类的设计者可以强制执行业务规则，确保对象状态的有效性。</p>
            </div>
        </section>
        
        <!-- Slide 5: Singleton Pattern -->
        <section class="slide">
            <div class="slide-content">
                <h2>封装的高级应用：单例模式</h2>
                <p>通过将构造方法私有化（<code>private</code>），我们可以阻止外部代码随意创建类的实例。这为实现“单例模式”铺平了道路。</p>
                <p>单例模式确保一个类在整个应用程序中只有一个实例，这对于管理共享资源（如配置、数据库连接池）非常有用。</p>
<pre><code class="language-java">
public class Singleton {
    // 1. 创建一个私有的、静态的自身实例
    private static Singleton instance;

    // 2. 私有化构造方法，防止外部 new
    private Singleton() {}

    // 3. 提供一个公共的、静态的方法来获取唯一实例
    public static Singleton getInstance() {
        // 如果实例不存在，则创建一个
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
</code></pre>
                <p class="conclusion">封装不仅是隐藏数据，更是对对象创建和生命周期的精细控制。</p>
            </div>
        </section>

        <!-- Slide 6: Inheritance -->
        <section class="slide">
            <div class="slide-content">
                <h2>类的继承：站在巨人的肩膀上</h2>
                <p>继承是代码复用的强大机制。它允许我们创建一个新类（子类），该类继承一个已存在类（父类）的属性和方法。</p>
                <p>这形成了一种 "is-a" 的关系。例如，“学生”是一个“人”，“工人”也是一个“人”。学生和工人都拥有人的共性（如姓名、年龄），但又各自拥有独特的行为。</p>
                <img src="https://s2.loli.net/2022/09/21/zlZ9JXAjvxpawPF.png" alt="Inheritance Diagram" style="max-width: 70%; border: 1px solid var(--border-color); display: block; margin: 10px auto;">
                <p class="conclusion">子类继承父类的“遗产”（非私有成员），并可以添加自己的新功能，实现“青出于蓝而胜于蓝”。</p>
            </div>
        </section>

        <!-- Slide 7: Inheritance Syntax -->
        <section class="slide">
            <div class="slide-content">
                <h2>继承的语法：<code>extends</code> 关键字</h2>
                <p>在Java中，我们使用 <code>extends</code> 关键字来实现继承。一个类只能直接继承一个父类（单继承），但继承的层级可以无限延伸。</p>
<pre><code class="language-java">
// 父类：Person
public class Person {
    String name;
    int age;

    public void hello() {
        System.out.println("你好，我叫 " + name);
    }
}

// 子类：Student 继承自 Person
public class Student extends Person {
    public void study() {
        // 可以直接使用从父类继承来的 name 属性
        System.out.println(name + " 正在学习...");
    }
}

// 使用
Student student = new Student();
student.name = "小明";
student.study(); // 调用自己的方法
student.hello(); // 调用从父类继承的方法
</code></pre>
                <p class="warning">被 <code>final</code> 关键字修饰的类不能被继承。</p>
            </div>
        </section>

        <!-- Slide 8: super Keyword -->
        <section class="slide">
            <div class="slide-content">
                <h2><code>super</code> 关键字：与父类的沟通桥梁</h2>
                <p><code>super</code> 关键字在子类中扮演着重要角色，它提供了两种主要用途：</p>
                <ul>
                    <li><strong>调用父类的构造方法:</strong> <code>super(...)</code> 必须是子类构造方法的第一行语句。子类的实例化过程总是从父类的构造开始。</li>
                    <li><strong>访问父类的成员:</strong> 当子类和父类有同名成员时，可以使用 <code>super.memberName</code> 来明确指定访问父类的成员。</li>
                </ul>
<pre><code class="language-java">
public class Person {
    protected String name;
    protected Person(String name) { this.name = name; }
}

public class Student extends Person {
    private String name; // 与父类同名的属性

    public Student(String parentName, String childName) {
        super(parentName); // 1. 必须先调用父类的构造方法
        this.name = childName;
    }

    public void printNames() {
        System.out.println("父类的名字: " + super.name); // 2. 访问父类的 name
        System.out.println("子类的名字: " + this.name);
    }
}
</code></pre>
            </div>
        </section>

        <!-- Slide 9: Upcasting and Downcasting -->
        <section class="slide">
            <div class="slide-content">
                <h2>向上转型与向下转型：多态的体现</h2>
                <p><strong>向上转型 (Upcasting):</strong> 将子类对象赋值给父类引用。这是自动且安全的。</p>
                <p><code>Person person = new Student("小明", 18, "男");</code></p>
                <p>向上转型后，该引用只能调用父类中定义的方法，但如果该方法在子类中被重写，实际执行的是子类的版本。这就是多态！</p>
                <p><strong>向下转型 (Downcasting):</strong> 将父类引用强制转换回子类引用。这需要显式转换，并且有风险。</p>
                <p><code>Student student = (Student) person;</code></p>
                <p class="warning">向下转型前，必须使用 <code>instanceof</code> 关键字进行检查，否则可能在运行时抛出 <code>ClassCastException</code>。</p>
<pre><code class="language-java">
if (person instanceof Student) {
    Student student = (Student) person;
    student.study(); // 安全地调用子类特有的方法
}
</code></pre>
            </div>
        </section>

        <!-- Slide 10: The Object Class -->
        <section class="slide">
            <div class="slide-content">
                <h2>万物之源：顶层 <code>Object</code> 类</h2>
                <p>在Java中，如果一个类没有明确地 <code>extends</code> 另一个类，那么它就默认继承自 <code>java.lang.Object</code> 类。</p>
                <p>因此，<code>Object</code> 类是所有类的“祖先”，它提供了一些所有对象都应具备的基本方法。</p>
                <img src="https://s2.loli.net/2022/09/21/hkapOYVHBrjy7UC.png" alt="Object Hierarchy" style="max-width: 60%; border: 1px solid var(--border-color); display: block; margin: 10px auto;">
                <p>常用方法包括：</p>
                <ul>
                    <li><code>String toString()</code>: 返回对象的字符串表示。</li>
                    <li><code>boolean equals(Object obj)</code>: 比较两个对象是否“相等”。</li>
                    <li><code>int hashCode()</code>: 返回对象的哈希码。</li>
                    <li><code>Class<?> getClass()</code>: 返回对象的运行时类。</li>
                </ul>
            </div>
        </section>

        <!-- Slide 11: Method Overriding -->
        <section class="slide">
            <div class="slide-content">
                <h2>方法的重写 (Override)：定制子类的行为</h2>
                <p>重写是指子类可以提供一个与父类方法签名完全相同（方法名、参数列表、返回类型）的新实现，从而“覆盖”父类的行为。</p>
                <p>这与<strong>重载 (Overload)</strong> 不同：重载是在同一个类中定义多个同名但参数列表不同的方法。</p>
                <p>重写是实现多态的关键。例如，我们可以重写 <code>Object</code> 类的 <code>equals()</code> 和 <code>toString()</code> 方法来满足我们自己的业务需求。</p>
                <p class="conclusion">使用 <code>@Override</code> 注解是一个好习惯，它能让编译器帮助我们检查重写是否正确。</p>
            </div>
        </section>

        <!-- Slide 12: Overriding equals() and toString() -->
        <section class="slide">
            <div class="slide-content">
                <h2>重写示例：定制 <code>equals()</code> 和 <code>toString()</code></h2>
                <p>默认的 <code>equals()</code> 比较的是内存地址，而我们通常希望比较对象的内容。默认的 <code>toString()</code> 输出的是类名和哈希码，我们希望看到更有意义的信息。</p>
<pre><code class="language-java">
public class Person {
    private String name;
    private int age;
    // ... 构造方法 ...

    @Override
    public String toString() {
        return "Person{" + "name='" + name + ''' + ", age=" + age + '}';
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true; // 是同一个对象
        if (obj == null || getClass() != obj.getClass()) return false; // 类型不同
        Person person = (Person) obj;
        // 比较核心属性
        return age == person.age && name.equals(person.name);
    }
}
</code></pre>
                <p>重写后，即使是两个不同的对象，只要内容相同，<code>equals()</code> 也会返回 <code>true</code>。</p>
            </div>
        </section>

        <!-- Slide 13: Polymorphism -->
        <section class="slide">
            <div class="slide-content">
                <h2>多态的魔力：同一调用，不同行为</h2>
                <p>多态的核心在于：父类引用指向子类对象，当调用被子类重写的方法时，执行的是子类的方法。</p>
                <p>这使得我们可以编写出更通用、更灵活的代码，程序在运行时动态地决定调用哪个方法。</p>
<pre><code class="language-java">
public class Person {
    public void exam() { System.out.println("人需要考试"); }
}
public class Student extends Person {
    @Override
    public void exam() { System.out.println("学生考文化课，得A"); }
}
public class Worker extends Person {
    @Override
    public void exam() { System.out.println("工人考技能，得D"); }
}

// 多态的运用
Person p1 = new Student();
Person p2 = new Worker();

p1.exam(); // 输出: 学生考文化课，得A
p2.exam(); // 输出: 工人考技能，得D
</code></pre>
                <p class="conclusion">多态解除了类之间的紧密耦合，使得程序更容易扩展和维护。</p>
            </div>
        </section>

        <!-- Slide 14: Abstract Classes -->
        <section class="slide">
            <div class="slide-content">
                <h2>抽象类 (Abstract Class)：定义行为的“蓝图”</h2>
                <p>当一个父类只知道其子类应该包含什么方法，但无法确定这些方法的具体实现时，就可以使用抽象类。</p>
                <p>抽象类使用 <code>abstract</code> 关键字修饰，它可以包含抽象方法（只有声明，没有方法体）和具体方法。</p>
                <ul>
                    <li>抽象类<strong>不能</strong>被实例化 (不能 <code>new</code>)。</li>
                    <li>继承抽象类的子类<strong>必须</strong>实现其所有抽象方法，除非子类自己也是抽象类。</li>
                </ul>
<pre><code class="language-java">
// 抽象类 Animal
public abstract class Animal {
    // 抽象方法：不知道怎么叫，留给子类实现
    public abstract void makeSound();

    // 具体方法：所有动物都会跑
    public void run() {
        System.out.println("动物在跑...");
    }
}

// 具体类 Dog
public class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("汪汪！");
    }
}
</code></pre>
            </div>
        </section>

        <!-- Slide 15: Interfaces -->
        <section class="slide">
            <div class="slide-content">
                <h2>接口 (Interface)：定义能力的“契约”</h2>
                <p>接口是比抽象类更纯粹的抽象。它只定义了一组行为规范（方法签名），而不关心任何实现。接口体现了 "has-a" 或 "can-do" 的关系。</p>
                <p>一个类可以实现（<code>implements</code>）多个接口，这弥补了Java单继承的不足。</p>
                <ul>
                    <li>接口中的方法默认是 <code>public abstract</code> 的。</li>
                    <li>接口中的变量默认是 <code>public static final</code> 的（常量）。</li>
                    <li>实现接口的类必须实现其所有抽象方法。</li>
                </ul>
<pre><code class="language-java">
// 定义“会飞”的能力
public interface Flyable {
    void fly(); // 接口方法
}

// 定义“会游泳”的能力
public interface Swimmable {
    void swim();
}

// Duck 类实现了这两种能力
public class Duck implements Flyable, Swimmable {
    @Override
    public void fly() { System.out.println("鸭子在飞..."); }

    @Override
    public void swim() { System.out.println("鸭子在游泳..."); }
}
</code></pre>
            </div>
        </section>
        
        <!-- Slide 16: Enum Classes -->
        <section class="slide">
            <div class="slide-content">
                <h2>枚举类 (Enum)：安全的常量集合</h2>
                <p>当一个变量的取值范围是有限且固定的集合时（如星期、季节、状态），使用枚举类是最佳选择。</p>
                <p>枚举提供了类型安全，避免了使用字符串或整数常量可能导致的错误，并使代码更具可读性。</p>
<pre><code class="language-java">
// 定义一个表示状态的枚举
public enum Status {
    RUNNING("跑步中"), 
    STUDYING("学习中"), 
    SLEEPING("睡觉中");

    private final String description;

    // 枚举的构造方法默认是 private
    Status(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }
}

// 使用枚举
Status currentStatus = Status.STUDYING;
System.out.println("当前状态: " + currentStatus.getDescription()); // 输出: 当前状态: 学习中
</code></pre>
                <p class="conclusion">枚举的本质是继承自 <code>java.lang.Enum</code> 的特殊类，功能远比简单的常量强大。</p>
            </div>
        </section>

        <!-- Slide 17: Conclusion -->
        <section class="slide">
            <div class="slide-content">
                <h2>总结：封装、继承与多态</h2>
                <p>今天我们学习了面向对象编程的三大核心特性，它们是构建高质量Java应用的基石。</p>
                <ul>
                    <li><strong>封装</strong>是基础，它保护数据，隐藏细节，提供了清晰的接口。</li>
                    <li><strong>继承</strong>是扩展，它复用代码，建立了类之间的层次关系。</li>
                    <li><strong>多态</strong>是灵魂，它提升了灵活性和可扩展性，让程序“活”了起来。</li>
                </ul>
                <p>同时，我们也了解了抽象类、接口和枚举等重要概念，它们都是实现这些特性的重要工具。</p>
                <p class="conclusion">请务必多加练习，在实践中去体会这些思想的精髓。编程之路，知易行难，唯有实践出真知！</p>
            </div>
        </section>

        <!-- UI Elements -->
        <div class="progress-bar-container">
            <div id="progress-bar"></div>
        </div>
        <div class="controls">
            <button id="prevBtn">上一页</button>
            <span id="slide-counter">1 / X</span>
            <button id="nextBtn">下一页</button>
        </div>
    </main>

    <script src="./js/animation.js"></script>
    <script src="./js/ppt.js"></script>
    <script src="../prism/prism.js"></script>
    <script src="../prism/prism-autoloader.min.js"></script>

</body>
</html>