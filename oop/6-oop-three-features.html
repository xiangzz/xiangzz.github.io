<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>封装、继承与多态</title>
    <link rel="stylesheet" href="./css/style.css">
    <link rel="stylesheet" href="./css/hacker-cmd.css">
    <link rel="stylesheet" href="../prism/prism.css">
</head>
<body>

    <main id="presentation">
        <!-- Slide 1: Title -->
        <section class="slide title-slide active">
            <h1>封装、继承与多态</h1>
            <p>面向对象程序设计的三大基石</p>
            <strong>深入理解Java对象的世界观</strong>
        </section>

        <!-- Slide 2: Introduction -->
        <section class="slide">
            <div class="slide-content">
                <h2>面向对象的三大特性</h2>
                <p>封装、继承和多态是Java面向对象编程的核心，它们共同构建了清晰、可维护和可扩展的软件世界。</p>
                <ul>
                    <li><strong>封装 (Encapsulation):</strong> 将数据（属性）和操作数据的方法（行为）捆绑在一起，并对外部隐藏内部实现细节，只提供公共的访问接口。</li>
                    <li><strong>继承 (Inheritance):</strong> 允许一个类（子类）获取另一个类（父类）的属性和方法，实现了代码的复用，并为多态提供了基础。</li>
                    <li><strong>多态 (Polymorphism):</strong> 同一个消息（方法调用）可以根据发送对象的不同而表现出不同的行为。它极大地增强了程序的灵活性和可扩展性。</li>
                </ul>
                <p class="conclusion">正是这三大特性，让我们的Java程序更加生动和强大。</p>
            </div>
        </section>

        <!-- Slide 3: Encapsulation -->
        <section class="slide">
            <div class="slide-content">
                <h2>类的封装：构建安全的“数据胶囊”</h2>
                <p>封装的核心思想是“高内聚，低耦合”。它确保了对象内部数据的安全性，使用者无需关心实现细节，只需通过预定义的接口与对象交互。</p>
                <p>如果不封装，类的内部变量可以被随意读写，这可能导致数据不一致或逻辑混乱，给系统带来风险。</p>
                <p class="conclusion">最佳实践：将成员变量设为 <code>private</code>，并通过公共的 <code>public</code> Getter 和 Setter 方法来控制访问。</p>
<pre><code class="language-java">
public class Person {
    private String name; // 设为私有，只能在类内部访问
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() { // Getter: 对外提供读取name的通道
        return name;
    }

    public void setName(String name) { // Setter: 对外提供修改name的通道
        // 可以在这里加入控制逻辑
        if(name != null && !name.isEmpty()) {
            this.name = name;
        }
    }
    
    public int getAge() {
        return age;
    }
}
</code></pre>
            </div>
        </section>

        <!-- Slide 4: Encapsulation Example -->
        <section class="slide">
            <div class="slide-content">
                <h2>封装的力量：在访问中加入控制逻辑</h2>
                <p>封装的真正威力在于，我们可以在Getter和Setter方法中添加额外的逻辑，从而完全掌控属性的读写过程。</p>
                <p>例如，我们可以规定名字不允许包含特定字符，或者年龄不能被设置为负数。</p>
<pre><code class="language-java">
public class Person {
    private String name;
    private int age;

    // ... 构造方法 ...

    public void setName(String name) {
        // 名字不能为空，且不能包含"小"字
        if (name == null || name.contains("小")) {
            System.out.println("无效的名字！");
            return;
        }
        this.name = name;
    }

    public void setAge(int age) {
        // 年龄必须在 0 到 120 之间
        if (age < 0 || age > 120) {
            System.out.println("无效的年龄！");
            return;
        }
        this.age = age;
    }
    
    // ... Getters ...
}
</code></pre>
                <p class="conclusion">通过这种方式，类的设计者可以强制执行业务规则，确保对象状态的有效性。</p>
            </div>
        </section>
        
        <!-- Slide 5: Access Modifiers Deep Dive -->
        <section class="slide">
            <div class="slide-content">
                <h2>访问修饰符详解：控制访问的"门卫"</h2>
                <p>在深入单例模式之前，我们需要彻底理解Java的四种访问修饰符。它们就像不同级别的"门卫"，控制着谁可以访问类的成员。</p>
                
                <div class="access-modifiers-table">
                    <h3>访问修饰符对比表</h3>
                    <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                        <thead>
                            <tr style="background-color: var(--primary-color); color: white;">
                                <th style="padding: 10px; border: 1px solid #ddd;">修饰符</th>
                                <th style="padding: 10px; border: 1px solid #ddd;">同一个类</th>
                                <th style="padding: 10px; border: 1px solid #ddd;">同一个包</th>
                                <th style="padding: 10px; border: 1px solid #ddd;">不同包的子类</th>
                                <th style="padding: 10px; border: 1px solid #ddd;">不同包的其他类</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td style="padding: 10px; border: 1px solid #ddd; font-weight: bold;">private</td>
                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: green;">✓</td>
                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: red;">✗</td>
                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: red;">✗</td>
                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: red;">✗</td>
                            </tr>
                            <tr style="background-color: #f9f9f9;">
                                <td style="padding: 10px; border: 1px solid #ddd; font-weight: bold;">默认(包私有)</td>
                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: green;">✓</td>
                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: green;">✓</td>
                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: red;">✗</td>
                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: red;">✗</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px; border: 1px solid #ddd; font-weight: bold;">protected</td>
                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: green;">✓</td>
                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: green;">✓</td>
                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: green;">✓</td>
                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: red;">✗</td>
                            </tr>
                            <tr style="background-color: #f9f9f9;">
                                <td style="padding: 10px; border: 1px solid #ddd; font-weight: bold;">public</td>
                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: green;">✓</td>
                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: green;">✓</td>
                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: green;">✓</td>
                                <td style="padding: 10px; border: 1px solid #ddd; text-align: center; color: green;">✓</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="access-examples">
                    <h3>实际应用场景</h3>
                    <div class="example-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                        <div class="example-item">
                            <h4>🔒 private - 内部秘密</h4>
                            <p>用于类的内部实现细节，外部完全不可见</p>
                            <ul>
                                <li>敏感数据（密码、密钥）</li>
                                <li>内部计算方法</li>
                                <li>缓存变量</li>
                            </ul>
                        </div>
                        <div class="example-item">
                            <h4>📦 默认 - 包内共享</h4>
                            <p>同一个包内的类可以访问，适合紧密协作的类</p>
                            <ul>
                                <li>工具类的辅助方法</li>
                                <li>包内数据传输对象</li>
                                <li>内部API</li>
                            </ul>
                        </div>
                        <div class="example-item">
                            <h4>🛡️ protected - 家族传承</h4>
                            <p>子类可以访问，用于继承体系中的共享</p>
                            <ul>
                                <li>父类的核心属性</li>
                                <li>可被重写的方法</li>
                                <li>模板方法模式</li>
                            </ul>
                        </div>
                        <div class="example-item">
                            <h4>🌍 public - 公开接口</h4>
                            <p>完全公开，任何地方都可以访问</p>
                            <ul>
                                <li>对外提供的API</li>
                                <li>常量定义</li>
                                <li>主要业务方法</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 6: Encapsulation Step by Step -->
        <section class="slide">
            <div class="slide-content">
                <h2>封装实战：从零开始构建一个银行账户类</h2>
                <p>让我们通过一个完整的银行账户类来演示封装的威力。我们将逐步展示如何从一个不安全的类演进到一个完全封装的类。</p>
                
                <div class="step-by-step">
                    <div class="step">
                        <h3>❌ 第一步：不封装的危险版本</h3>
<pre><code class="language-java">
public class BankAccount {
    public String accountNumber;  // 任何人都能修改账号！
    public double balance;        // 余额可以被随意篡改！
    public String ownerName;      // 户主姓名可以被改变！
    
    // 没有任何保护措施
}

// 使用时的问题
BankAccount account = new BankAccount();
account.balance = -1000;  // 😱 余额变成负数！
account.accountNumber = ""; // 😱 账号被清空！
</code></pre>
                        <p class="warning">这种设计完全没有安全保障，任何人都可以随意修改账户信息！</p>
                    </div>

                    <div class="step">
                        <h3>⚠️ 第二步：基础封装版本</h3>
<pre><code class="language-java">
public class BankAccount {
    private String accountNumber;
    private double balance;
    private String ownerName;
    
    // 基础的getter和setter
    public double getBalance() { return balance; }
    public void setBalance(double balance) { this.balance = balance; }
    
    public String getOwnerName() { return ownerName; }
    public void setOwnerName(String ownerName) { this.ownerName = ownerName; }
}
</code></pre>
                        <p class="warning">虽然数据私有化了，但setter方法仍然允许不合理的操作！</p>
                    </div>

                    <div class="step">
                        <h3>✅ 第三步：完全封装的安全版本</h3>
<pre><code class="language-java">
public class BankAccount {
    private final String accountNumber;  // 账号一旦设定不可更改
    private double balance;
    private final String ownerName;      // 户主姓名不可更改
    private boolean isActive;            // 账户状态
    
    public BankAccount(String accountNumber, String ownerName) {
        if (accountNumber == null || accountNumber.trim().isEmpty()) {
            throw new IllegalArgumentException("账号不能为空");
        }
        if (ownerName == null || ownerName.trim().isEmpty()) {
            throw new IllegalArgumentException("户主姓名不能为空");
        }
        this.accountNumber = accountNumber;
        this.ownerName = ownerName;
        this.balance = 0.0;  // 新账户余额为0
        this.isActive = true;
    }
    
    // 只提供查询余额的方法，不提供直接设置余额的方法
    public double getBalance() {
        if (!isActive) {
            throw new IllegalStateException("账户已被冻结");
        }
        return balance;
    }
    
    // 存款方法：有业务逻辑控制
    public void deposit(double amount) {
        if (!isActive) {
            throw new IllegalStateException("账户已被冻结，无法存款");
        }
        if (amount <= 0) {
            throw new IllegalArgumentException("存款金额必须大于0");
        }
        if (amount > 50000) {
            throw new IllegalArgumentException("单次存款不能超过5万元");
        }
        balance += amount;
        System.out.println("存款成功，当前余额：" + balance);
    }
    
    // 取款方法：有业务逻辑控制
    public void withdraw(double amount) {
        if (!isActive) {
            throw new IllegalStateException("账户已被冻结，无法取款");
        }
        if (amount <= 0) {
            throw new IllegalArgumentException("取款金额必须大于0");
        }
        if (amount > balance) {
            throw new IllegalArgumentException("余额不足");
        }
        if (amount > 20000) {
            throw new IllegalArgumentException("单次取款不能超过2万元");
        }
        balance -= amount;
        System.out.println("取款成功，当前余额：" + balance);
    }
    
    // 冻结账户
    public void freeze() {
        isActive = false;
        System.out.println("账户已被冻结");
    }
    
    // 解冻账户
    public void unfreeze() {
        isActive = true;
        System.out.println("账户已解冻");
    }
    
    // 只读属性的getter
    public String getAccountNumber() { return accountNumber; }
    public String getOwnerName() { return ownerName; }
    public boolean isActive() { return isActive; }
}
</code></pre>
                    </div>
                </div>
                
                <p class="conclusion">通过完全封装，我们不仅保护了数据，还嵌入了业务规则，确保账户操作的安全性和合理性。</p>
            </div>
        </section>

        <!-- Slide 7: Singleton Pattern -->
        <section class="slide">
            <div class="slide-content">
                <h2>封装的高级应用：单例模式深度解析</h2>
                <p>单例模式是封装思想的高级应用。通过将构造方法私有化，我们完全控制了对象的创建过程。</p>
                
                <div class="singleton-comparison">
                    <h3>单例模式的演进历程</h3>
                    
                    <div class="singleton-version">
                        <h4>🥚 饿汉式（Eager Loading）- 最简单但可能浪费内存</h4>
<pre><code class="language-java">
public class EagerSingleton {
    // 类加载时就创建实例（可能浪费内存）
    private static final EagerSingleton instance = new EagerSingleton();
    
    private EagerSingleton() {
        System.out.println("EagerSingleton 实例被创建");
    }
    
    public static EagerSingleton getInstance() {
        return instance;
    }
}
</code></pre>
                        <p><strong>优点：</strong>线程安全，实现简单</p>
                        <p><strong>缺点：</strong>类加载时就创建，可能浪费内存</p>
                    </div>

                    <div class="singleton-version">
                        <h4>😴 懒汉式（Lazy Loading）- 需要时才创建</h4>
<pre><code class="language-java">
public class LazySingleton {
    private static LazySingleton instance;
    
    private LazySingleton() {
        System.out.println("LazySingleton 实例被创建");
    }
    
    // 加synchronized确保线程安全，但性能较差
    public static synchronized LazySingleton getInstance() {
        if (instance == null) {
            instance = new LazySingleton();
        }
        return instance;
    }
}
</code></pre>
                        <p><strong>优点：</strong>按需创建，节省内存</p>
                        <p><strong>缺点：</strong>每次调用都要同步，性能较差</p>
                    </div>

                    <div class="singleton-version">
                        <h4>🔒 双重检查锁（Double-Check Locking）- 性能与安全的平衡</h4>
<pre><code class="language-java">
public class DoubleCheckSingleton {
    // volatile确保多线程环境下的可见性
    private static volatile DoubleCheckSingleton instance;
    
    private DoubleCheckSingleton() {
        System.out.println("DoubleCheckSingleton 实例被创建");
    }
    
    public static DoubleCheckSingleton getInstance() {
        if (instance == null) {  // 第一次检查
            synchronized (DoubleCheckSingleton.class) {
                if (instance == null) {  // 第二次检查
                    instance = new DoubleCheckSingleton();
                }
            }
        }
        return instance;
    }
}
</code></pre>
                        <p><strong>优点：</strong>线程安全且性能好</p>
                        <p><strong>缺点：</strong>代码复杂，需要理解volatile关键字</p>
                    </div>

                    <div class="singleton-version">
                        <h4>🏠 静态内部类（推荐）- 最优雅的解决方案</h4>
<pre><code class="language-java">
public class StaticInnerClassSingleton {
    
    private StaticInnerClassSingleton() {
        System.out.println("StaticInnerClassSingleton 实例被创建");
    }
    
    // 静态内部类，只有在被引用时才会加载
    private static class SingletonHolder {
        private static final StaticInnerClassSingleton INSTANCE = 
            new StaticInnerClassSingleton();
    }
    
    public static StaticInnerClassSingleton getInstance() {
        return SingletonHolder.INSTANCE;  // 触发内部类加载
    }
}
</code></pre>
                        <p><strong>优点：</strong>线程安全、按需加载、性能好、代码简洁</p>
                        <p><strong>缺点：</strong>无明显缺点，推荐使用</p>
                    </div>
                </div>

                <div class="real-world-examples">
                    <h3>🌍 真实世界中的单例模式应用</h3>
                    <div class="example-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        <div class="example-card">
                            <h4>🖥️ 系统配置管理器</h4>
<pre><code class="language-java">
public class ConfigManager {
    private static volatile ConfigManager instance;
    private Properties config;
    
    private ConfigManager() {
        config = new Properties();
        loadConfig();
    }
    
    public static ConfigManager getInstance() {
        if (instance == null) {
            synchronized (ConfigManager.class) {
                if (instance == null) {
                    instance = new ConfigManager();
                }
            }
        }
        return instance;
    }
    
    public String getProperty(String key) {
        return config.getProperty(key);
    }
}
</code></pre>
                        </div>
                        <div class="example-card">
                            <h4>📝 日志记录器</h4>
<pre><code class="language-java">
public class Logger {
    private static class LoggerHolder {
        private static final Logger INSTANCE = new Logger();
    }
    
    private Logger() {
        // 初始化日志配置
    }
    
    public static Logger getInstance() {
        return LoggerHolder.INSTANCE;
    }
    
    public void log(String message) {
        System.out.println("[" + new Date() + "] " + message);
    }
}
</code></pre>
                        </div>
                    </div>
                </div>
                
                <p class="conclusion">单例模式展示了封装的强大力量：通过控制构造过程，我们可以精确管理对象的生命周期和数量。</p>
            </div>
        </section>

        <!-- Slide 6: Inheritance Concept -->
        <section class="slide">
            <div class="slide-content">
                <h2>继承的本质：构建类的家族树</h2>
                <p>继承是面向对象编程中最重要的概念之一。它不仅仅是代码复用，更是对现实世界中"分类"和"特化"关系的抽象。</p>
                
                <div class="inheritance-benefits">
                    <h3>继承带来的好处</h3>
                    <div class="benefits-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                        <div class="benefit-item">
                            <h4>🔄 代码复用</h4>
                            <p>避免重复编写相同的代码，提高开发效率</p>
                        </div>
                        <div class="benefit-item">
                            <h4>📊 层次结构</h4>
                            <p>建立清晰的类层次关系，便于理解和维护</p>
                        </div>
                        <div class="benefit-item">
                            <h4>🔧 扩展性</h4>
                            <p>在不修改原有代码的基础上添加新功能</p>
                        </div>
                        <div class="benefit-item">
                            <h4>🎭 多态基础</h4>
                            <p>为多态提供基础，实现灵活的程序设计</p>
                        </div>
                    </div>
                </div>

                <div class="inheritance-rules">
                    <h3>继承的基本规则</h3>
                    <ul>
                        <li><strong>单继承：</strong>Java中一个类只能直接继承一个父类（但可以实现多个接口）</li>
                        <li><strong>传递性：</strong>如果C继承B，B继承A，那么C也拥有A的特性</li>
                        <li><strong>访问控制：</strong>子类不能访问父类的private成员，但可以访问protected和public成员</li>
                        <li><strong>构造顺序：</strong>创建子类对象时，总是先调用父类的构造方法</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Slide 7: Inheritance Chain Example -->
        <section class="slide">
            <div class="slide-content">
                <h2>继承链实战：构建一个完整的生物分类系统</h2>
                <p>让我们通过一个生物分类系统来深入理解继承链的工作原理。我们将从最抽象的"生物"开始，逐步细化到具体的"狗"。</p>
                
                <div class="inheritance-chain">
                    <div class="chain-level">
                        <h3>🌍 第一层：生物 (Organism)</h3>
<pre><code class="language-java">
public class Organism {
    protected String name;
    protected int age;
    protected boolean isAlive;
    
    public Organism(String name) {
        this.name = name;
        this.age = 0;
        this.isAlive = true;
        System.out.println("一个新的生物诞生了：" + name);
    }
    
    public void grow() {
        if (isAlive) {
            age++;
            System.out.println(name + " 长大了，现在 " + age + " 岁");
        }
    }
    
    public void die() {
        isAlive = false;
        System.out.println(name + " 死亡了");
    }
    
    // 所有生物都需要呼吸，但方式不同（留给子类实现）
    public void breathe() {
        System.out.println(name + " 在呼吸");
    }
}
</code></pre>
                    </div>

                    <div class="chain-level">
                        <h3>🦴 第二层：动物 (Animal)</h3>
<pre><code class="language-java">
public class Animal extends Organism {
    protected double weight;
    protected String habitat;  // 栖息地
    
    public Animal(String name, String habitat) {
        super(name);  // 调用父类构造方法
        this.habitat = habitat;
        this.weight = 1.0;
        System.out.println("这是一只动物，生活在：" + habitat);
    }
    
    // 重写父类的呼吸方法
    @Override
    public void breathe() {
        System.out.println(name + " 用肺呼吸");
    }
    
    // 动物特有的行为
    public void move() {
        if (isAlive) {
            System.out.println(name + " 在移动");
        }
    }
    
    public void eat(String food) {
        if (isAlive) {
            System.out.println(name + " 吃了 " + food);
            weight += 0.1;
        }
    }
    
    public void sleep() {
        System.out.println(name + " 在睡觉");
    }
}
</code></pre>
                    </div>
                    <div class="chain-level">
                        <h3>🐕 第三层：哺乳动物 (Mammal)</h3>
<pre><code class="language-java">
public class Mammal extends Animal {
    protected boolean hasFur;
    protected double bodyTemperature;
    
    public Mammal(String name, String habitat, boolean hasFur) {
        super(name, habitat);
        this.hasFur = hasFur;
        this.bodyTemperature = 37.0;  // 恒温动物
        System.out.println("这是一只哺乳动物，" + (hasFur ? "有毛发" : "无毛发"));
    }
    
    // 哺乳动物特有的行为
    public void feedMilk() {
        System.out.println(name + " 在哺乳");
    }
    
    public void regulateTemperature() {
        System.out.println(name + " 调节体温到 " + bodyTemperature + "°C");
    }
    
    // 重写移动方法，更具体化
    @Override
    public void move() {
        if (isAlive) {
            System.out.println(name + " 用四肢在 " + habitat + " 中移动");
        }
    }
}
</code></pre>
                    </div>

                    <div class="chain-level">
                        <h3>🐶 第四层：狗 (Dog)</h3>
<pre><code class="language-java">
public class Dog extends Mammal {
    private String breed;  // 品种
    private String owner;  // 主人
    
    public Dog(String name, String breed, String owner) {
        super(name, "家庭", true);  // 狗生活在家庭，有毛发
        this.breed = breed;
        this.owner = owner;
        System.out.println("这是一只 " + breed + "，主人是 " + owner);
    }
    
    // 狗特有的行为
    public void bark() {
        System.out.println(name + " 汪汪叫");
    }
    
    public void wagTail() {
        if (isAlive) {
            System.out.println(name + " 摇尾巴表示开心");
        }
    }
    
    public void fetch(String item) {
        System.out.println(name + " 去捡回 " + item);
    }
    
    // 重写吃的方法，更具体化
    @Override
    public void eat(String food) {
        if (food.equals("骨头") || food.equals("狗粮")) {
            super.eat(food);
            wagTail();  // 吃到喜欢的食物会摇尾巴
        } else {
            System.out.println(name + " 不喜欢吃 " + food);
        }
    }
    
    // 重写移动方法
    @Override
    public void move() {
        if (isAlive) {
            System.out.println(name + " 在 " + habitat + " 中奔跑和散步");
        }
    }
}
</code></pre>
                    </div>
                </div>

                <div class="usage-example">
                    <h3>🎯 使用示例：看看继承链的威力</h3>
<pre><code class="language-java">
public class InheritanceDemo {
    public static void main(String[] args) {
        // 创建一只狗
        Dog myDog = new Dog("旺财", "金毛", "小明");
        
        // 狗可以使用所有祖先类的方法
        myDog.grow();           // 来自 Organism
        myDog.breathe();        // 来自 Animal (重写了 Organism)
        myDog.eat("狗粮");       // 来自 Dog (重写了 Animal)
        myDog.feedMilk();       // 来自 Mammal
        myDog.bark();           // 来自 Dog
        myDog.move();           // 来自 Dog (重写了 Mammal)
        
        System.out.println("继承链演示完成！");
    }
}

/* 输出结果：
一个新的生物诞生了：旺财
这是一只动物，生活在：家庭
这是一只哺乳动物，有毛发
这是一只金毛，主人是小明
旺财 长大了，现在 1 岁
旺财 用肺呼吸
旺财 吃了 狗粮
旺财 摇尾巴表示开心
旺财 在哺乳
旺财 汪汪叫
旺财 在 家庭 中奔跑和散步
继承链演示完成！
*/
</code></pre>
                </div>
                
                <p class="conclusion">通过这个完整的继承链例子，我们看到了继承如何让代码层次清晰，每一层都在前一层的基础上添加新的特性，形成了一个完整的类族谱。狗类可以使用所有祖先类的功能！</p>
            </div>
        </section>

        <!-- Slide 8: Inheritance -->
        <section class="slide">
            <div class="slide-content">
                <h2>类的继承：站在巨人的肩膀上</h2>
                <p>继承是代码复用的强大机制。它允许我们创建一个新类（子类），该类继承一个已存在类（父类）的属性和方法。</p>
                <p>这形成了一种 "is-a" 的关系。例如，“学生”是一个“人”，“工人”也是一个“人”。学生和工人都拥有人的共性（如姓名、年龄），但又各自拥有独特的行为。</p>
                <img src="https://s2.loli.net/2022/09/21/zlZ9JXAjvxpawPF.png" alt="Inheritance Diagram" style="max-width: 70%; border: 1px solid var(--border-color); display: block; margin: 10px auto;">
                <p class="conclusion">子类继承父类的“遗产”（非私有成员），并可以添加自己的新功能，实现“青出于蓝而胜于蓝”。</p>
            </div>
        </section>

        <!-- Slide 7: Inheritance Syntax -->
        <section class="slide">
            <div class="slide-content">
                <h2>继承的语法：<code>extends</code> 关键字</h2>
                <p>在Java中，我们使用 <code>extends</code> 关键字来实现继承。一个类只能直接继承一个父类（单继承），但继承的层级可以无限延伸。</p>
<pre><code class="language-java">
// 父类：Person
public class Person {
    String name;
    int age;

    public void hello() {
        System.out.println("你好，我叫 " + name);
    }
}

// 子类：Student 继承自 Person
public class Student extends Person {
    public void study() {
        // 可以直接使用从父类继承来的 name 属性
        System.out.println(name + " 正在学习...");
    }
}

// 使用
Student student = new Student();
student.name = "小明";
student.study(); // 调用自己的方法
student.hello(); // 调用从父类继承的方法
</code></pre>
                <p class="warning">被 <code>final</code> 关键字修饰的类不能被继承。</p>
            </div>
        </section>

        <!-- Slide 10: super Keyword Deep Dive -->
        <section class="slide">
            <div class="slide-content">
                <h2><code>super</code> 关键字深度解析：与父类的沟通桥梁</h2>
                <p><code>super</code> 关键字是子类与父类之间的重要纽带，它有三个主要用途，让我们逐一深入了解：</p>
                
                <div class="super-usage">
                    <h3>1️⃣ 调用父类构造方法</h3>
                    <p><strong>规则：</strong><code>super(...)</code> 必须是子类构造方法的第一行语句</p>
<pre><code class="language-java">
public class Vehicle {
    protected String brand;
    protected int year;
    
    public Vehicle(String brand, int year) {
        this.brand = brand;
        this.year = year;
        System.out.println("Vehicle 构造方法被调用");
    }
}

public class Car extends Vehicle {
    private int doors;
    
    public Car(String brand, int year, int doors) {
        super(brand, year);  // 必须是第一行！
        this.doors = doors;
        System.out.println("Car 构造方法被调用");
    }
    
    // 如果不显式调用 super()，Java会自动调用父类的无参构造方法
    // 如果父类没有无参构造方法，编译会报错！
}
</code></pre>

                    <h3>2️⃣ 访问父类的方法（方法重写中的应用）</h3>
                    <p><strong>场景：</strong>子类重写父类方法时，想要在新功能基础上保留父类的原有功能</p>
<pre><code class="language-java">
public class BankAccount {
    protected double balance;
    
    public void deposit(double amount) {
        balance += amount;
        System.out.println("存款 " + amount + "，余额：" + balance);
    }
}

public class SavingsAccount extends BankAccount {
    private double interestRate = 0.02;
    
    @Override
    public void deposit(double amount) {
        super.deposit(amount);  // 先执行父类的存款逻辑
        
        // 然后添加储蓄账户特有的利息计算
        double interest = amount * interestRate;
        balance += interest;
        System.out.println("获得利息：" + interest + "，最终余额：" + balance);
    }
}
</code></pre>

                    <h3>3️⃣ 访问父类的属性（解决命名冲突）</h3>
                    <p><strong>场景：</strong>当子类和父类有同名属性时，明确指定访问父类的属性</p>
<pre><code class="language-java">
public class Animal {
    protected String name = "动物";
    
    public void showInfo() {
        System.out.println("我是：" + name);
    }
}

public class Dog extends Animal {
    private String name = "狗狗";  // 与父类同名
    
    public void showAllNames() {
        System.out.println("父类的 name：" + super.name);  // 输出：动物
        System.out.println("子类的 name：" + this.name);   // 输出：狗狗
        System.out.println("直接访问 name：" + name);       // 输出：狗狗（默认是this.name）
    }
    
    @Override
    public void showInfo() {
        super.showInfo();  // 调用父类的方法
        System.out.println("我还是：" + this.name);
    }
}
</code></pre>
                </div>

                <div class="super-demo">
                    <h3>🎯 完整示例：构造方法链的执行顺序</h3>
<pre><code class="language-java">
public class SuperDemo {
    public static void main(String[] args) {
        System.out.println("=== 创建 SavingsAccount 对象 ===");
        SavingsAccount account = new SavingsAccount("张三", 1000);
        
        System.out.println("\n=== 执行存款操作 ===");
        account.deposit(500);
        
        System.out.println("\n=== 显示信息 ===");
        account.showAllInfo();
    }
}

/* 输出结果：
=== 创建 SavingsAccount 对象 ===
BankAccount 构造方法：初始余额 1000.0
SavingsAccount 构造方法：设置账户持有人 张三

=== 执行存款操作 ===
存款 500.0，余额：1500.0
获得利息：10.0，最终余额：1510.0

=== 显示信息 ===
账户持有人：张三
当前余额：1510.0
*/
</code></pre>
                </div>

                <div class="super-tips">
                    <h3>💡 super 关键字使用要点</h3>
                    <ul>
                        <li><strong>构造方法：</strong><code>super()</code> 必须是第一行，且只能在构造方法中使用</li>
                        <li><strong>方法调用：</strong><code>super.methodName()</code> 可以在任何实例方法中使用</li>
                        <li><strong>属性访问：</strong><code>super.fieldName</code> 用于访问父类的非私有属性</li>
                        <li><strong>静态上下文：</strong>不能在静态方法或静态代码块中使用 super</li>
                        <li><strong>链式调用：</strong>super 只能访问直接父类，不能跨级访问祖父类</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Slide 9: Upcasting and Downcasting -->
        <section class="slide">
            <div class="slide-content">
                <h2>向上转型与向下转型：多态的体现</h2>
                <p><strong>向上转型 (Upcasting):</strong> 将子类对象赋值给父类引用。这是自动且安全的。</p>
                <p><code>Person person = new Student("小明", 18, "男");</code></p>
                <p>向上转型后，该引用只能调用父类中定义的方法，但如果该方法在子类中被重写，实际执行的是子类的版本。这就是多态！</p>
                <p><strong>向下转型 (Downcasting):</strong> 将父类引用强制转换回子类引用。这需要显式转换，并且有风险。</p>
                <p><code>Student student = (Student) person;</code></p>
                <p class="warning">向下转型前，必须使用 <code>instanceof</code> 关键字进行检查，否则可能在运行时抛出 <code>ClassCastException</code>。</p>
<pre><code class="language-java">
if (person instanceof Student) {
    Student student = (Student) person;
    student.study(); // 安全地调用子类特有的方法
}
</code></pre>
            </div>
        </section>

        <!-- Slide 10: The Object Class -->
        <section class="slide">
            <div class="slide-content">
                <h2>万物之源：顶层 <code>Object</code> 类</h2>
                <p>在Java中，如果一个类没有明确地 <code>extends</code> 另一个类，那么它就默认继承自 <code>java.lang.Object</code> 类。</p>
                <p>因此，<code>Object</code> 类是所有类的“祖先”，它提供了一些所有对象都应具备的基本方法。</p>
                <img src="https://s2.loli.net/2022/09/21/hkapOYVHBrjy7UC.png" alt="Object Hierarchy" style="max-width: 60%; border: 1px solid var(--border-color); display: block; margin: 10px auto;">
                <p>常用方法包括：</p>
                <ul>
                    <li><code>String toString()</code>: 返回对象的字符串表示。</li>
                    <li><code>boolean equals(Object obj)</code>: 比较两个对象是否“相等”。</li>
                    <li><code>int hashCode()</code>: 返回对象的哈希码。</li>
                    <li><code>Class<?> getClass()</code>: 返回对象的运行时类。</li>
                </ul>
            </div>
        </section>

        <!-- Slide 11: Method Overriding -->
        <section class="slide">
            <div class="slide-content">
                <h2>方法的重写 (Override)：定制子类的行为</h2>
                <p>重写是指子类可以提供一个与父类方法签名完全相同（方法名、参数列表、返回类型）的新实现，从而“覆盖”父类的行为。</p>
                <p>这与<strong>重载 (Overload)</strong> 不同：重载是在同一个类中定义多个同名但参数列表不同的方法。</p>
                <p>重写是实现多态的关键。例如，我们可以重写 <code>Object</code> 类的 <code>equals()</code> 和 <code>toString()</code> 方法来满足我们自己的业务需求。</p>
                <p class="conclusion">使用 <code>@Override</code> 注解是一个好习惯，它能让编译器帮助我们检查重写是否正确。</p>
            </div>
        </section>

        <!-- Slide 12: Overriding equals() and toString() -->
        <section class="slide">
            <div class="slide-content">
                <h2>重写示例：定制 <code>equals()</code> 和 <code>toString()</code></h2>
                <p>默认的 <code>equals()</code> 比较的是内存地址，而我们通常希望比较对象的内容。默认的 <code>toString()</code> 输出的是类名和哈希码，我们希望看到更有意义的信息。</p>
<pre><code class="language-java">
public class Person {
    private String name;
    private int age;
    // ... 构造方法 ...

    @Override
    public String toString() {
        return "Person{" + "name='" + name + ''' + ", age=" + age + '}';
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true; // 是同一个对象
        if (obj == null || getClass() != obj.getClass()) return false; // 类型不同
        Person person = (Person) obj;
        // 比较核心属性
        return age == person.age && name.equals(person.name);
    }
}
</code></pre>
                <p>重写后，即使是两个不同的对象，只要内容相同，<code>equals()</code> 也会返回 <code>true</code>。</p>
            </div>
        </section>

        <!-- Slide 13: Polymorphism Concept -->
        <section class="slide">
            <div class="slide-content">
                <h2>多态的本质：一个接口，多种实现</h2>
                <p>多态（Polymorphism）是面向对象编程的精髓，它让程序具有了"智能"——同一个方法调用可以根据对象的实际类型产生不同的行为。</p>
                
                <div class="polymorphism-types">
                    <h3>多态的三种形式</h3>
                    <div class="poly-types-grid" style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin: 20px 0;">
                        <div class="poly-type">
                            <h4>🔄 方法重载</h4>
                            <p><strong>编译时多态</strong><br>同一个类中，方法名相同但参数不同</p>
                        </div>
                        <div class="poly-type">
                            <h4>🎭 方法重写</h4>
                            <p><strong>运行时多态</strong><br>子类重写父类方法，实现不同行为</p>
                        </div>
                        <div class="poly-type">
                            <h4>📋 接口实现</h4>
                            <p><strong>契约多态</strong><br>不同类实现同一接口，提供不同实现</p>
                        </div>
                    </div>
                </div>

                <div class="polymorphism-benefits">
                    <h3>多态的核心价值</h3>
                    <ul>
                        <li><strong>🔧 降低耦合：</strong>调用者不需要知道具体的实现类，只需要知道接口</li>
                        <li><strong>📈 提高扩展性：</strong>新增子类无需修改现有代码</li>
                        <li><strong>🎯 统一处理：</strong>可以用统一的方式处理不同类型的对象</li>
                        <li><strong>🔄 代码复用：</strong>同一套代码可以处理多种类型</li>
                    </ul>
                </div>

                <div class="polymorphism-conditions">
                    <h3>实现多态的三个条件</h3>
                    <ol>
                        <li><strong>继承关系：</strong>必须有父类和子类的继承关系</li>
                        <li><strong>方法重写：</strong>子类必须重写父类的方法</li>
                        <li><strong>向上转型：</strong>父类引用指向子类对象</li>
                    </ol>
                </div>
            </div>
        </section>

        <!-- Slide 14: Dynamic Binding -->
        <section class="slide">
            <div class="slide-content">
                <h2>动态绑定：多态的底层机制</h2>
                <p>动态绑定（Dynamic Binding）是多态的核心机制，它让程序在运行时根据对象的实际类型来决定调用哪个方法。</p>
                
                <div class="binding-comparison">
                    <h3>静态绑定 vs 动态绑定</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                        <div class="binding-type">
                            <h4>🔒 静态绑定（编译时绑定）</h4>
                            <ul>
                                <li>在编译时就确定调用哪个方法</li>
                                <li>适用于：private方法、static方法、final方法、构造方法</li>
                                <li>效率高，但灵活性差</li>
                            </ul>
                        </div>
                        <div class="binding-type">
                            <h4>🔓 动态绑定（运行时绑定）</h4>
                            <ul>
                                <li>在运行时根据对象实际类型确定方法</li>
                                <li>适用于：普通实例方法的重写</li>
                                <li>灵活性高，是多态的基础</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="binding-process">
                    <h3>动态绑定的执行过程</h3>
<pre><code class="language-java">
// 1. 编译时：编译器只知道引用类型是 Animal
Animal animal = new Dog();

// 2. 运行时：JVM查找实际对象类型（Dog）的方法表
animal.makeSound();  // 调用 Dog 的 makeSound() 方法

/* JVM的查找过程：
 * 1. 检查 Dog 类是否有 makeSound() 方法 → 找到，执行
 * 2. 如果没找到，检查父类 Animal → 继续查找
 * 3. 一直向上查找到 Object 类
 * 4. 如果都没找到，编译错误
 */
</code></pre>
                </div>

                <div class="virtual-method-table">
                    <h3>虚方法表（Virtual Method Table）</h3>
                    <p>JVM为每个类维护一个虚方法表，存储该类所有可重写方法的地址：</p>
<pre><code class="language-java">
// Animal 的虚方法表
Animal VMT: [makeSound() → Animal.makeSound, eat() → Animal.eat]

// Dog 的虚方法表  
Dog VMT: [makeSound() → Dog.makeSound, eat() → Animal.eat, bark() → Dog.bark]

// 当调用 animal.makeSound() 时：
// 1. 找到对象实际类型：Dog
// 2. 查找 Dog 的虚方法表
// 3. 找到 makeSound() 对应的实际方法地址：Dog.makeSound
// 4. 执行 Dog.makeSound()
</code></pre>
                </div>
            </div>
        </section>

        <!-- Slide 15: Polymorphism in Action -->
        <section class="slide">
            <div class="slide-content">
                <h2>多态实战：构建一个图形绘制系统</h2>
                <p>让我们通过一个完整的图形绘制系统来深入理解多态的强大威力。</p>
                
                <div class="graphics-system">
                    <h3>🎨 图形系统的设计</h3>
<pre><code class="language-java">
// 抽象图形类
public abstract class Shape {
    protected String color;
    protected double x, y;  // 位置坐标
    
    public Shape(String color, double x, double y) {
        this.color = color;
        this.x = x;
        this.y = y;
    }
    
    // 抽象方法：每种图形的绘制方式不同
    public abstract void draw();
    public abstract double getArea();
    public abstract double getPerimeter();
    
    // 具体方法：所有图形都可以移动
    public void move(double deltaX, double deltaY) {
        this.x += deltaX;
        this.y += deltaY;
        System.out.println(color + "图形移动到 (" + x + ", " + y + ")");
    }
    
    // 通用信息显示
    public void showInfo() {
        System.out.println("颜色：" + color + "，位置：(" + x + ", " + y + ")");
        System.out.println("面积：" + getArea() + "，周长：" + getPerimeter());
    }
}
</code></pre>

                    <h3>🔴 圆形类</h3>
<pre><code class="language-java">
public class Circle extends Shape {
    private double radius;
    
    public Circle(String color, double x, double y, double radius) {
        super(color, x, y);
        this.radius = radius;
    }
    
    @Override
    public void draw() {
        System.out.println("绘制" + color + "圆形：中心(" + x + ", " + y + ")，半径" + radius);
    }
    
    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }
    
    @Override
    public double getPerimeter() {
        return 2 * Math.PI * radius;
    }
}
</code></pre>

                    <h3>🔲 矩形类</h3>
<pre><code class="language-java">
public class Rectangle extends Shape {
    private double width, height;
    
    public Rectangle(String color, double x, double y, double width, double height) {
        super(color, x, y);
        this.width = width;
        this.height = height;
    }
    
    @Override
    public void draw() {
        System.out.println("绘制" + color + "矩形：左上角(" + x + ", " + y + 
                          ")，宽" + width + "，高" + height);
    }
    
    @Override
    public double getArea() {
        return width * height;
    }
    
    @Override
    public double getPerimeter() {
        return 2 * (width + height);
    }
}
</code></pre>
                </div>
            </div>
        </section>

        <!-- Slide 16: Polymorphism Magic -->
        <section class="slide">
            <div class="slide-content">
                <h2>多态的魔力：同一调用，不同行为</h2>
                <p>现在让我们看看多态如何让我们用统一的方式处理不同类型的图形：</p>
                
                <div class="polymorphism-demo">
                    <h3>🎯 图形管理器：多态的完美体现</h3>
<pre><code class="language-java">
public class GraphicsManager {
    private List&lt;Shape&gt; shapes = new ArrayList&lt;&gt;();
    
    // 添加图形（接受任何 Shape 的子类）
    public void addShape(Shape shape) {
        shapes.add(shape);
        System.out.println("添加了一个图形");
    }
    
    // 绘制所有图形（多态的威力）
    public void drawAll() {
        System.out.println("=== 开始绘制所有图形 ===");
        for (Shape shape : shapes) {
            shape.draw();  // 多态：根据实际类型调用对应的 draw() 方法
        }
    }
    
    // 计算总面积
    public double getTotalArea() {
        double total = 0;
        for (Shape shape : shapes) {
            total += shape.getArea();  // 多态：调用各自的 getArea() 实现
        }
        return total;
    }
    
    // 移动所有图形
    public void moveAll(double deltaX, double deltaY) {
        for (Shape shape : shapes) {
            shape.move(deltaX, deltaY);  // 调用父类的通用方法
        }
    }
    
    // 显示所有图形信息
    public void showAllInfo() {
        System.out.println("=== 图形详细信息 ===");
        for (int i = 0; i < shapes.size(); i++) {
            System.out.println("图形 " + (i + 1) + ":");
            shapes.get(i).showInfo();  // 多态：调用各自重写的方法
            System.out.println();
        }
    }
}
</code></pre>

                    <h3>🚀 使用示例：看多态的神奇效果</h3>
<pre><code class="language-java">
public class PolymorphismDemo {
    public static void main(String[] args) {
        GraphicsManager manager = new GraphicsManager();
        
        // 创建不同类型的图形
        Shape circle = new Circle("红色", 10, 10, 5);
        Shape rectangle = new Rectangle("蓝色", 20, 20, 8, 6);
        Shape triangle = new Triangle("绿色", 30, 30, 4, 3);
        
        // 添加到管理器（多态：统一处理不同类型）
        manager.addShape(circle);
        manager.addShape(rectangle);
        manager.addShape(triangle);
        
        // 统一操作（多态的威力）
        manager.drawAll();
        System.out.println("总面积：" + manager.getTotalArea());
        manager.moveAll(5, 5);
        manager.showAllInfo();
    }
}

/* 输出结果：
添加了一个图形
添加了一个图形  
添加了一个图形
=== 开始绘制所有图形 ===
绘制红色圆形：中心(10.0, 10.0)，半径5.0
绘制蓝色矩形：左上角(20.0, 20.0)，宽8.0，高6.0
绘制绿色三角形：底边4.0，高3.0，位置(30.0, 30.0)
总面积：134.53981633974483
红色图形移动到 (15.0, 15.0)
蓝色图形移动到 (25.0, 25.0)
绿色图形移动到 (35.0, 35.0)
=== 图形详细信息 ===
...
*/
</code></pre>
                </div>
                
                <p class="conclusion">多态让我们可以用统一的接口处理不同的对象，极大地提高了代码的灵活性和可扩展性。当需要添加新的图形类型时，只需要继承Shape类并实现抽象方法，无需修改GraphicsManager的代码！</p>
            </div>
        </section>

        <!-- Slide 14: Abstract Classes -->
        <section class="slide">
            <div class="slide-content">
                <h2>抽象类 (Abstract Class)：定义行为的“蓝图”</h2>
                <p>当一个父类只知道其子类应该包含什么方法，但无法确定这些方法的具体实现时，就可以使用抽象类。</p>
                <p>抽象类使用 <code>abstract</code> 关键字修饰，它可以包含抽象方法（只有声明，没有方法体）和具体方法。</p>
                <ul>
                    <li>抽象类<strong>不能</strong>被实例化 (不能 <code>new</code>)。</li>
                    <li>继承抽象类的子类<strong>必须</strong>实现其所有抽象方法，除非子类自己也是抽象类。</li>
                </ul>
<pre><code class="language-java">
// 抽象类 Animal
public abstract class Animal {
    // 抽象方法：不知道怎么叫，留给子类实现
    public abstract void makeSound();

    // 具体方法：所有动物都会跑
    public void run() {
        System.out.println("动物在跑...");
    }
}

// 具体类 Dog
public class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("汪汪！");
    }
}
</code></pre>
            </div>
        </section>

        <!-- Slide 15: Interfaces -->
        <section class="slide">
            <div class="slide-content">
                <h2>接口 (Interface)：定义能力的“契约”</h2>
                <p>接口是比抽象类更纯粹的抽象。它只定义了一组行为规范（方法签名），而不关心任何实现。接口体现了 "has-a" 或 "can-do" 的关系。</p>
                <p>一个类可以实现（<code>implements</code>）多个接口，这弥补了Java单继承的不足。</p>
                <ul>
                    <li>接口中的方法默认是 <code>public abstract</code> 的。</li>
                    <li>接口中的变量默认是 <code>public static final</code> 的（常量）。</li>
                    <li>实现接口的类必须实现其所有抽象方法。</li>
                </ul>
<pre><code class="language-java">
// 定义“会飞”的能力
public interface Flyable {
    void fly(); // 接口方法
}

// 定义“会游泳”的能力
public interface Swimmable {
    void swim();
}

// Duck 类实现了这两种能力
public class Duck implements Flyable, Swimmable {
    @Override
    public void fly() { System.out.println("鸭子在飞..."); }

    @Override
    public void swim() { System.out.println("鸭子在游泳..."); }
}
</code></pre>
            </div>
        </section>

        <!-- Slide 16: Interface Deep Dive -->
        <section class="slide">
            <div class="slide-content">
                <h2>接口深度解析：现代Java接口特性</h2>
                <p>Java 8+ 为接口引入了新特性，使接口更加强大和灵活。</p>
                
                <div class="interface-features">
                    <h3>🚀 现代接口的完整特性</h3>
<pre><code class="language-java">
public interface ModernInterface {
    // 1. 常量（隐式 public static final）
    int MAX_SIZE = 100;
    String DEFAULT_NAME = "Unknown";
    
    // 2. 抽象方法（隐式 public abstract）
    void abstractMethod();
    
    // 3. 默认方法（Java 8+）- 可以有实现
    default void defaultMethod() {
        System.out.println("这是默认实现");
        // 可以调用其他方法
        abstractMethod();
    }
    
    // 4. 静态方法（Java 8+）
    static void staticMethod() {
        System.out.println("接口的静态方法");
    }
    
    // 5. 私有方法（Java 9+）- 用于代码复用
    private void privateHelper() {
        System.out.println("私有辅助方法");
    }
    
    // 6. 私有静态方法（Java 9+）
    private static void privateStaticHelper() {
        System.out.println("私有静态辅助方法");
    }
}
</code></pre>
                </div>

                <div class="interface-evolution">
                    <h3>📈 接口的演进历程</h3>
                    <ul>
                        <li><strong>Java 7及之前：</strong>只能有抽象方法和常量</li>
                        <li><strong>Java 8：</strong>引入默认方法和静态方法</li>
                        <li><strong>Java 9：</strong>支持私有方法和私有静态方法</li>
                        <li><strong>现在：</strong>接口几乎具备了类的所有功能（除了实例变量和构造方法）</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Slide 17: Abstract Class vs Interface -->
        <section class="slide">
            <div class="slide-content">
                <h2>抽象类 vs 接口：深度对比分析</h2>
                <p>抽象类和接口都是实现抽象的重要手段，但它们有着不同的设计理念和使用场景。</p>
                
                <div class="comparison-table">
                    <h3>📊 详细对比表</h3>
                    <table style="width: 100%; border-collapse: collapse; margin: 20px 0; font-size: 14px;">
                        <thead>
                            <tr style="background-color: var(--primary-color); color: white;">
                                <th style="padding: 8px; border: 1px solid #ddd;">对比维度</th>
                                <th style="padding: 8px; border: 1px solid #ddd;">抽象类 (Abstract Class)</th>
                                <th style="padding: 8px; border: 1px solid #ddd;">接口 (Interface)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td style="padding: 6px; border: 1px solid #ddd;"><strong>设计理念</strong></td>
                                <td style="padding: 6px; border: 1px solid #ddd;">"is-a" 关系，表示本质</td>
                                <td style="padding: 6px; border: 1px solid #ddd;">"can-do" 关系，表示能力</td>
                            </tr>
                            <tr>
                                <td style="padding: 6px; border: 1px solid #ddd;"><strong>继承数量</strong></td>
                                <td style="padding: 6px; border: 1px solid #ddd;">单继承（extends）</td>
                                <td style="padding: 6px; border: 1px solid #ddd;">多实现（implements）</td>
                            </tr>
                            <tr>
                                <td style="padding: 6px; border: 1px solid #ddd;"><strong>方法类型</strong></td>
                                <td style="padding: 6px; border: 1px solid #ddd;">抽象方法 + 具体方法</td>
                                <td style="padding: 6px; border: 1px solid #ddd;">抽象 + 默认 + 静态 + 私有方法</td>
                            </tr>
                            <tr>
                                <td style="padding: 6px; border: 1px solid #ddd;"><strong>成员变量</strong></td>
                                <td style="padding: 6px; border: 1px solid #ddd;">任意访问修饰符，可变</td>
                                <td style="padding: 6px; border: 1px solid #ddd;">public static final（常量）</td>
                            </tr>
                            <tr>
                                <td style="padding: 6px; border: 1px solid #ddd;"><strong>构造方法</strong></td>
                                <td style="padding: 6px; border: 1px solid #ddd;">可以有构造方法</td>
                                <td style="padding: 6px; border: 1px solid #ddd;">不能有构造方法</td>
                            </tr>
                            <tr>
                                <td style="padding: 6px; border: 1px solid #ddd;"><strong>实例化</strong></td>
                                <td style="padding: 6px; border: 1px solid #ddd;">不能直接实例化</td>
                                <td style="padding: 6px; border: 1px solid #ddd;">不能直接实例化</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="design-principles">
                    <h3>🎯 设计原则和选择指南</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 15px 0;">
                        <div class="principle-box" style="border: 2px solid #4CAF50; padding: 15px; border-radius: 8px;">
                            <h4 style="color: #4CAF50;">🏗️ 选择抽象类的场景</h4>
                            <ul style="margin: 10px 0; font-size: 14px;">
                                <li>有共同的代码需要复用</li>
                                <li>需要定义非public的方法</li>
                                <li>需要定义实例变量</li>
                                <li>类之间有明确的"is-a"关系</li>
                                <li>需要提供构造方法</li>
                            </ul>
                        </div>
                        <div class="principle-box" style="border: 2px solid #2196F3; padding: 15px; border-radius: 8px;">
                            <h4 style="color: #2196F3;">🔌 选择接口的场景</h4>
                            <ul style="margin: 10px 0; font-size: 14px;">
                                <li>定义一组能力或行为规范</li>
                                <li>需要多重继承的效果</li>
                                <li>不同类需要相同的行为</li>
                                <li>强调"can-do"的能力关系</li>
                                <li>API设计和框架开发</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 18: Real-world Design Example -->
        <section class="slide">
            <div class="slide-content">
                <h2>实战案例：智能设备管理系统</h2>
                <p>通过一个完整的案例来理解抽象类和接口的协同使用。</p>
                
                <div class="real-world-example">
                    <h3>🌍 系统设计思路</h3>
<pre><code class="language-java">
// 抽象类：定义设备的共同本质（is-a关系）
public abstract class SmartDevice {
    protected String deviceId;
    protected String brand;
    protected boolean isOnline;
    
    // 构造方法
    public SmartDevice(String deviceId, String brand) {
        this.deviceId = deviceId;
        this.brand = brand;
        this.isOnline = false;
    }
    
    // 具体方法：所有设备的共同行为
    public void connect() {
        isOnline = true;
        System.out.println(brand + " 设备 " + deviceId + " 已连接");
    }
    
    public void disconnect() {
        isOnline = false;
        System.out.println("设备 " + deviceId + " 已断开");
    }
    
    // 抽象方法：不同设备的特定行为
    public abstract void performMainFunction();
    public abstract String getDeviceType();
}

// 接口：定义设备的能力（can-do关系）
interface Controllable {
    void turnOn();
    void turnOff();
    boolean isOn();
}

interface Schedulable {
    void setSchedule(String time, String action);
    void executeScheduledTask();
}

interface VoiceControlled {
    void processVoiceCommand(String command);
    default void enableVoiceControl() {
        System.out.println("语音控制已启用");
    }
}

// 具体设备类：智能灯泡
public class SmartBulb extends SmartDevice 
                      implements Controllable, Schedulable, VoiceControlled {
    private boolean isLightOn = false;
    private int brightness = 50;
    private String scheduledAction;
    
    public SmartBulb(String deviceId, String brand) {
        super(deviceId, brand);
    }
    
    @Override
    public void performMainFunction() {
        System.out.println("智能灯泡提供照明功能");
    }
    
    @Override
    public String getDeviceType() {
        return "Smart Bulb";
    }
    
    // 实现 Controllable 接口
    @Override
    public void turnOn() {
        isLightOn = true;
        System.out.println("灯泡已开启，亮度：" + brightness + "%");
    }
    
    @Override
    public void turnOff() {
        isLightOn = false;
        System.out.println("灯泡已关闭");
    }
    
    @Override
    public boolean isOn() {
        return isLightOn;
    }
    
    // 实现 Schedulable 接口
    @Override
    public void setSchedule(String time, String action) {
        scheduledAction = action;
        System.out.println("已设置定时任务：" + time + " - " + action);
    }
    
    @Override
    public void executeScheduledTask() {
        if (scheduledAction != null) {
            System.out.println("执行定时任务：" + scheduledAction);
        }
    }
    
    // 实现 VoiceControlled 接口
    @Override
    public void processVoiceCommand(String command) {
        switch (command.toLowerCase()) {
            case "开灯":
                turnOn();
                break;
            case "关灯":
                turnOff();
                break;
            case "调亮":
                brightness = Math.min(100, brightness + 20);
                System.out.println("亮度调至：" + brightness + "%");
                break;
            default:
                System.out.println("无法识别的语音命令：" + command);
        }
    }
}
</code></pre>
                </div>
            </div>
        </section>

        <!-- Slide 19: Usage Example -->
        <section class="slide">
            <div class="slide-content">
                <h2>系统使用示例：多态的威力</h2>
                <p>看看如何通过多态和接口实现灵活的设备管理。</p>
                
<pre><code class="language-java">
public class SmartHomeManager {
    private List&lt;SmartDevice&gt; devices = new ArrayList&lt;&gt;();
    
    public void addDevice(SmartDevice device) {
        devices.add(device);
        device.connect();
    }
    
    // 多态：统一管理所有设备
    public void showAllDevices() {
        for (SmartDevice device : devices) {
            System.out.println("设备类型：" + device.getDeviceType());
            device.performMainFunction();  // 多态调用
        }
    }
    
    // 接口：只控制可控制的设备
    public void turnOnAllControllableDevices() {
        for (SmartDevice device : devices) {
            if (device instanceof Controllable) {
                Controllable controllable = (Controllable) device;
                controllable.turnOn();
            }
        }
    }
    
    // 接口：为支持语音的设备执行语音命令
    public void executeVoiceCommand(String command) {
        for (SmartDevice device : devices) {
            if (device instanceof VoiceControlled) {
                VoiceControlled voiceDevice = (VoiceControlled) device;
                voiceDevice.processVoiceCommand(command);
            }
        }
    }
}

// 使用示例
public class SmartHomeDemo {
    public static void main(String[] args) {
        SmartHomeManager manager = new SmartHomeManager();
        
        // 添加设备
        SmartBulb bulb1 = new SmartBulb("BULB001", "飞利浦");
        SmartBulb bulb2 = new SmartBulb("BULB002", "小米");
        
        manager.addDevice(bulb1);
        manager.addDevice(bulb2);
        
        // 多态：统一管理
        manager.showAllDevices();
        
        // 接口：能力导向的操作
        manager.turnOnAllControllableDevices();
        manager.executeVoiceCommand("调亮");
        
        // 设置定时任务
        bulb1.setSchedule("22:00", "关灯");
        bulb1.executeScheduledTask();
    }
}
</code></pre>

                <div class="design-insights">
                    <h3>🎯 设计洞察</h3>
                    <ul>
                        <li><strong>抽象类 SmartDevice：</strong>定义了所有智能设备的共同本质和行为</li>
                        <li><strong>接口 Controllable/Schedulable/VoiceControlled：</strong>定义了设备的不同能力</li>
                        <li><strong>多态：</strong>允许统一管理不同类型的设备</li>
                        <li><strong>接口分离：</strong>每个接口专注于一种特定能力，符合单一职责原则</li>
                        <li><strong>灵活扩展：</strong>新设备只需继承抽象类并实现相应接口即可</li>
                    </ul>
                </div>
            </div>
        </section>
        
        <!-- Slide 20: Enum Classes -->
        <section class="slide">
            <div class="slide-content">
                <h2>枚举类 (Enum)：安全的常量集合</h2>
                <p>当一个变量的取值范围是有限且固定的集合时（如星期、季节、状态），使用枚举类是最佳选择。</p>
                <p>枚举提供了类型安全，避免了使用字符串或整数常量可能导致的错误，并使代码更具可读性。</p>
<pre><code class="language-java">
// 定义一个表示状态的枚举
public enum Status {
    RUNNING("跑步中"), 
    STUDYING("学习中"), 
    SLEEPING("睡觉中");

    private final String description;

    // 枚举的构造方法默认是 private
    Status(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }
}

// 使用枚举
Status currentStatus = Status.STUDYING;
System.out.println("当前状态: " + currentStatus.getDescription()); // 输出: 当前状态: 学习中
</code></pre>
                <p class="conclusion">枚举的本质是继承自 <code>java.lang.Enum</code> 的特殊类，功能远比简单的常量强大。</p>
            </div>
        </section>

        <!-- Slide 21: Interactive Exercises -->
        <section class="slide">
            <div class="slide-content">
                <h2>🎯 互动练习：检验你的理解</h2>
                <p>通过这些练习题来检验你对面向对象三大特性的掌握程度。</p>
                
                <div class="exercise-section">
                    <h3>📝 练习1：设计选择题</h3>
                    <div class="exercise-box" style="background-color: #f8f9fa; padding: 20px; border-radius: 8px; margin: 15px 0;">
                        <p><strong>场景：</strong>你需要设计一个图形绘制系统，包含圆形、矩形、三角形等图形。每种图形都能计算面积、周长，但计算方式不同。部分图形还具有旋转、缩放等特殊能力。</p>
                        
                        <p><strong>问题：</strong>你会如何设计这个系统？</p>
                        
                        <div class="options" style="margin: 15px 0;">
                            <div style="margin: 8px 0;">
                                <strong>A.</strong> 创建一个 Shape 接口，所有图形实现这个接口
                            </div>
                            <div style="margin: 8px 0;">
                                <strong>B.</strong> 创建一个 Shape 抽象类，所有图形继承这个类
                            </div>
                            <div style="margin: 8px 0;">
                                <strong>C.</strong> 创建 Shape 抽象类 + Rotatable、Scalable 接口
                            </div>
                            <div style="margin: 8px 0;">
                                <strong>D.</strong> 直接创建具体的图形类，不需要抽象
                            </div>
                        </div>
                        
                        <div class="answer" style="background-color: #d4edda; padding: 10px; border-radius: 5px; margin-top: 15px;">
                            <strong>💡 推荐答案：C</strong><br>
                            <strong>理由：</strong>Shape 抽象类定义图形的共同本质（都有面积、周长），Rotatable、Scalable 接口定义特殊能力，体现了"is-a"和"can-do"的设计理念。
                        </div>
                    </div>
                </div>

                <div class="exercise-section">
                    <h3>🔧 练习2：代码实现</h3>
                    <div class="exercise-box" style="background-color: #f8f9fa; padding: 20px; border-radius: 8px; margin: 15px 0;">
                        <p><strong>任务：</strong>基于上面的设计，实现一个简单的 Circle 类</p>
                        
                        <p><strong>要求：</strong></p>
                        <ul>
                            <li>继承 Shape 抽象类</li>
                            <li>实现 Rotatable 接口（圆形旋转不改变外观）</li>
                            <li>正确实现面积和周长计算</li>
                            <li>提供合适的构造方法</li>
                        </ul>
                        
                        <div class="code-template" style="background-color: #fff; padding: 15px; border: 1px solid #ddd; border-radius: 5px; margin: 10px 0;">
<pre><code class="language-java">
// 你的代码框架
public abstract class Shape {
    protected String color;
    
    public Shape(String color) {
        this.color = color;
    }
    
    public abstract double getArea();
    public abstract double getPerimeter();
    
    public void display() {
        System.out.println(color + "的图形");
    }
}

interface Rotatable {
    void rotate(double angle);
}

// 请完成 Circle 类的实现
public class Circle extends Shape implements Rotatable {
    // 你的实现...
}
</code></pre>
                        </div>
                    </div>
                </div>

                <div class="exercise-section">
                    <h3>🤔 练习3：多态理解</h3>
                    <div class="exercise-box" style="background-color: #f8f9fa; padding: 20px; border-radius: 8px; margin: 15px 0;">
                        <p><strong>代码分析：</strong>下面代码的输出是什么？为什么？</p>
                        
<pre><code class="language-java">
class Animal {
    public void makeSound() {
        System.out.println("动物发出声音");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("汪汪汪");
    }
    
    public void wagTail() {
        System.out.println("摇尾巴");
    }
}

public class Test {
    public static void main(String[] args) {
        Animal animal = new Dog();
        animal.makeSound();        // 输出什么？
        // animal.wagTail();       // 这行代码会怎样？
    }
}
</code></pre>
                        
                        <div class="answer" style="background-color: #d4edda; padding: 10px; border-radius: 5px; margin-top: 15px;">
                            <strong>💡 答案：</strong><br>
                            1. <code>animal.makeSound()</code> 输出 "汪汪汪"（动态绑定，调用子类重写的方法）<br>
                            2. <code>animal.wagTail()</code> 编译错误（父类引用无法访问子类特有方法）
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 22: Common Pitfalls -->
        <section class="slide">
            <div class="slide-content">
                <h2>⚠️ 常见错误和陷阱</h2>
                <p>学习过程中容易犯的错误，提前了解可以避免很多坑。</p>
                
                <div class="pitfall-section">
                    <h3>🚫 陷阱1：封装破坏</h3>
                    <div class="pitfall-box" style="border-left: 4px solid #dc3545; padding: 15px; margin: 15px 0; background-color: #f8d7da;">
                        <h4>❌ 错误示例</h4>
<pre><code class="language-java">
public class Student {
    public String name;           // 直接暴露字段
    public List&lt;String&gt; courses;   // 暴露可变集合
    
    public List&lt;String&gt; getCourses() {
        return courses;           // 返回内部集合的直接引用
    }
}

// 使用时可能出现的问题
Student student = new Student();
student.name = "";               // 可以设置无效值
student.getCourses().clear();    // 外部可以修改内部状态
</code></pre>
                        
                        <h4>✅ 正确做法</h4>
<pre><code class="language-java">
public class Student {
    private String name;
    private List&lt;String&gt; courses = new ArrayList&lt;&gt;();
    
    public void setName(String name) {
        if (name != null && !name.trim().isEmpty()) {
            this.name = name;
        } else {
            throw new IllegalArgumentException("姓名不能为空");
        }
    }
    
    public String getName() {
        return name;
    }
    
    public List&lt;String&gt; getCourses() {
        return new ArrayList&lt;&gt;(courses);  // 返回副本，保护内部状态
    }
    
    public void addCourse(String course) {
        if (course != null && !courses.contains(course)) {
            courses.add(course);
        }
    }
}
</code></pre>
                    </div>
                </div>

                <div class="pitfall-section">
                    <h3>🚫 陷阱2：继承滥用</h3>
                    <div class="pitfall-box" style="border-left: 4px solid #dc3545; padding: 15px; margin: 15px 0; background-color: #f8d7da;">
                        <h4>❌ 错误示例：为了复用代码而强行继承</h4>
<pre><code class="language-java">
// 错误：汽车不是一种房子！
public class Car extends House {
    // 只是为了复用 House 中的 address 字段
    private String address;  // 停车位置
    
    public void drive() {
        System.out.println("汽车在行驶");
    }
}
</code></pre>
                        
                        <h4>✅ 正确做法：使用组合而非继承</h4>
<pre><code class="language-java">
public class Location {
    private String address;
    private double latitude;
    private double longitude;
    
    // 构造方法和getter/setter...
}

public class Car {
    private Location currentLocation;  // 组合：汽车"有一个"位置
    private String brand;
    
    public void drive() {
        System.out.println("汽车在行驶");
    }
    
    public void parkAt(Location location) {
        this.currentLocation = location;
    }
}

public class House {
    private Location location;  // 组合：房子"有一个"位置
    private int rooms;
    
    // 房子的相关方法...
}
</code></pre>
                    </div>
                </div>

                <div class="pitfall-section">
                    <h3>🚫 陷阱3：多态误用</h3>
                    <div class="pitfall-box" style="border-left: 4px solid #dc3545; padding: 15px; margin: 15px 0; background-color: #f8d7da;">
                        <h4>❌ 常见错误</h4>
<pre><code class="language-java">
Animal animal = new Dog();
Dog dog = animal;              // 编译错误：不能直接向下转型
dog.wagTail();

// 或者
if (animal instanceof Dog) {
    Dog dog = (Dog) animal;
    dog.wagTail();             // 虽然可以，但破坏了多态的意义
}
</code></pre>
                        
                        <h4>✅ 正确做法：通过接口或抽象方法实现</h4>
<pre><code class="language-java">
// 定义能力接口
interface TailWagger {
    void wagTail();
}

class Dog extends Animal implements TailWagger {
    @Override
    public void wagTail() {
        System.out.println("摇尾巴");
    }
}

// 使用时
Animal animal = new Dog();
if (animal instanceof TailWagger) {
    TailWagger wagger = (TailWagger) animal;
    wagger.wagTail();          // 基于能力的调用，更符合OOP原则
}
</code></pre>
                    </div>
                </div>

                <div class="best-practices">
                    <h3>💡 最佳实践总结</h3>
                    <div style="background-color: #d1ecf1; padding: 15px; border-radius: 8px; margin: 15px 0;">
                        <ul>
                            <li><strong>封装：</strong>永远使用private字段 + public方法，验证输入，保护内部状态</li>
                            <li><strong>继承：</strong>确保真正的"is-a"关系，优先考虑组合而非继承</li>
                            <li><strong>多态：</strong>通过接口和抽象类设计，避免强制类型转换</li>
                            <li><strong>接口：</strong>保持接口小而专注，遵循单一职责原则</li>
                            <li><strong>抽象类：</strong>提供合理的默认实现，为子类留出扩展空间</li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 23: Conclusion -->
        <section class="slide">
            <div class="slide-content">
                <h2>总结：封装、继承与多态</h2>
                <p>今天我们学习了面向对象编程的三大核心特性，它们是构建高质量Java应用的基石。</p>
                <ul>
                    <li><strong>封装</strong>是基础，它保护数据，隐藏细节，提供了清晰的接口。</li>
                    <li><strong>继承</strong>是扩展，它复用代码，建立了类之间的层次关系。</li>
                    <li><strong>多态</strong>是灵魂，它提升了灵活性和可扩展性，让程序“活”了起来。</li>
                </ul>
                <p>同时，我们也了解了抽象类、接口和枚举等重要概念，它们都是实现这些特性的重要工具。</p>
                <p class="conclusion">请务必多加练习，在实践中去体会这些思想的精髓。编程之路，知易行难，唯有实践出真知！</p>
            </div>
        </section>

        <!-- UI Elements -->
        <div class="progress-bar-container">
            <div id="progress-bar"></div>
        </div>
        <div class="controls">
            <button id="prevBtn">上一页</button>
            <span id="slide-counter">1 / X</span>
            <button id="nextBtn">下一页</button>
        </div>
    </main>

    <script src="./js/animation.js"></script>
    <script src="./js/ppt.js"></script>
    <script src="../prism/prism.js"></script>
    <script src="../prism/prism-autoloader.min.js"></script>

</body>
</html>