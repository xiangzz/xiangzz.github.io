<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java Collections Framework - 集合框架详解</title>
    <link rel="stylesheet" href="./css/style.css">
    <link rel="stylesheet" href="../prism/prism.css">
</head>
<body>

    <main id="presentation">
        <!-- Slide 1: Title -->
        <section class="slide title-slide active">
            <h1>Java Collections Framework</h1>
            <p>集合框架详解</p>
            <strong>让数据管理更高效、更灵活、更强大</strong>
            <div class="collections-visual">
                <span class="collection-icon">📦</span>
                <span class="arrow">→</span>
                <span class="code-snippet">高效数据结构</span>
            </div>
        </section>

        <!-- Slide 2: What is Collections -->
        <section class="slide">
            <div class="slide-content">
                <h2>什么是 Collections？</h2>
                <p>Java Collections Framework 是一套用于存储和操作对象集合的统一架构。</p>
                
                <div class="concept-grid">
                    <div class="concept-item">
                        <h3>🎯 核心目标</h3>
                        <ul>
                            <li>提供高性能的数据结构</li>
                            <li>减少编程工作量</li>
                            <li>提供统一的API</li>
                        </ul>
                    </div>
                    
                    <div class="concept-item">
                        <h3>📚 主要组件</h3>
                        <ul>
                            <li><strong>接口</strong>：定义集合的抽象数据类型</li>
                            <li><strong>实现</strong>：接口的具体实现类</li>
                            <li><strong>算法</strong>：对集合进行操作的方法</li>
                        </ul>
                    </div>
                </div>
                
                <div class="comparison">
                    <div class="before">
                        <h3>传统数组 😰</h3>
                        <pre><code class="language-java">// 固定大小，操作复杂
String[] names = new String[10];
names[0] = "张三";
names[1] = "李四";
// 需要手动管理大小和索引</code></pre>
                    </div>
                    
                    <div class="after">
                        <h3>Collections 😍</h3>
                        <pre><code class="language-java">// 动态大小，操作简单
List&lt;String&gt; names = new ArrayList&lt;&gt;();
names.add("张三");
names.add("李四");
// 自动管理大小，丰富的操作方法</code></pre>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 3: Collections Framework Structure -->
        <section class="slide">
            <div class="slide-content">
                <h2>Collections 框架结构</h2>
                
                <div class="hierarchy-diagram">
                    <div class="interface-level">
                        <h3>核心接口</h3>
                        <div class="interface-boxes">
                            <div class="interface-box collection">
                                <strong>Collection</strong>
                                <span>基础集合接口</span>
                            </div>
                            <div class="interface-box map">
                                <strong>Map</strong>
                                <span>键值对映射</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="subinterface-level">
                        <h3>子接口</h3>
                        <div class="subinterface-boxes">
                            <div class="subinterface-box list">
                                <strong>List</strong>
                                <span>有序可重复</span>
                            </div>
                            <div class="subinterface-box set">
                                <strong>Set</strong>
                                <span>无序不重复</span>
                            </div>
                            <div class="subinterface-box queue">
                                <strong>Queue</strong>
                                <span>队列结构</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="implementation-level">
                        <h3>常用实现类</h3>
                        <div class="impl-grid">
                            <div class="impl-group">
                                <h4>List 实现</h4>
                                <span>ArrayList, LinkedList, Vector</span>
                            </div>
                            <div class="impl-group">
                                <h4>Set 实现</h4>
                                <span>HashSet, TreeSet, LinkedHashSet</span>
                            </div>
                            <div class="impl-group">
                                <h4>Map 实现</h4>
                                <span>HashMap, TreeMap, LinkedHashMap</span>
                            </div>
                            <div class="impl-group">
                                <h4>Queue 实现</h4>
                                <span>ArrayDeque, PriorityQueue</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 4: List Interface -->
        <section class="slide">
            <div class="slide-content">
                <h2>List 接口 - 有序可重复集合</h2>
                
                <div class="list-comparison">
                    <div class="list-type">
                        <h3>ArrayList 📋</h3>
                        <div class="features">
                            <p><strong>特点：</strong>基于动态数组，随机访问快</p>
                            <p><strong>适用：</strong>频繁查询，较少插入删除</p>
                        </div>
                        <pre><code class="language-java">// ArrayList 示例
List&lt;String&gt; arrayList = new ArrayList&lt;&gt;();
arrayList.add("苹果");
arrayList.add("香蕉");
arrayList.add("橙子");

// 随机访问 O(1)
String fruit = arrayList.get(1); // "香蕉"

// 遍历
for (String item : arrayList) {
    System.out.println(item);
}</code></pre>
                    </div>
                    
                    <div class="list-type">
                        <h3>LinkedList 🔗</h3>
                        <div class="features">
                            <p><strong>特点：</strong>基于双向链表，插入删除快</p>
                            <p><strong>适用：</strong>频繁插入删除，较少随机访问</p>
                        </div>
                        <pre><code class="language-java">// LinkedList 示例
List&lt;String&gt; linkedList = new LinkedList&lt;&gt;();
linkedList.add("第一个");
linkedList.add("第二个");

// 在开头插入 O(1)
linkedList.add(0, "新的第一个");

// 作为队列使用
LinkedList&lt;String&gt; queue = new LinkedList&lt;&gt;();
queue.offer("任务1"); // 入队
queue.offer("任务2");
String task = queue.poll(); // 出队</code></pre>
                    </div>
                </div>
                
                <div class="performance-table">
                    <h3>性能对比</h3>
                    <table>
                        <tr>
                            <th>操作</th>
                            <th>ArrayList</th>
                            <th>LinkedList</th>
                        </tr>
                        <tr>
                            <td>随机访问</td>
                            <td class="good">O(1)</td>
                            <td class="bad">O(n)</td>
                        </tr>
                        <tr>
                            <td>头部插入</td>
                            <td class="bad">O(n)</td>
                            <td class="good">O(1)</td>
                        </tr>
                        <tr>
                            <td>尾部插入</td>
                            <td class="good">O(1)</td>
                            <td class="good">O(1)</td>
                        </tr>
                    </table>
                </div>
            </div>
        </section>

        <!-- Slide 5: Set Interface -->
        <section class="slide">
            <div class="slide-content">
                <h2>Set 接口 - 无重复元素集合</h2>
                
                <div class="set-types">
                    <div class="set-type">
                        <h3>HashSet 🔍</h3>
                        <p><strong>特点：</strong>基于哈希表，无序，查找快速</p>
                        <pre><code class="language-java">// HashSet 示例
Set&lt;String&gt; hashSet = new HashSet&lt;&gt;();
hashSet.add("Java");
hashSet.add("Python");
hashSet.add("Java"); // 重复元素，不会添加

System.out.println(hashSet.size()); // 2
System.out.println(hashSet.contains("Java")); // true

// 去重应用
List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 2, 3, 3, 4);
Set&lt;Integer&gt; uniqueNumbers = new HashSet&lt;&gt;(numbers);
System.out.println(uniqueNumbers); // [1, 2, 3, 4]</code></pre>
                    </div>
                    
                    <div class="set-type">
                        <h3>TreeSet 🌳</h3>
                        <p><strong>特点：</strong>基于红黑树，有序，支持范围查询</p>
                        <pre><code class="language-java">// TreeSet 示例
Set&lt;Integer&gt; treeSet = new TreeSet&lt;&gt;();
treeSet.add(5);
treeSet.add(2);
treeSet.add(8);
treeSet.add(1);

System.out.println(treeSet); // [1, 2, 5, 8] 自动排序

// 范围操作
TreeSet&lt;Integer&gt; scores = new TreeSet&lt;&gt;();
scores.addAll(Arrays.asList(85, 92, 78, 96, 88));

System.out.println(scores.headSet(90)); // [78, 85, 88]
System.out.println(scores.tailSet(90)); // [92, 96]</code></pre>
                    </div>
                    
                    <div class="set-type">
                        <h3>LinkedHashSet 🔗</h3>
                        <p><strong>特点：</strong>保持插入顺序的HashSet</p>
                        <pre><code class="language-java">// LinkedHashSet 示例
Set&lt;String&gt; linkedHashSet = new LinkedHashSet&lt;&gt;();
linkedHashSet.add("第一个");
linkedHashSet.add("第二个");
linkedHashSet.add("第三个");

// 保持插入顺序
for (String item : linkedHashSet) {
    System.out.println(item);
}
// 输出：第一个, 第二个, 第三个</code></pre>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 6: Map Interface -->
        <section class="slide">
            <div class="slide-content">
                <h2>Map 接口 - 键值对映射</h2>
                
                <div class="map-types">
                    <div class="map-type">
                        <h3>HashMap 🗺️</h3>
                        <p><strong>特点：</strong>基于哈希表，无序，查找快速</p>
                        <pre><code class="language-java">// HashMap 示例
Map&lt;String, Integer&gt; studentGrades = new HashMap&lt;&gt;();
studentGrades.put("张三", 85);
studentGrades.put("李四", 92);
studentGrades.put("王五", 78);

// 获取值
Integer grade = studentGrades.get("张三"); // 85

// 遍历
for (Map.Entry&lt;String, Integer&gt; entry : studentGrades.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}

// 实用方法
studentGrades.putIfAbsent("赵六", 88); // 如果不存在才添加
studentGrades.computeIfPresent("张三", (k, v) -> v + 5); // 更新值</code></pre>
                    </div>
                    
                    <div class="map-type">
                        <h3>TreeMap 🌲</h3>
                        <p><strong>特点：</strong>基于红黑树，按键排序</p>
                        <pre><code class="language-java">// TreeMap 示例
Map&lt;String, String&gt; dictionary = new TreeMap&lt;&gt;();
dictionary.put("apple", "苹果");
dictionary.put("banana", "香蕉");
dictionary.put("cherry", "樱桃");

// 自动按键排序
System.out.println(dictionary);
// {apple=苹果, banana=香蕉, cherry=樱桃}

// 范围查询
TreeMap&lt;Integer, String&gt; timeline = new TreeMap&lt;&gt;();
timeline.put(2020, "疫情开始");
timeline.put(2021, "疫苗普及");
timeline.put(2022, "经济复苏");

System.out.println(timeline.headMap(2022)); // 2022年之前</code></pre>
                    </div>
                </div>
                
                <div class="map-usage">
                    <h3>常用应用场景</h3>
                    <div class="usage-examples">
                        <div class="usage-item">
                            <h4>📊 统计计数</h4>
                            <pre><code class="language-java">// 统计单词出现次数
Map&lt;String, Integer&gt; wordCount = new HashMap&lt;&gt;();
String[] words = {"java", "python", "java", "c++", "python", "java"};

for (String word : words) {
    wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);
}
System.out.println(wordCount); // {java=3, python=2, c++=1}</code></pre>
                        </div>
                        
                        <div class="usage-item">
                            <h4>🏪 缓存系统</h4>
                            <pre><code class="language-java">// 简单缓存实现
Map&lt;String, Object&gt; cache = new HashMap&lt;&gt;();

public Object getData(String key) {
    if (cache.containsKey(key)) {
        return cache.get(key); // 从缓存获取
    }
    Object data = loadFromDatabase(key); // 从数据库加载
    cache.put(key, data); // 存入缓存
    return data;
}</code></pre>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 7: Queue Interface -->
        <section class="slide">
            <div class="slide-content">
                <h2>Queue 接口 - 队列数据结构</h2>
                
                <div class="queue-types">
                    <div class="queue-type">
                        <h3>ArrayDeque 📦</h3>
                        <p><strong>特点：</strong>双端队列，可在两端操作</p>
                        <pre><code class="language-java">// ArrayDeque 示例
Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();

// 作为栈使用 (LIFO)
deque.push("第一个");
deque.push("第二个");
deque.push("第三个");
System.out.println(deque.pop()); // "第三个"

// 作为队列使用 (FIFO)
Queue&lt;String&gt; queue = new ArrayDeque&lt;&gt;();
queue.offer("任务1");
queue.offer("任务2");
queue.offer("任务3");
System.out.println(queue.poll()); // "任务1"

// 双端操作
deque.addFirst("头部");
deque.addLast("尾部");
System.out.println(deque.removeFirst());
System.out.println(deque.removeLast());</code></pre>
                    </div>
                    
                    <div class="queue-type">
                        <h3>PriorityQueue ⭐</h3>
                        <p><strong>特点：</strong>优先级队列，自动排序</p>
                        <pre><code class="language-java">// PriorityQueue 示例
PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;();
pq.offer(5);
pq.offer(2);
pq.offer(8);
pq.offer(1);

// 按优先级输出（最小值优先）
while (!pq.isEmpty()) {
    System.out.println(pq.poll()); // 1, 2, 5, 8
}

// 自定义优先级（任务调度）
PriorityQueue&lt;Task&gt; taskQueue = new PriorityQueue&lt;&gt;(
    (t1, t2) -> Integer.compare(t1.priority, t2.priority)
);

taskQueue.offer(new Task("低优先级", 3));
taskQueue.offer(new Task("高优先级", 1));
taskQueue.offer(new Task("中优先级", 2));</code></pre>
                    </div>
                </div>
                
                <div class="queue-applications">
                    <h3>实际应用场景</h3>
                    <div class="application-grid">
                        <div class="app-item">
                            <h4>🎯 任务调度</h4>
                            <p>使用PriorityQueue根据优先级处理任务</p>
                        </div>
                        <div class="app-item">
                            <h4>🌐 广度优先搜索</h4>
                            <p>使用ArrayDeque实现BFS算法</p>
                        </div>
                        <div class="app-item">
                            <h4>📝 撤销操作</h4>
                            <p>使用Deque作为栈存储操作历史</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 8: Practical Example -->
        <section class="slide">
            <div class="slide-content">
                <h2>实践案例 - 学生管理系统</h2>
                
                <div class="assignment-requirements">
                    <div class="assignment-header">
                        <h3>📋 作业要求：学生管理系统</h3>
                        <p class="assignment-intro">
                            请使用Java Collections Framework设计并实现一个学生管理系统，要求能够高效地管理学生信息并提供各种查询功能。
                        </p>
                    </div>
                    
                    <div class="requirements-grid">
                        <div class="requirement-section">
                            <h4>🎯 核心功能需求</h4>
                            <ul>
                                <li><strong>学生信息管理</strong>：添加、删除、修改学生基本信息</li>
                                <li><strong>成绩管理</strong>：为学生添加各科目成绩，支持多科目</li>
                                <li><strong>快速查询</strong>：根据学号快速查找学生信息（要求O(1)时间复杂度）</li>
                                <li><strong>排序功能</strong>：按总成绩、平均成绩或单科成绩排序显示</li>
                                <li><strong>统计分析</strong>：统计各科目成绩分布、班级平均分等</li>
                                <li><strong>优秀学生榜</strong>：维护成绩前10名学生列表</li>
                                <li><strong>操作日志</strong>：记录最近100次操作历史</li>
                            </ul>
                        </div>
                        
                        <div class="requirement-section">
                            <h4>🔧 技术要求</h4>
                            <ul>
                                <li><strong>必须使用的集合类型</strong>：
                                    <ul>
                                        <li>HashMap - 用于按学号索引学生</li>
                                        <li>TreeSet - 用于维护排序的优秀学生榜</li>
                                        <li>ArrayList - 用于存储成绩列表</li>
                                        <li>ArrayDeque - 用于操作日志队列</li>
                                    </ul>
                                </li>
                                <li><strong>性能要求</strong>：
                                    <ul>
                                        <li>学生查找：O(1)</li>
                                        <li>添加学生：O(log n)</li>
                                        <li>成绩排序：O(n log n)</li>
                                    </ul>
                                </li>
                                <li><strong>代码规范</strong>：使用泛型、接口编程、异常处理</li>
                            </ul>
                        </div>
                        
                        <div class="requirement-section">
                            <h4>📊 数据结构设计</h4>
                            <ul>
                                <li><strong>Student类</strong>：
                                    <ul>
                                        <li>属性：姓名(String)、学号(String)、成绩(Map&lt;String, Integer&gt;)</li>
                                        <li>方法：添加成绩、计算平均分、获取总分等</li>
                                    </ul>
                                </li>
                                <li><strong>StudentManager类</strong>：
                                    <ul>
                                        <li>学生索引：Map&lt;String, Student&gt;</li>
                                        <li>优秀学生榜：TreeSet&lt;Student&gt;</li>
                                        <li>操作日志：Queue&lt;String&gt;</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                        
                        <div class="requirement-section">
                            <h4>🧪 测试用例</h4>
                            <ul>
                                <li>添加至少10个学生，每人3-5门课程成绩</li>
                                <li>测试按学号查找功能</li>
                                <li>测试各种排序功能</li>
                                <li>验证优秀学生榜自动更新</li>
                                <li>检查操作日志记录</li>
                                <li>测试异常情况处理（重复学号、无效成绩等）</li>
                            </ul>
                        </div>
                        
                        <div class="requirement-section">
                            <h4>💡 实现提示</h4>
                            <ul>
                                <li>使用Comparator接口实现多种排序方式</li>
                                <li>利用Stream API简化统计计算</li>
                                <li>考虑使用Builder模式构建Student对象</li>
                                <li>实现toString()方法便于调试输出</li>
                                <li>添加输入验证和异常处理</li>
                            </ul>
                        </div>
                        
                        <div class="requirement-section">
                            <h4>📝 提交要求</h4>
                            <ul>
                                <li>完整的Java源代码文件</li>
                                <li>包含main方法的测试类</li>
                                <li>代码注释说明关键算法和数据结构选择理由</li>
                                <li>运行截图展示各功能效果</li>
                                <li>简要的设计文档（500字以内）</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="assignment-footer">
                        <p class="highlight-note">
                            <strong>评分重点</strong>：正确使用集合类型(30%)、代码质量和规范(25%)、功能完整性(25%)、性能优化(20%)
                        </p>
                    </div>
                </div>
                    
                    <div class="code-example">
                        <pre><code class="language-java">// 学生类
class Student {
    private String name;
    private String id;
    private Map&lt;String, Integer&gt; grades;
    
    public Student(String name, String id) {
        this.name = name;
        this.id = id;
        this.grades = new HashMap&lt;&gt;();
    }
    
    public void addGrade(String subject, int grade) {
        grades.put(subject, grade);
    }
    
    public double getAverageGrade() {
        return grades.values().stream()
                    .mapToInt(Integer::intValue)
                    .average()
                    .orElse(0.0);
    }
    
    // getters and setters...
}

// 学生管理系统
class StudentManager {
    private Map&lt;String, Student&gt; students;        // 按学号索引
    private Set&lt;Student&gt; topStudents;            // 优秀学生集合
    private Queue&lt;String&gt; recentOperations;      // 最近操作记录
    
    public StudentManager() {
        students = new HashMap&lt;&gt;();
        topStudents = new TreeSet&lt;&gt;((s1, s2) -> 
            Double.compare(s2.getAverageGrade(), s1.getAverageGrade()));
        recentOperations = new ArrayDeque&lt;&gt;();
    }
    
    public void addStudent(Student student) {
        students.put(student.getId(), student);
        updateTopStudents(student);
        logOperation("添加学生: " + student.getName());
    }
    
    public Student findStudent(String id) {
        return students.get(id); // O(1) 查找
    }
    
    public List&lt;Student&gt; getStudentsByGrade() {
        List&lt;Student&gt; result = new ArrayList&lt;&gt;(students.values());
        result.sort((s1, s2) -> 
            Double.compare(s2.getAverageGrade(), s1.getAverageGrade()));
        return result;
    }
    
    public Map&lt;String, List&lt;Integer&gt;&gt; getGradeStatistics() {
        Map&lt;String, List&lt;Integer&gt;&gt; stats = new HashMap&lt;&gt;();
        
        for (Student student : students.values()) {
            for (Map.Entry&lt;String, Integer&gt; entry : student.getGrades().entrySet()) {
                stats.computeIfAbsent(entry.getKey(), k -> new ArrayList&lt;&gt;())
                     .add(entry.getValue());
            }
        }
        
        return stats;
    }
    
    private void updateTopStudents(Student student) {
        topStudents.add(student);
        if (topStudents.size() > 10) {
            topStudents.remove(topStudents.last()); // 保持前10名
        }
    }
    
    private void logOperation(String operation) {
        recentOperations.offer(operation);
        if (recentOperations.size() > 100) {
            recentOperations.poll(); // 保持最近100条记录
        }
    }
}</code></pre>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 9: Performance Comparison -->
        <section class="slide">
            <div class="slide-content">
                <h2>性能对比与选择指南</h2>
                
                <div class="performance-guide">
                    <div class="performance-table-container">
                        <h3>时间复杂度对比</h3>
                        <table class="performance-table">
                            <thead>
                                <tr>
                                    <th>数据结构</th>
                                    <th>查找</th>
                                    <th>插入</th>
                                    <th>删除</th>
                                    <th>空间复杂度</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>ArrayList</td>
                                    <td class="good">O(1)</td>
                                    <td class="average">O(n)</td>
                                    <td class="average">O(n)</td>
                                    <td class="good">O(n)</td>
                                </tr>
                                <tr>
                                    <td>LinkedList</td>
                                    <td class="bad">O(n)</td>
                                    <td class="good">O(1)</td>
                                    <td class="good">O(1)</td>
                                    <td class="average">O(n)</td>
                                </tr>
                                <tr>
                                    <td>HashSet/HashMap</td>
                                    <td class="good">O(1)</td>
                                    <td class="good">O(1)</td>
                                    <td class="good">O(1)</td>
                                    <td class="average">O(n)</td>
                                </tr>
                                <tr>
                                    <td>TreeSet/TreeMap</td>
                                    <td class="average">O(log n)</td>
                                    <td class="average">O(log n)</td>
                                    <td class="average">O(log n)</td>
                                    <td class="good">O(n)</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    
                    <div class="selection-guide">
                        <h3>选择指南</h3>
                        <div class="guide-grid">
                            <div class="guide-item">
                                <h4>🎯 需要快速随机访问</h4>
                                <p><strong>选择：</strong>ArrayList</p>
                                <p><strong>场景：</strong>频繁通过索引访问元素</p>
                            </div>
                            
                            <div class="guide-item">
                                <h4>🔄 频繁插入删除</h4>
                                <p><strong>选择：</strong>LinkedList</p>
                                <p><strong>场景：</strong>队列、栈、频繁修改的列表</p>
                            </div>
                            
                            <div class="guide-item">
                                <h4>🚫 不允许重复</h4>
                                <p><strong>选择：</strong>HashSet</p>
                                <p><strong>场景：</strong>去重、快速查找</p>
                            </div>
                            
                            <div class="guide-item">
                                <h4>📊 需要排序</h4>
                                <p><strong>选择：</strong>TreeSet/TreeMap</p>
                                <p><strong>场景：</strong>有序数据、范围查询</p>
                            </div>
                            
                            <div class="guide-item">
                                <h4>🗝️ 键值对映射</h4>
                                <p><strong>选择：</strong>HashMap</p>
                                <p><strong>场景：</strong>缓存、索引、计数</p>
                            </div>
                            
                            <div class="guide-item">
                                <h4>⭐ 优先级处理</h4>
                                <p><strong>选择：</strong>PriorityQueue</p>
                                <p><strong>场景：</strong>任务调度、算法实现</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 10: Summary -->
        <section class="slide">
            <div class="slide-content">
                <h2>总结与最佳实践</h2>
                
                <div class="summary-content">
                    <div class="key-points">
                        <h3>🎯 核心要点</h3>
                        <ul>
                            <li><strong>选择合适的数据结构</strong>：根据使用场景选择最优的集合类型</li>
                            <li><strong>理解时间复杂度</strong>：不同操作的性能差异很大</li>
                            <li><strong>考虑线程安全</strong>：多线程环境下使用ConcurrentHashMap等</li>
                            <li><strong>合理设置初始容量</strong>：避免频繁扩容影响性能</li>
                        </ul>
                    </div>
                    
                    <div class="best-practices-section">
                        <h3>💡 最佳实践</h3>
                        <div class="best-practices">
                            <div class="practice-item">
                                <h4>1. 接口编程</h4>
                                <pre><code class="language-java">// 好的做法
List&lt;String&gt; list = new ArrayList&lt;&gt;();
Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();

// 避免
ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</code></pre>
                            </div>
                            
                            <div class="practice-item">
                                <h4>2. 泛型使用</h4>
                                <pre><code class="language-java">// 类型安全
List&lt;Student&gt; students = new ArrayList&lt;&gt;();
Map&lt;String, List&lt;Integer&gt;&gt; grades = new HashMap&lt;&gt;();

// 避免原始类型
List students = new ArrayList(); // 不推荐</code></pre>
                            </div>
                            
                            <div class="practice-item">
                                <h4>3. 空值检查</h4>
                                <pre><code class="language-java">// 安全的操作
if (map.containsKey(key)) {
    value = map.get(key);
}

// 或使用
value = map.getOrDefault(key, defaultValue);</code></pre>
                            </div>
                            
                            <div class="practice-item">
                                <h4>4. 合理初始化</h4>
                                <pre><code class="language-java">// 预估大小，减少扩容
List&lt;String&gt; list = new ArrayList&lt;&gt;(1000);
Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(16, 0.75f);

// 使用工厂方法
List&lt;String&gt; immutableList = List.of("a", "b", "c");</code></pre>
                            </div>
                        </div>
                    </div>
                    

                </div>
            </div>
        </section>

        <!-- UI Elements -->
        <div class="progress-bar-container">
            <div id="progress-bar"></div>
        </div>
        <div class="controls">
            <button id="prevBtn">上一页</button>
            <span id="slide-counter">1 / 10</span>
            <button id="nextBtn">下一页</button>
        </div>
    </main>

    <script src="../prism/prism.js"></script>
    <script src="../prism/prism-autoloader.min.js"></script>
    <script src="./js/ppt.js"></script>
    <script src="./js/nav.js"></script>
</body>
</html>