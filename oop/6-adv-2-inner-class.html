<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>面向对象课程导论</title>
    <link rel="stylesheet" href="./css/style.css">
    <link rel="stylesheet" href="./css/hacker-cmd.css">
    <link rel="stylesheet" href="../prism/prism.css">
</head>
<body>

    <main id="presentation">

        <section class="slide title-slide active">
            <h1>内部类</h1>
            <p>面向对象程序设计（Java）</p>
            <strong>掌握内部类的四种形式，理解类的嵌套定义</strong>
        </section>

        <!-- 内部类概述 -->
        <section class="slide">
            <div class="slide-content">
                <h2>内部类概述</h2>
                <p>内部类顾名思义，就是创建在内部的类。</p>
                <p><strong>注意：</strong>内部类很多地方都很绕，所以说一定要仔细思考。</p>
                
                <h3>内部类的四种类型：</h3>
                <ul>
                    <li><strong>成员内部类</strong> - 作为外部类的成员存在</li>
                    <li><strong>静态内部类</strong> - 使用static修饰的内部类</li>
                    <li><strong>局部内部类</strong> - 定义在方法中的类</li>
                    <li><strong>匿名内部类</strong> - 没有名字的内部类</li>
                </ul>
                
                <p>每种内部类都有其特定的使用场景和特点。</p>
            </div>
        </section>

        <!-- 成员内部类 -->
        <section class="slide">
            <div class="slide-content">
                <h2>成员内部类</h2>
                <p>我们可以直接在类的内部定义成员内部类：</p>
                
                <pre><code class="language-java">public class Test {
    public class Inner {   // 内部类也是类，所以说里面也可以有成员变量、方法等
        public void test(){
            System.out.println("我是成员内部类！");
        }
    }
}</code></pre>
                
                <p><strong>特点：</strong></p>
                <ul>
                    <li>成员内部类和成员方法、成员变量一样，是对象所有的</li>
                    <li>可以使用访问权限控制（public、private等）</li>
                    <li>可以访问外部类的所有成员（包括私有成员）</li>
                </ul>
            </div>
        </section>

        <!-- 成员内部类的使用 -->
        <section class="slide">
            <div class="slide-content">
                <h2>成员内部类的使用</h2>
                <p>如果我们要使用成员内部类，需要先创建外部类对象：</p>
                
                <pre><code class="language-java">public static void main(String[] args) {
    Test test = new Test();   // 首先需要创建外部类对象
    Test.Inner inner = test.new Inner();   // 成员内部类的类型名称是 外层.内部类名称
    inner.test();   // 调用内部类方法
}</code></pre>
                
                <p><strong>语法说明：</strong></p>
                <ul>
                    <li>类型声明：<code>外部类.内部类 变量名</code></li>
                    <li>对象创建：<code>外部类对象.new 内部类()</code></li>
                    <li>必须先有外部类对象，才能创建内部类对象</li>
                </ul>
            </div>
        </section>

        <!-- 成员内部类访问外部成员 -->
        <section class="slide">
            <div class="slide-content">
                <h2>成员内部类访问外部成员</h2>
                <p>成员内部类可以访问到外层的变量：</p>
                
                <pre><code class="language-java">public class Test {
    private final String name;
    
    public Test(String name){
        this.name = name;
    }
    
    public class Inner {
        public void test(){
            System.out.println("我是成员内部类：" + name);
            // 成员内部类可以访问到外部的成员变量
            // 因为成员内部类本身就是某个对象所有的
        }
    }
}</code></pre>
                
                <p>每个外部类对象都有一个单独的内部类定义，可以通过这个成员内部类又创建出更多对象。</p>
            </div>
        </section>

        <!-- 成员内部类的this关键字 -->
        <section class="slide">
            <div class="slide-content">
                <h2>成员内部类的this关键字</h2>
                <p>如果内部类中也定义了同名的变量，如何明确要使用的是哪一个？</p>
                
                <pre><code class="language-java">public class Test {
    private final String name;
    
    public Test(String name){
        this.name = name;
    }
    
    public class Inner {
        String name;
        public void test(String name){
            System.out.println("方法参数的name = " + name);    // 就近原则，参数
            System.out.println("成员内部类的name = " + this.name);   // 内部类对象
            System.out.println("外部类的name = " + Test.this.name); 
            // 如果需要指定为外部的对象，需要在前面添加外部类型名称
        }
    }
}</code></pre>
            </div>
        </section>

        <!-- 静态内部类 -->
        <section class="slide">
            <div class="slide-content">
                <h2>静态内部类</h2>
                <p>静态内部类就像静态方法和静态变量一样，是属于类的：</p>
                
                <pre><code class="language-java">public class Test {
    private final String name;
    
    public Test(String name){
        this.name = name;
    }
    
    public static class Inner {
        public void test(){
            System.out.println("我是静态内部类！");
        }
    }
}</code></pre>
                
                <p><strong>特点：</strong></p>
                <ul>
                    <li>不需要依附任何对象，可以直接创建</li>
                    <li>无法访问外部类的非静态内容</li>
                    <li>相对于外部来说，整个内部类中都处于静态上下文</li>
                </ul>
            </div>
        </section>

        <!-- 静态内部类的使用 -->
        <section class="slide">
            <div class="slide-content">
                <h2>静态内部类的使用</h2>
                <p>不需要依附任何对象，可以直接创建静态内部类的对象：</p>
                
                <pre><code class="language-java">public static void main(String[] args) {
    Test.Inner inner = new Test.Inner();   // 静态内部类可以直接new
    inner.test();
}</code></pre>
                
                <p><strong>访问限制：</strong></p>
                <pre><code class="language-java">public static class Inner {
    String name;
    public void test(){
        // System.out.println(Test.this.name);  // 错误！无法访问外部非静态成员
        System.out.println("我是静态内部类：" + name);  // 可以访问自己的成员
    }
}</code></pre>
                
                <p>因为静态内部类不依附任何对象，所以无法访问外部类的非静态属性。</p>
            </div>
        </section>

        <!-- 局部内部类 -->
        <section class="slide">
            <div class="slide-content">
                <h2>局部内部类</h2>
                <p>局部内部类就像局部变量一样，可以在方法中定义：</p>
                
                <pre><code class="language-java">public class Test {
    private final String name;
    
    public Test(String name){
        this.name = name;
    }
    
    public void hello(){
        class Inner {    // 直接在方法中创建局部内部类
            public void test(){
                System.out.println("我是局部内部类");
            }
        }
        
        Inner inner = new Inner();   // 局部内部类直接使用类名就行
        inner.test();
    }
}</code></pre>
                
                <p><strong>特点：</strong>作用范围只能在方法中，使用频率很低。</p>
            </div>
        </section>

        <!-- 匿名内部类概述 -->
        <section class="slide">
            <div class="slide-content">
                <h2>匿名内部类</h2>
                <p>匿名内部类是我们使用频率非常高的一种内部类，它是局部内部类的简化版。</p>
                
                <p>还记得抽象类和接口吗？它们都含有某些抽象方法需要子类去实现。</p>
                <p>我们不能直接通过new的方式去创建一个抽象类或接口对象，但是可以使用匿名内部类。</p>
                
                <pre><code class="language-java">public abstract class Student {
    public abstract void test();
}</code></pre>
                
                <p>正常情况下，要创建抽象类的实例对象，只能对其进行继承，先实现未实现的方法，然后创建子类对象。</p>
            </div>
        </section>

        <!-- 匿名内部类的使用 -->
        <section class="slide">
            <div class="slide-content">
                <h2>匿名内部类的使用</h2>
                <p>我们可以在方法中使用匿名内部类，将其中的抽象方法实现，并直接创建实例对象：</p>
                
                <pre><code class="language-java">public static void main(String[] args) {
    Student student = new Student() {   // 在new的时候，后面加上花括号
        @Override
        public void test() {
            System.out.println("我是匿名内部类的实现!");
        }
    };
    student.test();
}</code></pre>
                
                <p>此时创建出来的Student对象，就是一个已经实现了抽象方法的对象。</p>
                <p>这个抽象类直接就定义好了，甚至连名字都没有，就可以直接创建对象。</p>
            </div>
        </section>

        <!-- 匿名内部类的特点 -->
        <section class="slide">
            <div class="slide-content">
                <h2>匿名内部类的特点</h2>
                <p>匿名内部类中同样可以使用类中的属性（因为它本质上就相当于是对应类型的子类）：</p>
                
                <pre><code class="language-java">Student student = new Student() {
    int a;   // 因为本质上就相当于是子类，所以说子类定义一些属性完全没问题
    
    @Override
    public void test() {
        System.out.println(name + "我是匿名内部类的实现!");   // 直接使用父类中的name变量
    }
};</code></pre>
                
                <p><strong>接口的匿名内部类：</strong></p>
                <pre><code class="language-java">Study study = new Study() {
    @Override
    public void study() {
        System.out.println("我是学习方法！");
    }
};
study.study();</code></pre>
            </div>
        </section>

        <!-- 匿名内部类的其他用法 -->
        <section class="slide">
            <div class="slide-content">
                <h2>匿名内部类的其他用法</h2>
                <p>并不是说只有抽象类和接口才可以创建匿名内部类，普通的类也可以：</p>
                
                <pre><code class="language-java">public class NormalClass {
    public void normalMethod() {
        System.out.println("普通方法");
    }
}

public static void main(String[] args) {
    NormalClass obj = new NormalClass() {
        // 可以添加新的方法或重写现有方法
        @Override
        public void normalMethod() {
            System.out.println("重写的方法");
        }
        
        public void newMethod() {
            System.out.println("新增的方法");
        }
    };
    obj.normalMethod();
}</code></pre>
                
                <p>只不过意义不大，一般情况下只是为了进行一些额外的初始化工作而已。</p>
            </div>
        </section>

        <!-- 总结 -->
        <section class="slide">
            <div class="slide-content">
                <h2>内部类总结</h2>
                
                <table style="width: 100%; border-collapse: collapse; margin-top: 20px;">
                    <thead>
                        <tr style="background-color: #f0f0f0;">
                            <th style="border: 1px solid #ddd; padding: 8px;">内部类类型</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">定义位置</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">创建方式</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">访问外部成员</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 8px;">成员内部类</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">类的成员位置</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">外部对象.new 内部类()</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">可以访问所有</td>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 8px;">静态内部类</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">类的成员位置</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">new 外部类.内部类()</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">只能访问静态成员</td>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 8px;">局部内部类</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">方法内部</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">new 内部类()</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">可以访问所有</td>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 8px;">匿名内部类</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">方法内部</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">new 父类/接口(){}</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">可以访问所有</td>
                        </tr>
                    </tbody>
                </table>
                
                <p style="margin-top: 20px;"><strong>使用建议：</strong></p>
                <ul>
                    <li>匿名内部类使用最频繁，特别是在事件处理和回调中</li>
                    <li>静态内部类适合工具类的场景</li>
                    <li>成员内部类和局部内部类使用相对较少</li>
                </ul>
            </div>
        </section>

    </main>

        <!-- UI Elements -->
        <div class="progress-bar-container">
            <div id="progress-bar"></div>
        </div>
        <div class="controls">
            <button id="prevBtn">上一页</button>
            <span id="slide-counter">1 / X</span>
            <button id="nextBtn">下一页</button>
        </div>
    </main>

    <script src="../prism/prism.js"></script>
    <script src="../prism/prism-autoloader.min.js"></script>
    <script src="./js/ppt.js"></script>
    <script src="./js/nav.js"></script>

</body>
</html>