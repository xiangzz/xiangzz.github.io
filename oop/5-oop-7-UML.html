<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UML类图详解</title>
    <link rel="stylesheet" href="./css/style.css">
    <link rel="stylesheet" href="../prism/prism.css">
</head>

<body>

    <main id="presentation">
        <section class="slide title-slide active">
            <h1>UML 类图</h1>
            <p>面向对象程序设计（Java）</p>
            <strong>掌握类图元素与关系，规范表达面向对象设计</strong>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>1.1 UML基础概念与类图定位</h2>
                <p><strong>UML（Unified Modeling Language，统一建模语言）</strong>是一种标准化的图形建模语言，用于可视化、描述、构建和文档化软件系统的产物。</p>

                <h3>UML的定义与用途</h3>
                <ul>
                    <li><strong>定义</strong>：一种通用的、标准化的建模工具，不是编程语言</li>
                    <li><strong>可视化</strong>：通过图形方式直观展示系统结构和行为</li>
                    <li><strong>规范化</strong>：提供标准化的表达方式，减少沟通歧义</li>
                    <li><strong>文档化</strong>：为系统设计提供完整、准确的文档记录</li>
                </ul>

                <h3>UML发展历史</h3>
                <ul>
                    <li><strong>1995年</strong>：Booch、Rumbaugh和Jacobson三位方法学家开始统一方法</li>
                    <li><strong>1997年</strong>：UML 1.0被对象管理组织(OMG)采纳为标准</li>
                    <li><strong>2005年</strong>：UML 2.0发布，引入更丰富的建模能力</li>
                    <li><strong>2015年</strong>：UML 2.5发布，目前最新的稳定版本</li>
                </ul>

                <h3>类图在UML中的定位</h3>
                <p>类图是UML中的<strong>静态结构图</strong>，用于描述系统中类的静态结构以及它们之间的各种关系。与描述系统行为的动态图（如序列图、活动图）不同，类图关注的是系统的"快照"，展示系统在某一时刻的结构组成。
                </p>
                <h3>最小可用类图示例</h3>
                <pre><code id="case1-code" class="language-text">@startuml
class Student {
  - id : int
  + name : String
  + getName() : String
  + setName(n : String) : void
}
@enduml</code></pre>
                <div style="display:flex; gap:12px; align-items:center; margin:10px 0;">
                    <button class="copy-btn" data-code-id="case1-code" aria-label="复制示例代码">复制示例代码</button>
                    <span style="color:#6B7280;">渲染结果（SVG）</span>
                </div>
                <div>
                    <img id="case1-render" class="puml-render" data-source-id="case1-code" data-format="svg"
                        alt="UML渲染">
                </div>
                <p class="conclusion">类图用于静态结构表达；属性与方法区分清晰，采用可见性标记描述访问约束。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>2.1 类图核心要素：类、关系与接口</h2>
                <p>类图由三大核心要素构成：<strong>类（Class）</strong>、<strong>关系（Relationship）</strong>和<strong>接口（Interface）</strong>。这些要素共同描述了系统的静态结构。
                </p>

                <h3>1. 类（Class）的表示方法</h3>
                <p>类是类图的核心元素，由三部分组成：</p>
                <ul>
                    <li><strong>名称栏</strong>：类的名称</li>
                    <li><strong>属性栏</strong>：类的属性/字段</li>
                    <li><strong>方法栏</strong>：类的操作/方法</li>
                </ul>

                <h3>2. 类之间的关系</h3>
                <p>类之间可以通过多种关系相互连接，每种关系有不同的语义：</p>
                <ul>
                    <li><strong>关联(Association)</strong>：类之间的结构关系</li>
                    <li><strong>聚合(Aggregation)</strong>：整体与部分的关系，部分可独立存在</li>
                    <li><strong>组合(Composition)</strong>：强聚合，部分不能独立存在</li>
                    <li><strong>继承(Inheritance)</strong>：一般与特殊的关系</li>
                    <li><strong>实现(Realization)</strong>：接口与实现类的关系</li>
                    <li><strong>依赖(Dependency)</strong>：一个类使用另一个类</li>
                </ul>

                <h3>3. 接口（Interface）的表示方式</h3>
                <p>接口是一种特殊的类，它定义了一组操作规范但没有实现，用于表达行为约定和抽象概念。</p>

                <p class="conclusion">类是类图的核心元素，关系连接类形成结构，接口定义行为规范。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>2.2 类成员可见性与抽象设计</h2>
                <p>深入理解类成员的可见性、抽象类与接口的使用。</p>

                <h3>类成员与可见性</h3>
                <p>可见性符号用于控制类成员的访问级别：</p>
                <ul>
                    <li><code>+</code>：公有(public) - 所有类可访问</li>
                    <li><code>-</code>：私有(private) - 仅本类可访问</li>
                    <li><code>#</code>：受保护(protected) - 本类、子类及同包类可访问</li>
                    <li><code>~</code>：包级私有(package private) - 同包类可访问</li>
                </ul>

                <h3>类成员示例</h3>
                <pre><code id="case2-code" class="language-text">@startuml
class Account {
  - id : long
  + owner : String
  # balance : BigDecimal
  + deposit(amount : BigDecimal) : void
  + withdraw(amount : BigDecimal) : boolean
}
@enduml</code></pre>
                <div style="display:flex; gap:12px; align-items:center; margin:10px 0;">
                    <button class="copy-btn" data-code-id="case2-code" aria-label="复制示例代码">复制示例代码</button>
                    <span style="color:#6B7280;">渲染结果（SVG）</span>
                </div>
                <img id="case2-render" class="puml-render" data-source-id="case2-code" data-format="svg" alt="UML渲染">

                <h3>抽象类与接口</h3>
                <pre><code id="case2b-code" class="language-text">@startuml
interface AuthService {
  + login(u : String, p : String) : boolean
}
abstract class Person {
  + id : int
  + getId() : int
}
class Student extends Person {
  + name : String
}
Student ..|&gt; AuthService
@enduml</code></pre>
                <div style="display:flex; gap:12px; align-items:center; margin:10px 0;">
                    <button class="copy-btn" data-code-id="case2b-code" aria-label="复制示例代码">复制示例代码</button>
                    <span style="color:#6B7280;">渲染结果（SVG）</span>
                </div>
                <img id="case2b-render" class="puml-render" data-source-id="case2b-code" data-format="svg" alt="UML渲染">
                <p class="conclusion">接口用于行为约定；抽象类表达抽象通用性；实现关系以空心三角+虚线表示。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>3.1 类元素语法：属性与方法</h2>
                <p>掌握类图元素的完整语法格式，能够更精确地表达设计意图。</p>

                <h3>属性的完整语法</h3>
                <p><code>可见性 名称 : 类型 [多重性] = 初始值 {属性特性}</code></p>
                <ul>
                    <li><strong>可见性</strong>：+、-、#、~</li>
                    <li><strong>多重性</strong>：[1]、[0..1]、[0..*]、[1..*]</li>
                    <li><strong>属性特性</strong>：{readOnly}、{derived}、{static}</li>
                </ul>

                <h3>方法的完整语法</h3>
                <p><code>可见性 名称 (参数列表) : 返回类型 {方法特性}</code></p>
                <ul>
                    <li><strong>参数列表</strong>：参数名 : 类型 [默认值]</li>
                    <li><strong>方法特性</strong>：{query}、{static}、{abstract}</li>
                </ul>

                <h3>属性与方法示例</h3>
                <pre><code id="attr-method-code" class="language-text">@startuml
class Product {
  - id : long [1]
  - name : String [1]
  - price : double [1] = 0.0
  - description : String [0..1]
  + {static} TAX_RATE : double = 0.08
  + {query} calculateTax() : double
  + {static} fromJson(json : String) : Product
  + {abstract} validate() : boolean
}
@enduml</code></pre>
                <div style="display:flex; gap:12px; align-items:center; margin:10px 0;">
                    <button class="copy-btn" data-code-id="attr-method-code" aria-label="复制示例代码">复制示例代码</button>
                    <span style="color:#6B7280;">渲染结果（SVG）</span>
                </div>
                <img id="attr-method-render" class="puml-render" data-source-id="attr-method-code" data-format="svg"
                    alt="UML渲染">
                <p class="conclusion">属性和方法的完整语法提供了精确表达设计意图的能力，多重性和特性标记是关键要素。</p>
            </div>
        </section>



        <section class="slide">
            <div class="slide-content">
                <h2>4.1 强关系（结构性关系）</h2>
                <p>强关系表示类之间紧密的结构性依赖，修改一方会直接影响另一方。按照依赖强度从强到弱依次为：继承、实现、组合。</p>

                <h3>继承关系 - 最强</h3>
                <p><strong>定义</strong>：表示"is-a"关系，子类完全依赖父类。</p>
                <p><strong>特点</strong>：修改父类会直接影响子类，子类继承父类的所有属性和方法。</p>
                <p><strong>表示方法</strong>：实线空心三角箭头，箭头指向父类。</p>

                <h3>实现关系 - 最强</h3>
                <p><strong>定义</strong>：表示类完全依赖接口定义。</p>
                <p><strong>特点</strong>：必须实现所有接口方法，接口变更会影响实现类。</p>
                <p><strong>表示方法</strong>：虚线空心三角箭头，箭头指向接口。</p>

                <h3>组合关系 - 很强</h3>
                <p><strong>定义</strong>：表示整体与部分的关系，部分不能独立于整体存在。</p>
                <p><strong>特点</strong>：生命周期强绑定，整体销毁时部分也随之销毁（如：汽车-引擎）。</p>
                <p><strong>表示方法</strong>：实心菱形端点的实线，菱形端点连接整体类。</p>

                <pre><code id="case3-code" class="language-text">@startuml
class Animal
class Dog extends Animal
interface Runnable
Dog ..|&gt; Runnable
class Car
class Engine
Car *-- Engine
@enduml</code></pre>
                <div style="display:flex; gap:12px; align-items:center; margin:10px 0;">
                    <button class="copy-btn" data-code-id="case3-code">复制示例代码</button>
                    <span style="color:#6B7280;">渲染结果（SVG）</span>
                </div>
                <img id="case3-render" class="puml-render" data-source-id="case3-code" data-format="svg" alt="UML渲染">

                <p class="conclusion">强关系体现了类之间的结构性依赖，设计时需要谨慎考虑，因为修改会带来连锁影响。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>4.2 弱关系（行为性关系）</h2>
                <p>弱关系表示类之间较为松散的连接，修改一方对另一方的影响较小。按照依赖强度从强到弱依次为：聚合、关联、依赖。</p>

                <h3>聚合关系 - 中等强度</h3>
                <p><strong>定义</strong>：表示整体与部分的关系，部分可以独立于整体存在。</p>
                <p><strong>特点</strong>："has-a"关系，生命周期独立（如：部门-员工）。</p>
                <p><strong>表示方法</strong>：空心菱形端点的实线，菱形端点连接整体类。</p>

                <h3>关联关系 - 较弱</h3>
                <p><strong>定义</strong>：表示对象间的独立存在，只是相互引用。</p>
                <p><strong>特点</strong>：通常是长期关系，对象可以独立存在（如：学生-课程）。</p>
                <p><strong>表示方法</strong>：实线连接，可带箭头表示导航方向。</p>

                <h3>依赖关系 - 最弱</h3>
                <p><strong>定义</strong>：表示临时性的使用关系。</p>
                <p><strong>特点</strong>：通常是方法参数、局部变量（如：方法调用时依赖某个类）。</p>
                <p><strong>表示方法</strong>：虚线箭头，箭头指向被依赖的类。</p>

                <pre><code id="case3b-code" class="language-text">@startuml
class Department
class Employee
class Student
class Course
class OrderService
class EmailService
Department o-- "1..*" Employee
Student "0..*" -- "0..*" Course
OrderService ..&gt; EmailService
@enduml</code></pre>
                <div style="display:flex; gap:12px; align-items:center; margin:10px 0;">
                    <button class="copy-btn" data-code-id="case3b-code">复制示例代码</button>
                    <span style="color:#6B7280;">渲染结果（SVG）</span>
                </div>
                <img id="case3b-render" class="puml-render" data-source-id="case3b-code" data-format="svg" alt="UML渲染">

                <p class="conclusion">弱关系体现了类之间的行为性连接，设计时优先选择较弱的关系，以提高系统的灵活性和可维护性。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>4.3 关联关系详解</h2>
                <p>关联关系是UML类图中最基本的关系类型，表示类之间的结构化连接。</p>

                <h3>关联关系（Association）</h3>
                <p><strong>定义</strong>：表示类之间的结构化连接，描述对象之间的链接关系。</p>
                <p><strong>特点</strong>：是一种"has-a"关系，表示一个对象知道另一个对象的存在。</p>
                <p><strong>表示方法</strong>：实线连接，可带箭头表示导航方向，可标注多重性。</p>

                <h3>关联关系的类型</h3>
                <p><strong>双向关联</strong>：两个类互相知道对方的存在，用无箭头的实线表示。</p>
                <p><strong>单向关联</strong>：只有一个类知道另一个类的存在，用带箭头的实线表示。</p>
                <p><strong>自关联</strong>：类与自身关联，表示类内部对象之间的关系。</p>

                <h3>多重性表示</h3>
                <p><strong>1</strong>：恰好一个</p>
                <p><strong>0..1</strong>：零个或一个</p>
                <p><strong>*</strong> 或 <strong>0..*</strong>：零个或多个</p>
                <p><strong>1..*</strong>：一个或多个</p>
                <p><strong>n</strong>：固定数量</p>
                <p><strong>m..n</strong>：范围数量</p>

                <pre><code id="assoc-code" class="language-text">@startuml
class Teacher
class Student
class Course

' 双向关联
Teacher "1" -- "0..*" Student : teaches >

' 单向关联
Teacher --> Course : teaches >

@enduml</code></pre>
                <div style="display:flex; gap:12px; align-items:center; margin:10px 0;">
                    <button class="copy-btn" data-code-id="assoc-code" aria-label="复制示例代码">复制示例代码</button>
                    <span style="color:#6B7280;">渲染结果（SVG）</span>
                </div>
                <img id="assoc-render" class="puml-render" data-source-id="assoc-code" data-format="svg" alt="UML渲染">

                <p class="conclusion">关联关系是类图中最常用的关系，正确使用多重性可以精确表达类之间的数量约束。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>4.4 聚合关系详解</h2>
                <p>聚合关系是关联关系的特殊形式，表示整体与部分的关系，但部分可以独立存在。</p>

                <h3>聚合关系（Aggregation）</h3>
                <p><strong>定义</strong>：表示"has-a"关系的特殊形式，表示整体与部分的关系，但部分可以独立存在。</p>
                <p><strong>特点</strong>：部分对象的生命周期不依赖于整体对象，可以独立存在。</p>
                <p><strong>表示方法</strong>：空心菱形端点的实线，菱形端点连接整体类。</p>

                <h3>聚合关系的特征</h3>
                <p><strong>生命周期独立</strong>：部分对象可以在整体对象创建之前存在，也可以在整体对象销毁后继续存在。</p>
                <p><strong>共享性</strong>：一个部分对象可以同时属于多个整体对象。</p>
                <p><strong>弱耦合</strong>：整体和部分之间的关系相对松散。</p>

                <h3>聚合关系的应用场景</h3>
                <p><strong>部门与员工</strong>：部门包含员工，但员工可以独立存在，也可以属于多个部门。</p>
                <p><strong>汽车与轮胎</strong>：汽车有轮胎，但轮胎可以独立存在，也可以安装到其他汽车上。</p>
                <p><strong>团队与成员</strong>：团队由成员组成，但成员可以离开团队，也可以加入其他团队。</p>

                <pre><code id="aggr-code" class="language-text">@startuml
class Department {
  - name : String
}
class Employee {
  - id : int
  - name : String
}

' 聚合关系：部门包含员工，但员工可以独立存在
Department o-- Employee : contains >

@enduml</code></pre>
                <div style="display:flex; gap:12px; align-items:center; margin:10px 0;">
                    <button class="copy-btn" data-code-id="aggr-code" aria-label="复制示例代码">复制示例代码</button>
                    <span style="color:#6B7280;">渲染结果（SVG）</span>
                </div>
                <img id="aggr-render" class="puml-render" data-source-id="aggr-code" data-format="svg" alt="UML渲染">

                <p class="conclusion">聚合关系强调了整体与部分的关系，但部分可以独立存在，这是与组合关系的主要区别。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>4.5 组合关系详解</h2>
                <p>组合关系是聚合关系的特殊形式，表示更强的整体与部分关系，部分不能独立存在。</p>

                <h3>组合关系（Composition）</h3>
                <p><strong>定义</strong>：表示更强的"has-a"关系，部分对象的生命周期依赖于整体对象。</p>
                <p><strong>特点</strong>：部分对象不能独立存在，整体对象销毁时，部分对象也随之销毁。</p>
                <p><strong>表示方法</strong>：实心菱形端点的实线，菱形端点连接整体类。</p>

                <h3>组合关系的特征</h3>
                <p><strong>生命周期依赖</strong>：部分对象的生命周期完全依赖于整体对象。</p>
                <p><strong>独占性</strong>：一个部分对象在同一时间只能属于一个整体对象。</p>
                <p><strong>强耦合</strong>：整体和部分之间的关系非常紧密。</p>

                <h3>组合关系的应用场景</h3>
                <p><strong>房子与房间</strong>：房子包含房间，房间不能独立存在，房子销毁时房间也随之销毁。</p>
                <p><strong>公司与部门</strong>：公司由部门组成，部门不能独立于公司存在。</p>
                <p><strong>文档与章节</strong>：文档由章节组成，章节不能独立于文档存在。</p>

                <h3>组合与聚合的区别</h3>
                <p><strong>生命周期</strong>：组合中部分依赖整体，聚合中部分独立于整体。</p>
                <p><strong>共享性</strong>：组合中部分不能共享，聚合中部分可以共享。</p>
                <p><strong>表示方法</strong>：组合用实心菱形，聚合用空心菱形。</p>

                <pre><code id="comp-code" class="language-text">@startuml
class House {
  - address : String
}
class Room {
  - area : double
  - type : String
}
class Door {
  - material : String
}

' 组合关系：房子包含房间和门，房间和门不能独立存在
House *-- Room : contains >
House *-- Door : has >

@enduml</code></pre>
                <div style="display:flex; gap:12px; align-items:center; margin:10px 0;">
                    <button class="copy-btn" data-code-id="comp-code" aria-label="复制示例代码">复制示例代码</button>
                    <span style="color:#6B7280;">渲染结果（SVG）</span>
                </div>
                <img id="comp-render" class="puml-render" data-source-id="comp-code" data-format="svg" alt="UML渲染">

                <p class="conclusion">组合关系是最强的结构关系，表示部分的生命周期完全依赖于整体，体现了"部分不能脱离整体而存在"的语义。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>4.6 依赖关系详解</h2>
                <p>依赖关系是UML类图中最弱的关系，表示一个类使用另一个类的临时性关系。</p>

                <h3>依赖关系（Dependency）</h3>
                <p><strong>定义</strong>：表示一个类使用另一个类，通常是一种临时性的、较弱的关系。</p>
                <p><strong>特点</strong>：通常表现为一个类的方法使用另一个类作为参数、返回值或局部变量。</p>
                <p><strong>表示方法</strong>：虚线箭头，箭头指向被依赖的类。</p>

                <h3>依赖关系的表现形式</h3>
                <p><strong>参数依赖</strong>：一个类的方法使用另一个类作为参数。</p>
                <p><strong>返回值依赖</strong>：一个类的方法返回另一个类的对象。</p>
                <p><strong>局部变量依赖</strong>：一个类的方法中定义了另一个类的局部变量。</p>
                <p><strong>静态方法调用</strong>：一个类调用另一个类的静态方法。</p>

                <h3>依赖关系的应用场景</h3>
                <p><strong>服务调用</strong>：业务类调用服务类的方法。</p>
                <p><strong>工具类使用</strong>：业务类使用工具类进行辅助操作。</p>
                <p><strong>工厂模式</strong>：客户端类依赖工厂类创建对象。</p>

                <h3>依赖关系与其他关系的区别</h3>
                <p><strong>临时性</strong>：依赖关系通常是临时的，而关联、聚合、组合是长期的结构关系。</p>
                <p><strong>弱耦合</strong>：依赖关系表示较弱的耦合，而其他关系表示较强的耦合。</p>
                <p><strong>使用方式</strong>：依赖关系表示"使用"关系，其他关系表示"拥有"关系。</p>

                <pre><code id="dep-code" class="language-text">@startuml
class OrderProcessor {
  + processOrder(order : Order) : void
}
class Order {
  - items : List&lt;OrderItem&gt;
}
class EmailService {
  + sendEmail(to : String, content : String) : void
}

' 依赖关系：订单处理器依赖于订单和邮件服务
OrderProcessor ..> Order : uses >
OrderProcessor ..> EmailService : uses >

@enduml</code></pre>
                <div style="display:flex; gap:12px; align-items:center; margin:10px 0;">
                    <button class="copy-btn" data-code-id="dep-code" aria-label="复制示例代码">复制示例代码</button>
                    <span style="color:#6B7280;">渲染结果（SVG）</span>
                </div>
                <img id="dep-render" class="puml-render" data-source-id="dep-code" data-format="svg" alt="UML渲染">

                <p class="conclusion">依赖关系是最弱的关系，表示临时性的使用关系，合理使用依赖关系可以降低系统的耦合度。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>4.7 继承关系详解</h2>

                <h3>5. 继承关系（Inheritance/Generalization）</h3>
                <p><strong>定义</strong>：表示"is-a"关系，子类继承父类的属性和方法。</p>
                <p><strong>特点</strong>：子类是父类的特化，具有父类的所有特性，并可以添加新的特性。</p>
                <p><strong>表示方法</strong>：实线空心三角箭头，箭头指向父类。</p>

                <h3>继承关系的核心特性</h3>
                <ul>
                    <li><strong>传递性</strong>：如果B继承A，C继承B，则C间接继承A</li>
                    <li><strong>单根性</strong>：Java中类只能单继承，但可以多实现接口</li>
                    <li><strong>访问控制</strong>：子类可以访问父类的protected和public成员</li>
                    <li><strong>多态性</strong>：子类对象可以当作父类对象使用</li>
                </ul>

                <pre><code id="inherit-code" class="language-text">@startuml
class Vehicle {
  # speed : double
  + start() : void
  + stop() : void
}
class Car extends Vehicle {
  - doors : int
  + openTrunk() : void
}
class Motorcycle extends Vehicle {
  - type : String
  + doWheelie() : void
}

' 继承关系：汽车和摩托车继承自车辆
Car --|> Vehicle
Motorcycle --|> Vehicle

@enduml</code></pre>
                <div style="display:flex; gap:12px; align-items:center; margin:10px 0;">
                    <button class="copy-btn" data-code-id="inherit-code" aria-label="复制示例代码">复制示例代码</button>
                    <span style="color:#6B7280;">渲染结果（SVG）</span>
                </div>
                <img id="inherit-render" class="puml-render" data-source-id="inherit-code" data-format="svg"
                    alt="UML渲染">

                <p class="conclusion">继承是面向对象编程的核心机制，通过继承可以实现代码复用和建立清晰的类层次结构。设计时应遵循"里氏替换原则"，确保子类可以替换父类而不影响程序正确性。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>4.8 实现关系详解</h2>

                <h3>实现关系（Realization/Implementation）</h3>
                <p><strong>定义</strong>：表示类实现接口，接口定义了一组操作，类提供这些操作的具体实现。</p>
                <p><strong>特点</strong>：类必须实现接口中定义的所有方法，是一种契约关系。</p>
                <p><strong>表示方法</strong>：虚线空心三角箭头，箭头指向接口。</p>

                <h3>实现关系的核心特性</h3>
                <ul>
                    <li><strong>多实现性</strong>：一个类可以实现多个接口，弥补单继承的不足</li>
                    <li><strong>契约性</strong>：接口定义了行为契约，实现类必须遵守</li>
                    <li><strong>抽象性</strong>：接口只定义行为规范，不包含实现细节</li>
                    <li><strong>多态性</strong>：通过接口引用可以调用不同实现类的方法</li>
                </ul>

                <pre><code id="impl-code" class="language-text">@startuml
interface Drawable {
  + draw() : void
  + resize(scale : double) : void
}
interface Movable {
  + move(dx : double, dy : double) : void
}
class Shape {
  - x : double
  - y : double
}
class Circle extends Shape implements Drawable, Movable {
  - radius : double
  + draw() : void
  + resize(scale : double) : void
  + move(dx : double, dy : double) : void
}

' 实现关系：圆形实现了可绘制和可移动接口
Circle ..|> Drawable
Circle ..|> Movable

@enduml</code></pre>
                <div style="display:flex; gap:12px; align-items:center; margin:10px 0;">
                    <button class="copy-btn" data-code-id="impl-code" aria-label="复制示例代码">复制示例代码</button>
                    <span style="color:#6B7280;">渲染结果（SVG）</span>
                </div>
                <img id="impl-render" class="puml-render" data-source-id="impl-code" data-format="svg" alt="UML渲染">

                <h3>继承与实现关系对比</h3>
                <table style="width:100%; border-collapse:collapse; margin:10px 0;">
                    <tr style="background-color:var(--accent-bg);">
                        <th style="border:1px solid var(--border-color); padding:8px;">对比项</th>
                        <th style="border:1px solid var(--border-color); padding:8px;">继承关系</th>
                        <th style="border:1px solid var(--border-color); padding:8px;">实现关系</th>
                    </tr>
                    <tr>
                        <td style="border:1px solid var(--border-color); padding:8px;">语义</td>
                        <td style="border:1px solid var(--border-color); padding:8px;">is-a关系</td>
                        <td style="border:1px solid var(--border-color); padding:8px;">can-do关系</td>
                    </tr>
                    <tr>
                        <td style="border:1px solid var(--border-color); padding:8px;">数量限制</td>
                        <td style="border:1px solid var(--border-color); padding:8px;">单继承</td>
                        <td style="border:1px solid var(--border-color); padding:8px;">多实现</td>
                    </tr>
                    <tr>
                        <td style="border:1px solid var(--border-color); padding:8px;">内容</td>
                        <td style="border:1px solid var(--border-color); padding:8px;">属性+方法</td>
                        <td style="border:1px solid var(--border-color); padding:8px;">抽象方法</td>
                    </tr>
                    <tr>
                        <td style="border:1px solid var(--border-color); padding:8px;">表示方法</td>
                        <td style="border:1px solid var(--border-color); padding:8px;">实线空心三角</td>
                        <td style="border:1px solid var(--border-color); padding:8px;">虚线空心三角</td>
                    </tr>
                </table>

                <p class="conclusion">实现关系提供了灵活的多态机制，通过接口可以定义系统的行为规范，降低类之间的耦合度。设计时应优先使用接口而非具体类，遵循"面向接口编程"的原则。</p>
            </div>
        </section>


        <section class="slide">
            <div class="slide-content">
                <h2>3.2 关系语法与多重性表示</h2>
                <p>掌握类之间关系的语法表示，准确表达类之间的连接方式。</p>

                <h3>关系语法示例</h3>
                <pre><code id="syntax-code" class="language-text">@startuml
' 接口
interface Payable {
    +getSalary(): double
}

' 抽象类
abstract class Person {
    -name: String
    -age: int
    +getName(): String
}

' 具体类
class Employee {
    -employeeId: String
    +getSalary(): double
}

class Department {
    -deptName: String
    +addEmployee(emp: Employee): void
}

class Project {
    -projectName: String
    +startProject(): void
}

class Task {
    -taskName: String
    +complete(): void
}

' 工具类
class Calculator {
    +calculateBonus(salary: double): double
}

' 继承关系
Employee --|> Person

' 实现关系
Employee ..|> Payable

' 关联关系
Employee "1" -- "*" Project : works on >

' 聚合关系
Department "1" o-- "*" Employee : contains >

' 组合关系  
Project "1" *-- "1..*" Task : consists of >

' 依赖关系
Employee ..> Calculator : uses >

@enduml</code></pre>
                <div style="display:flex; gap:12px; align-items:center; margin:10px 0;">
                    <button class="copy-btn" data-code-id="syntax-code" aria-label="复制示例代码">复制示例代码</button>
                    <span style="color:#6B7280;">渲染结果（SVG）</span>
                </div>
                <img id="syntax-render" class="puml-render" data-source-id="syntax-code" data-format="svg" alt="UML渲染">
                <p class="conclusion">掌握完整语法有助于精确表达设计意图，多重性和关系类型是关键要素。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>5.1 类图绘制规范与最佳实践</h2>
                <p>保持命名统一、关系方向合理、标注多重性与可见性、适度分组。关注可读性与一致性。</p>
                <h3>规范示例</h3>
                <pre><code id="case4-code" class="language-text">@startuml
package app {
  class Controller
  class Service
  class Repository
}
Controller --&gt; Service
Service --&gt; Repository
class Utils {
  {static} version : String
  {static} now() : Date
}
@enduml</code></pre>
                <div style="display:flex; gap:12px; align-items:center; margin:10px 0;">
                    <button class="copy-btn" data-code-id="case4-code">复制示例代码</button>
                    <span style="color:#6B7280;">渲染结果（SVG）</span>
                </div>
                <img id="case4-render" class="puml-render" data-source-id="case4-code" data-format="svg" alt="UML渲染">
                <p class="conclusion">采用包分组、明确依赖方向、区分静态成员，保证图面简洁与表达准确。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>5.2 实战案例：电商系统订单模块设计</h2>
                <p>通过一个完整的电商系统订单模块，展示类图在实际项目中的应用。</p>

                <h3>需求分析</h3>
                <ul>
                    <li>客户可以下订单，一个订单包含多个订单项</li>
                    <li>每个订单项对应一个商品，包含数量和单价</li>
                    <li>订单需要支付，支持多种支付方式</li>
                    <li>系统需要记录订单状态和操作日志</li>
                </ul>

                <h3>类图设计</h3>
                <pre><code id="ecommerce-code" class="language-text">@startuml
package 电商系统 {
  class Customer {
    - id : long
    - name : String
    - email : String
    + register() : boolean
    + login(password : String) : boolean
    + placeOrder(items : List<OrderItem>) : Order
  }
  
  class Order {
    - orderNumber : String
    - orderDate : Date
    - totalAmount : BigDecimal
    + calculateTotal() : BigDecimal
    + addItem(item : OrderItem) : void
    + removeItem(item : OrderItem) : void
  }
  
  class OrderItem {
    - quantity : int
    - unitPrice : BigDecimal
    + getSubtotal() : BigDecimal
  }
  
  class Product {
    - id : long
    - name : String
    - price : BigDecimal
    - stock : int
    + updateStock(quantity : int) : void
    + isAvailable() : boolean
  }
  
  class PaymentResult {
    - success : boolean
    - transactionId : String
    - message : String
  }
  
  interface PaymentService {
    + processPayment(amount : BigDecimal) : PaymentResult
  }
  
  class CreditCardPayment implements PaymentService {
    + processPayment(amount : BigDecimal) : PaymentResult
  }
}

Customer "1" -- "0..*" Order : places >
Order "1" *-- "1..*" OrderItem : contains >
OrderItem "1" -- "1" Product : refers to >
Order ..|> PaymentService : uses >
@enduml</code></pre>
                <div style="display:flex; gap:12px; align-items:center; margin:10px 0;">
                    <button class="copy-btn" data-code-id="ecommerce-code" aria-label="复制示例代码">复制示例代码</button>
                    <span style="color:#6B7280;">渲染结果（SVG）</span>
                </div>
                <img id="ecommerce-render" class="puml-render" data-source-id="ecommerce-code" data-format="svg"
                    alt="UML渲染">

                <h3>设计解析</h3>
                <ul>
                    <li><strong>Customer与Order</strong>：一对多关联关系，一个客户可以有多个订单</li>
                    <li><strong>Order与OrderItem</strong>：组合关系，订单由多个订单项组成，订单项不能独立存在</li>
                    <li><strong>OrderItem与Product</strong>：关联关系，订单项引用一个商品</li>
                    <li><strong>Order与PaymentService</strong>：依赖关系，订单处理时需要使用支付服务</li>
                </ul>
                <p class="conclusion">从需求分析到类图设计，识别核心类、定义属性方法、建立关系是关键步骤。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>6.1 交互实践：PlantUML编辑器</h2>
                <p>在下方编辑区修改PlantUML代码，点击运行或直接输入实时预览；可选择导出为SVG或PNG。</p>
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:20px; align-items:start;">
                    <div>
                        <textarea id="puml-editor"
                            style="width:100%; height:320px; font-family: 'Roboto Mono', monospace; font-size:14px;">@startuml
class User {
  - id : int
  + name : String
  + getName() : String
}
class Role {
  + code : String
}
User "1" --&gt; "0..*" Role
@enduml</textarea>
                        <div style="display:flex; gap:10px; margin-top:10px;">
                            <button id="runPumlBtn">运行</button>
                            <button id="copyPumlBtn">复制</button>
                            <select id="puml-format" aria-label="渲染格式选择">
                                <option value="svg" selected>SVG</option>
                                <option value="png">PNG</option>
                            </select>
                            <button id="exportSvgBtn">导出SVG</button>
                            <button id="exportPngBtn">导出PNG</button>
                            <span id="puml-status" style="color:#6B7280; margin-left:8px;">待运行</span>
                        </div>
                    </div>
                    <div>
                        <img id="puml-preview" alt="UML图预览"
                            style="width:100%; max-height:420px; object-fit:contain; border:1px solid var(--border-color); border-radius:8px; background:#fff;">
                    </div>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>6.2 类图与其他UML图的协作关系</h2>
                <p>类图是UML中的静态结构图，与其他UML图相互补充，共同构成完整的系统模型。</p>

                <h3>类图与序列图</h3>
                <ul>
                    <li><strong>类图</strong>：定义静态结构，展示类及其关系</li>
                    <li><strong>序列图</strong>：展示对象间的动态交互过程</li>
                    <li><strong>关系</strong>：类图中的类对应序列图中的对象，类图中的方法对应序列图中的消息</li>
                </ul>

                <h3>类图与用例图</h3>
                <ul>
                    <li><strong>用例图</strong>：描述系统功能需求，从用户视角展示系统功能</li>
                    <li><strong>类图</strong>：实现用例所需的内部结构</li>
                    <li><strong>关系</strong>：用例驱动类的设计，每个用例可能对应一组协作的类</li>
                </ul>

                <h3>类图与组件图</h3>
                <ul>
                    <li><strong>类图</strong>：展示系统内部微观结构</li>
                    <li><strong>组件图</strong>：展示系统更高层次的组织结构</li>
                    <li><strong>关系</strong>：组件由一组类组成，类图是组件图的细化</li>
                </ul>

                <h3>类图与活动图</h3>
                <ul>
                    <li><strong>活动图</strong>：描述业务流程或算法流程</li>
                    <li><strong>类图</strong>：活动图中涉及的对象类型</li>
                    <li><strong>关系</strong>：活动图中的操作通常对应类图中的方法</li>
                </ul>

                <h3>建模工具使用建议</h3>
                <ul>
                    <li><strong>Enterprise Architect</strong>：功能全面，适合大型项目</li>
                    <li><strong>Visual Paradigm</strong>：界面友好，学习曲线平缓</li>
                    <li><strong>PlantUML</strong>：文本式建模，适合版本控制和协作</li>
                    <li><strong>StarUML</strong>：开源免费，适合中小型项目</li>
                </ul>

                <h3>类图设计最佳实践</h3>
                <ul>
                    <li><strong>保持简洁</strong>：避免在单个类图中展示过多信息</li>
                    <li><strong>关注重点</strong>：根据受众调整展示的详细程度</li>
                    <li><strong>遵循标准</strong>：使用标准UML符号和约定</li>
                    <li><strong>合理分组</strong>：使用包或命名空间组织相关类</li>
                    <li><strong>明确关系</strong>：准确表示类之间的关系和多重性</li>
                </ul>

                <h3>常见误区</h3>
                <ul>
                    <li><strong>过度设计</strong>：创建不必要的类和关系</li>
                    <li><strong>细节过多</strong>：在类图中包含过多实现细节</li>
                    <li><strong>关系混淆</strong>：错误使用关系类型（如混淆聚合和组合）</li>
                    <li><strong>忽略约束</strong>：不标注重要的约束条件</li>
                    <li><strong>不一致性</strong>：命名和表示方式不统一</li>
                </ul>

                <p class="conclusion">类图是面向对象设计的重要工具，掌握它将帮助您更好地设计、沟通和实现软件系统。</p>
            </div>
        </section>

        <div class="progress-bar-container">
            <div id="progress-bar"></div>
        </div>
        <div class="controls">
            <button id="prevBtn">上一页</button>
            <span id="slide-counter">1 / X</span>
            <button id="nextBtn">下一页</button>
        </div>
    </main>

    <script src="../prism/prism.js"></script>
    <script src="../prism/prism-autoloader.min.js"></script>
    <script src="https://unpkg.com/plantuml-encoder/dist/plantuml-encoder.min.js"></script>
    <script>
        (function () {
            var server = 'https://www.plantuml.com/plantuml';
            function encode(txt) { return window.plantumlEncoder.encode(txt); }
            function url(format, encoded) { return server + '/' + format + '/' + encoded; }
            function textUrl(encoded) { return server + '/txt/' + encoded; }
            function renderImageFromCode(codeElId, imgElId, format) {
                var codeEl = document.getElementById(codeElId);
                var imgEl = document.getElementById(imgElId);
                if (!codeEl || !imgEl) return;
                var src = codeEl.textContent;
                var encoded = encode(src);
                imgEl.src = url(format || 'svg', encoded);
            }
            function initExamples() {
                var imgs = document.querySelectorAll('.puml-render');
                imgs.forEach(function (img) {
                    var sid = img.getAttribute('data-source-id');
                    var fmt = img.getAttribute('data-format') || 'svg';
                    var codeEl = document.getElementById(sid);
                    if (!codeEl) return;
                    var encoded = encode(codeEl.textContent);
                    img.src = url(fmt, encoded);
                });
            }
            function bindCopyButtons() {
                var btns = document.querySelectorAll('.copy-btn');
                btns.forEach(function (btn) {
                    btn.addEventListener('click', function () {
                        var id = btn.getAttribute('data-code-id');
                        var el = document.getElementById(id);
                        if (!el) return;
                        var txt = el.textContent;
                        if (navigator.clipboard && navigator.clipboard.writeText) {
                            navigator.clipboard.writeText(txt).then(function () {
                                btn.textContent = '已复制';
                                setTimeout(function () { btn.textContent = '复制示例代码'; }, 1200);
                            }).catch(function () {
                                btn.textContent = '复制失败';
                                setTimeout(function () { btn.textContent = '复制示例代码'; }, 1200);
                            });
                        }
                    });
                });
            }
            function validateAndRenderEditor() {
                var ta = document.getElementById('puml-editor');
                var fmtSel = document.getElementById('puml-format');
                var img = document.getElementById('puml-preview');
                var status = document.getElementById('puml-status');
                if (!ta || !img) return;
                var src = ta.value;
                var encoded = encode(src);
                var fmt = fmtSel ? fmtSel.value : 'svg';
                fetch(textUrl(encoded)).then(function (r) { return r.text(); }).then(function (text) {
                    var ok = text && text.toLowerCase().indexOf('error') === -1;
                    status.textContent = ok ? '语法正确' : '语法错误';
                    status.style.color = ok ? 'var(--success-color)' : 'var(--warning-text-color)';
                    img.src = url(fmt, encoded);
                }).catch(function () {
                    status.textContent = '网络校验失败';
                    status.style.color = 'var(--warning-text-color)';
                    img.src = url(fmt, encoded);
                });
            }
            function debounce(fn, wait) {
                var t;
                return function () {
                    var ctx = this, args = arguments;
                    clearTimeout(t);
                    t = setTimeout(function () { fn.apply(ctx, args); }, wait);
                };
            }
            function bindEditor() {
                var ta = document.getElementById('puml-editor');
                var runBtn = document.getElementById('runPumlBtn');
                var copyBtn = document.getElementById('copyPumlBtn');
                var fmtSel = document.getElementById('puml-format');
                var exportSvgBtn = document.getElementById('exportSvgBtn');
                var exportPngBtn = document.getElementById('exportPngBtn');
                if (!ta) return;
                var onInput = debounce(validateAndRenderEditor, 400);
                ta.addEventListener('input', onInput);
                if (runBtn) runBtn.addEventListener('click', validateAndRenderEditor);
                if (fmtSel) fmtSel.addEventListener('change', validateAndRenderEditor);
                if (copyBtn) copyBtn.addEventListener('click', function () {
                    var txt = ta.value;
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        navigator.clipboard.writeText(txt);
                    }
                });
                function doExport(fmt) {
                    var encoded = encode(ta.value);
                    var u = url(fmt, encoded);
                    try {
                        fetch(u, { mode: 'cors' }).then(function (r) { return r.blob(); }).then(function (b) {
                            var a = document.createElement('a');
                            var objectUrl = URL.createObjectURL(b);
                            a.href = objectUrl;
                            a.download = 'diagram.' + fmt;
                            document.body.appendChild(a);
                            a.click();
                            setTimeout(function () { URL.revokeObjectURL(objectUrl); a.remove(); }, 500);
                        }).catch(function () { window.open(u, '_blank'); });
                    } catch (e) { window.open(u, '_blank'); }
                }
                if (exportSvgBtn) exportSvgBtn.addEventListener('click', function () { doExport('svg'); });
                if (exportPngBtn) exportPngBtn.addEventListener('click', function () { doExport('png'); });
                validateAndRenderEditor();
            }
            document.addEventListener('DOMContentLoaded', function () {
                initExamples();
                bindCopyButtons();
                bindEditor();
            });
        })();
    </script>
    <script src="./js/ppt.js"></script>
    <script src="./js/nav.js"></script>
</body>

</html>