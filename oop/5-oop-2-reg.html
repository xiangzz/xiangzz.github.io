<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java正则表达式详解</title>
    <link rel="stylesheet" href="./css/style.css">
    <link rel="stylesheet" href="./css/hacker-cmd.css">
    <link rel="stylesheet" href="../prism/prism.css">
    <link rel="stylesheet" href="./css/animation.css">
</head>
<body>

    <main id="presentation">
        <!-- Slide 1: Title -->
        <section class="slide title-slide active">
            <h1>Java 正则表达式</h1>
            <p>Regular Expressions in Java</p>
            <strong>掌握文本处理的强大工具</strong>
            <div class="title-decoration">
                <span class="regex-symbol">.*</span>
                <span class="regex-symbol">[a-zA-Z]+</span>
                <span class="regex-symbol">\d{3,5}</span>
            </div>
        </section>

        <!-- Slide 2: What is Regular Expression -->
        <section class="slide">
            <div class="slide-content">
                <h2>什么是正则表达式？</h2>
                <p>正则表达式（Regular Expression，简称 Regex）是一种强大的文本模式匹配工具，就像是文本世界的"搜索引擎"。</p>
                
                <h3>🔍 生活中的类比</h3>
                <p>想象你在图书馆寻找书籍：</p>
                <ul>
                    <li><strong>普通搜索：</strong> "找到书名是《Java编程思想》的书" - 精确匹配</li>
                    <li><strong>正则搜索：</strong> "找到所有以'Java'开头，包含'编程'的书" - 模式匹配</li>
                </ul>

                <h3>正则表达式的核心能力</h3>
                <ul>
                    <li><strong>🎯 模式匹配：</strong>检查文本是否符合特定模式</li>
                    <li><strong>🔍 文本搜索：</strong>在大量文本中快速找到目标</li>
                    <li><strong>✂️ 文本替换：</strong>批量替换符合模式的文本</li>
                    <li><strong>📝 数据验证：</strong>验证邮箱、电话号码等格式</li>
                </ul>
            </div>
        </section>

        <!-- Slide 2.5: Finite State Automaton Theory -->
        <section class="slide">
            <div class="slide-content">
                <h2>有限状态自动机理论基础</h2>
                <p>理解正则表达式的工作原理：有限状态自动机（FSA）</p>

                <h3>🔧 什么是有限状态自动机？</h3>
                <p><strong>有限状态自动机</strong>是一个数学模型，由以下组成：</p>
                <ul>
                    <li><strong>状态集合：</strong>有限个状态，包括初始状态和接受状态</li>
                    <li><strong>字母表：</strong>输入符号的集合</li>
                    <li><strong>转移函数：</strong>定义状态间的转移规则</li>
                    <li><strong>初始状态：</strong>自动机开始的状态</li>
                    <li><strong>接受状态：</strong>表示匹配成功的状态</li>
                </ul>

                <h3>🎯 正则表达式如何工作</h3>
                <h4>示例：匹配 "abc" 的状态机</h4>
                <p><strong>示例：匹配字符串 "abc" 的状态机</strong></p>
                <pre><code>S0 --a--> S1 --b--> S2 --c--> S3(接受状态)</code></pre>
                <p><strong>工作过程：</strong></p>
                <ol>
                    <li>从初始状态 S0 开始</li>
                    <li>读取字符 'a'，转移到状态 S1</li>
                    <li>读取字符 'b'，转移到状态 S2</li>
                    <li>读取字符 'c'，转移到接受状态 S3</li>
                    <li>到达接受状态，匹配成功！</li>
                </ol>

                <h3>🧠 为什么理解FSM很重要？</h3>
                <ul>
                    <li><strong>性能理解：</strong>了解状态转移有助于编写高效的正则表达式</li>
                    <li><strong>调试能力：</strong>理解匹配过程有助于调试复杂的正则表达式</li>
                    <li><strong>精确控制：</strong>明确知道每个字符如何影响匹配状态</li>
                    <li><strong>避免陷阱：</strong>理解回溯机制，避免性能问题</li>
                </ul>
            </div>
        </section>

        <!-- Slide 3: Java Regular Expressions (Moved from Slide 10) -->
        <section class="slide">
            <div class="slide-content">
                <h2>String类的文本处理方法</h2>
                <p>在学习正则表达式之前，让我们先了解String类中常用的文本处理方法，它们为我们引出正则表达式的强大功能：</p>

                <div class="string-methods-intro">
                    <div class="method-explanation">
                        <h3>🔄 replace() 和 replaceAll()</h3>
                        <p>字符串替换操作</p>
                        <pre><code class="language-java">String text = "Hello World, Hello Java";

// replace() - 替换所有匹配的字符序列
String result1 = text.replace("Hello", "Hi");
// 结果: "Hi World, Hi Java"

// replaceAll() - 支持正则表达式的替换
String result2 = text.replaceAll("Hello", "Hi");
// 结果: "Hi World, Hi Java"

// replaceAll() 的正则表达式威力
String phoneText = "电话: 123-456-7890, 手机: 987-654-3210";
String masked = phoneText.replaceAll("\\d{3}-\\d{3}-\\d{4}", "***-***-****");
// 结果: "电话: ***-***-****, 手机: ***-***-****"</code></pre>
                    </div>

                    <div class="method-explanation">
                        <h3>✂️ split() 方法</h3>
                        <p>字符串分割操作</p>
                        <pre><code class="language-java">String data = "apple,banana,orange";

// 简单分割
String[] fruits = data.split(",");
// 结果: ["apple", "banana", "orange"]

// 使用正则表达式分割
String complexData = "apple,banana;orange:grape";
String[] allFruits = complexData.split("[,;:]");
// 结果: ["apple", "banana", "orange", "grape"]

// 处理多个空格
String sentence = "Hello    world   Java";
String[] words = sentence.split("\\s+");
// 结果: ["Hello", "world", "Java"]</code></pre>
                    </div>
                </div>

                <div class="string-limitations">
                    <h3>🤔 String方法的局限性</h3>
                    <div class="limitation-examples">
                        <div class="limitation-item">
                            <h4>复杂模式匹配</h4>
                            <p>如何验证邮箱格式？电话号码格式？</p>
                            <pre><code class="language-java">// 使用String方法很难实现
String email = "user@example.com";
// 如何验证这是一个有效的邮箱？</code></pre>
                        </div>
                        <div class="limitation-item">
                            <h4>灵活的文本提取</h4>
                            <p>如何从文本中提取所有的数字？所有的URL？</p>
                            <pre><code class="language-java">// String方法无法轻松实现
String text = "价格：￥199.99，折扣：8.5折";
// 如何提取所有数字？</code></pre>
                        </div>
                    </div>
                </div>

                <div class="regex-introduction">
                    <h3>🚀 正则表达式的优势</h3>
                    <p>正则表达式提供了强大的模式匹配能力，可以轻松解决上述问题：</p>
                    <ul>
                        <li><strong>模式匹配</strong>：定义复杂的文本模式</li>
                        <li><strong>数据验证</strong>：验证邮箱、电话、身份证等格式</li>
                        <li><strong>文本提取</strong>：从复杂文本中提取特定信息</li>
                        <li><strong>高效替换</strong>：基于模式的智能替换</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Slide 4: Basic Syntax -->
        <section class="slide">
            <div class="slide-content">
                <h2>正则表达式基础语法</h2>
                <p>正则表达式由普通字符和特殊字符（元字符）组成，就像编程语言的语法一样。</p>

                <h3>🔤 字符匹配</h3>
                <table>
                    <thead>
                        <tr>
                            <th>符号</th>
                            <th>含义</th>
                            <th>示例</th>
                            <th>匹配结果</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>.</code></td>
                            <td>匹配任意单个字符</td>
                            <td><code>a.c</code></td>
                            <td>abc, a1c, a@c</td>
                        </tr>
                        <tr>
                            <td><code>\d</code></td>
                            <td>匹配数字 [0-9]</td>
                            <td><code>\d\d</code></td>
                            <td>12, 99, 00</td>
                        </tr>
                        <tr>
                            <td><code>\w</code></td>
                            <td>匹配字母、数字、下划线</td>
                            <td><code>\w+</code></td>
                            <td>hello, test_123</td>
                        </tr>
                        <tr>
                            <td><code>\s</code></td>
                            <td>匹配空白字符</td>
                            <td><code>\s+</code></td>
                            <td>空格, 制表符, 换行</td>
                        </tr>
                    </tbody>
                </table>

                <h3>🔢 数量限定符</h3>
                <table>
                    <thead>
                        <tr>
                            <th>符号</th>
                            <th>含义</th>
                            <th>示例</th>
                            <th>匹配结果</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>*</code></td>
                            <td>0次或多次</td>
                            <td><code>ab*</code></td>
                            <td>a, ab, abbb</td>
                        </tr>
                        <tr>
                            <td><code>+</code></td>
                            <td>1次或多次</td>
                            <td><code>ab+</code></td>
                            <td>ab, abbb (不匹配a)</td>
                        </tr>
                        <tr>
                            <td><code>?</code></td>
                            <td>0次或1次</td>
                            <td><code>ab?</code></td>
                            <td>a, ab</td>
                        </tr>
                        <tr>
                            <td><code>{n,m}</code></td>
                            <td>n到m次</td>
                            <td><code>\d{3,5}</code></td>
                            <td>123, 1234, 12345</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <!-- Slide 5: Pattern and Matcher Classes -->
        <section class="slide">
            <div class="slide-content">
                <h2>Pattern和Matcher类：Java正则表达式的核心</h2>
                <p>学习了正则表达式语法后，让我们掌握Java中专门用于正则表达式操作的两个核心类。</p>

                <div class="java-regex-classes">
                    <div class="class-explanation">
                        <h3>🎯 Pattern类 - 正则表达式的编译器</h3>
                        <p><strong>作用：</strong>将正则表达式字符串编译成可重用的模式对象</p>
                        <p><strong>特点：</strong>线程安全，可以被多个线程同时使用</p>
                        <pre><code class="language-java">// 编译正则表达式
Pattern pattern = Pattern.compile("\\d{3}-\\d{2}-\\d{4}");

// 带标志的编译
Pattern pattern = Pattern.compile("hello", Pattern.CASE_INSENSITIVE);</code></pre>
                    </div>

                    <div class="class-explanation">
                        <h3>🔍 Matcher类 - 匹配执行器</h3>
                        <p><strong>作用：</strong>对特定字符串执行匹配操作</p>
                        <p><strong>特点：</strong>非线程安全，每个线程需要独立的Matcher实例</p>
                        <pre><code class="language-java">// 创建Matcher对象
String text = "电话：123-45-6789";
Matcher matcher = pattern.matcher(text);

// 执行匹配操作
if (matcher.find()) {
    System.out.println("找到匹配：" + matcher.group());
}</code></pre>
                    </div>
                </div>

                <div class="common-methods">
                    <h3>🛠️ 常用方法一览</h3>
                    <div class="method-grid">
                        <div class="method-item">
                            <h4>find()</h4>
                            <p>查找下一个匹配</p>
                            <code>boolean found = matcher.find();</code>
                        </div>
                        <div class="method-item">
                            <h4>matches()</h4>
                            <p>整个字符串是否匹配</p>
                            <code>boolean isMatch = matcher.matches();</code>
                        </div>
                        <div class="method-item">
                            <h4>group()</h4>
                            <p>获取匹配的内容</p>
                            <code>String result = matcher.group();</code>
                        </div>
                        <div class="method-item">
                            <h4>replaceAll()</h4>
                            <p>替换所有匹配</p>
                            <code>String newText = matcher.replaceAll("***");</code>
                        </div>
                    </div>
                </div>

                <div class="practical-example">
                    <h3>💡 完整示例：邮箱验证</h3>
                    <pre><code class="language-java">import java.util.regex.*;

public class EmailValidator {
    private static final String EMAIL_PATTERN = 
        "^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$";
    
    private static final Pattern pattern = Pattern.compile(EMAIL_PATTERN);
    
    public static boolean isValidEmail(String email) {
        Matcher matcher = pattern.matcher(email);
        return matcher.matches();
    }
    
    public static void main(String[] args) {
        String[] emails = {
            "user@example.com",     // ✅ 有效
            "test.email@domain.co", // ✅ 有效  
            "invalid.email",        // ❌ 无效
            "@domain.com"           // ❌ 无效
        };
        
        for (String email : emails) {
            System.out.println(email + " -> " + 
                (isValidEmail(email) ? "有效" : "无效"));
        }
    }
}</code></pre>
                </div>
            </div>
        </section>

        <!-- Slide 6: Greedy vs Non-Greedy Matching -->
        <section class="slide">
            <div class="slide-content">
                <h2>贪婪与非贪婪匹配</h2>
                <p>理解正则表达式的两种匹配策略，掌握精确控制匹配行为的技巧。</p>

                <h3>🔍 匹配机制原理</h3>
                <ul>
                    <li><strong>贪婪匹配 (Greedy)：</strong>尽可能多地匹配字符，先匹配最长可能的字符串，然后回溯</li>
                    <li><strong>非贪婪匹配 (Non-Greedy/Lazy)：</strong>尽可能少地匹配字符，先匹配最短可能的字符串，必要时扩展</li>
                </ul>

                <h3>📊 量词对比表</h3>
                <table>
                    <thead>
                        <tr>
                            <th>贪婪量词</th>
                            <th>非贪婪量词</th>
                            <th>含义</th>
                            <th>匹配策略</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>*</code></td>
                            <td><code>*?</code></td>
                            <td>0次或多次</td>
                            <td>贪婪：尽可能多 / 非贪婪：尽可能少</td>
                        </tr>
                        <tr>
                            <td><code>+</code></td>
                            <td><code>+?</code></td>
                            <td>1次或多次</td>
                            <td>贪婪：尽可能多 / 非贪婪：只匹配1次</td>
                        </tr>
                        <tr>
                            <td><code>?</code></td>
                            <td><code>??</code></td>
                            <td>0次或1次</td>
                            <td>贪婪：优先匹配1次 / 非贪婪：优先匹配0次</td>
                        </tr>
                        <tr>
                            <td><code>{n,m}</code></td>
                            <td><code>{n,m}?</code></td>
                            <td>n到m次</td>
                            <td>贪婪：优先匹配m次 / 非贪婪：优先匹配n次</td>
                        </tr>
                    </tbody>
                </table>

                <h3>🎭 实战演示</h3>
                <h4>案例1：HTML标签提取</h4>
                <p><strong>文本：</strong><code>"&lt;div&gt;Hello&lt;/div&gt;&lt;span&gt;World&lt;/span&gt;"</code></p>
                <ul>
                    <li><strong>贪婪模式 <code>&lt;.*&gt;</code>：</strong>匹配整个字符串 ❌</li>
                    <li><strong>非贪婪模式 <code>&lt;.*?&gt;</code>：</strong>分别匹配每个标签 ✅</li>
                </ul>

                <h4>案例2：引号内容提取</h4>
                <p><strong>文本：</strong><code>"name=\"John\" age=\"25\""</code></p>
                <ul>
                    <li><strong>贪婪模式 <code>".*"</code>：</strong>匹配 "John\" age=\"25" ❌</li>
                    <li><strong>非贪婪模式 <code>".*?"</code>：</strong>分别匹配 "John" 和 "25" ✅</li>
                </ul>

                <h3>💻 Java代码示例</h3>
                <pre><code class="language-java">import java.util.regex.*;

public class GreedyDemo {
    public static void main(String[] args) {
        String text = "&lt;div&gt;Hello&lt;/div&gt;&lt;span&gt;World&lt;/span&gt;";
        
        // 贪婪匹配
        Pattern greedyPattern = Pattern.compile("&lt;.*&gt;");
        Matcher greedyMatcher = greedyPattern.matcher(text);
        System.out.println("贪婪匹配结果:");
        while (greedyMatcher.find()) {
            System.out.println("  " + greedyMatcher.group());
        }
        
        // 非贪婪匹配
        Pattern lazyPattern = Pattern.compile("&lt;.*?&gt;");
        Matcher lazyMatcher = lazyPattern.matcher(text);
        System.out.println("非贪婪匹配结果:");
        while (lazyMatcher.find()) {
            System.out.println("  " + lazyMatcher.group());
        }
    }
}</code></pre>

                <h3>⚡ 性能考虑</h3>
                <ul>
                    <li><strong>回溯问题：</strong>贪婪匹配可能导致大量回溯，影响性能</li>
                    <li><strong>优化策略：</strong>使用非贪婪量词、精确指定匹配范围</li>
                    <li><strong>危险模式：</strong>避免使用 <code>(a+)+b</code> 这样的嵌套量词</li>
                </ul>
            </div>
        </section>

        <!-- Slide 6: Quantifiers -->
        <section class="slide">
            <div class="slide-content">
                <h2>量词 (Quantifiers)</h2>
                <p>量词用于指定匹配的次数，是正则表达式中控制匹配数量的核心机制。</p>

                <h3>基本量词</h3>
                <table>
                    <tr><th>量词</th><th>含义</th><th>示例</th></tr>
                    <tr><td><code>*</code></td><td>0次或多次</td><td><code>a*</code> 匹配 "", "a", "aa", "aaa"</td></tr>
                    <tr><td><code>+</code></td><td>1次或多次</td><td><code>a+</code> 匹配 "a", "aa", "aaa"</td></tr>
                    <tr><td><code>?</code></td><td>0次或1次</td><td><code>a?</code> 匹配 "", "a"</td></tr>
                    <tr><td><code>{n}</code></td><td>恰好n次</td><td><code>a{3}</code> 匹配 "aaa"</td></tr>
                    <tr><td><code>{n,}</code></td><td>至少n次</td><td><code>a{2,}</code> 匹配 "aa", "aaa", "aaaa"</td></tr>
                    <tr><td><code>{n,m}</code></td><td>n到m次</td><td><code>a{2,4}</code> 匹配 "aa", "aaa", "aaaa"</td></tr>
                </table>

                <h3>实际应用示例</h3>
                <pre><code class="language-java">// 匹配手机号码 (11位数字)
String phonePattern = "\\d{11}";

// 匹配邮箱地址
String emailPattern = "\\w+@\\w+\\.\\w{2,4}";

// 匹配HTML标签
String htmlPattern = "&lt;\\w+.*?&gt;";

// 匹配IP地址
String ipPattern = "\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}";

// 匹配可选的协议前缀
String urlPattern = "(https?://)?\\w+\\.\\w+";

// 测试示例
Pattern pattern = Pattern.compile(phonePattern);
Matcher matcher = pattern.matcher("13812345678");
System.out.println(matcher.matches()); // true</code></pre>
            </div>
        </section>

        <!-- Slide 7: Character Classes -->
        <section class="slide">
            <div class="slide-content">
                <h2>字符类 (Character Classes)</h2>
                <p>字符类允许我们匹配一组特定的字符，是正则表达式中非常实用的功能。</p>
                
                <h3>基础字符类</h3>
                <ul>
                    <li><code>[abc]</code> - 匹配 a、b 或 c 中的任意一个</li>
                    <li><code>[a-z]</code> - 匹配任意小写字母</li>
                    <li><code>[A-Z]</code> - 匹配任意大写字母</li>
                    <li><code>[0-9]</code> - 匹配任意数字</li>
                    <li><code>[^abc]</code> - 匹配除了 a、b、c 之外的任意字符</li>
                    <li><code>[a-zA-Z0-9]</code> - 匹配字母或数字</li>
                </ul>

                <h3>高级字符类</h3>
                <ul>
                    <li><code>[a-z&&[^bc]]</code> - 交集：小写字母但不包括b和c</li>
                    <li><code>[a-z[A-Z]]</code> - 并集：所有字母</li>
                    <li><code>[\p{L}]</code> - Unicode字母类</li>
                    <li><code>[\p{N}]</code> - Unicode数字类</li>
                    <li><code>[^\s]</code> - 非空白字符</li>
                    <li><code>[[:alpha:]]</code> - POSIX字母类</li>
                </ul>

                <h3>实际应用示例</h3>
                <ul>
                    <li><strong>用户名验证：</strong> <code>[a-zA-Z0-9_]{3,16}</code> - 3-16位字母、数字或下划线</li>
                    <li><strong>十六进制颜色：</strong> <code>#[0-9a-fA-F]{6}</code> - 匹配CSS颜色代码</li>
                    <li><strong>中文字符：</strong> <code>[\u4e00-\u9fa5]+</code> - 匹配中文字符</li>
                </ul>
            </div>
        </section>

        <!-- Slide 8: Unicode and Advanced Character Classes -->
        <section class="slide">
            <div class="slide-content">
                <h2>🌍 Unicode与高级字符类详解</h2>
                
                <h3>Unicode字符分类系统</h3>
                
                <h4>字母类 (Letter)</h4>
                <ul>
                    <li><code>\p{L}</code> - 所有字母</li>
                    <li><code>\p{Lu}</code> - 大写字母 (Uppercase Letter)</li>
                    <li><code>\p{Ll}</code> - 小写字母 (Lowercase Letter)</li>
                    <li><code>\p{Lt}</code> - 标题字母 (Titlecase Letter)</li>
                    <li><code>\p{Lm}</code> - 修饰字母 (Modifier Letter)</li>
                    <li><code>\p{Lo}</code> - 其他字母 (Other Letter)</li>
                </ul>
                
                <h4>数字类 (Number)</h4>
                <ul>
                    <li><code>\p{N}</code> - 所有数字</li>
                    <li><code>\p{Nd}</code> - 十进制数字 (Decimal Number)</li>
                    <li><code>\p{Nl}</code> - 字母数字 (Letter Number)</li>
                    <li><code>\p{No}</code> - 其他数字 (Other Number)</li>
                </ul>
                
                <h4>标点符号类 (Punctuation)</h4>
                <ul>
                    <li><code>\p{P}</code> - 所有标点</li>
                    <li><code>\p{Pc}</code> - 连接符 (Connector Punctuation)</li>
                    <li><code>\p{Pd}</code> - 破折号 (Dash Punctuation)</li>
                    <li><code>\p{Ps}</code> - 开始标点 (Open Punctuation)</li>
                    <li><code>\p{Pe}</code> - 结束标点 (Close Punctuation)</li>
                </ul>

                <div class="script-blocks">
                    <h3>📝 Unicode脚本块 (Script Blocks)</h3>
                    <div class="script-grid">
                        <div class="script-item">
                            <h4>中文相关</h4>
                            <pre><code class="language-regex">\p{Script=Han}        // 汉字
\p{Script=Hiragana}   // 平假名
\p{Script=Katakana}   // 片假名
\p{InCJK_Unified_Ideographs}  // CJK统一汉字</code></pre>
                        </div>
                        
                        <div class="script-item">
                            <h4>拉丁文系</h4>
                            <pre><code class="language-regex">\p{Script=Latin}      // 拉丁字母
\p{Script=Cyrillic}   // 西里尔字母
\p{Script=Greek}      // 希腊字母
\p{Script=Arabic}     // 阿拉伯字母</code></pre>
                        </div>
                        
                        <div class="script-item">
                            <h4>其他脚本</h4>
                            <pre><code class="language-regex">\p{Script=Hebrew}     // 希伯来文
\p{Script=Thai}       // 泰文
\p{Script=Devanagari} // 天城文
\p{Script=Bengali}    // 孟加拉文</code></pre>
                        </div>
                    </div>
                </div>

                <div class="posix-classes">
                    <h3>🔧 POSIX字符类详解</h3>
                    <div class="posix-table">
                        <table class="unicode-table">
                            <thead>
                                <tr>
                                    <th>POSIX类</th>
                                    <th>等价Unicode</th>
                                    <th>描述</th>
                                    <th>示例</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>[[:alpha:]]</code></td>
                                    <td><code>\p{L}</code></td>
                                    <td>字母字符</td>
                                    <td>a, B, 中, α</td>
                                </tr>
                                <tr>
                                    <td><code>[[:digit:]]</code></td>
                                    <td><code>\p{Nd}</code></td>
                                    <td>十进制数字</td>
                                    <td>0, 5, ９</td>
                                </tr>
                                <tr>
                                    <td><code>[[:alnum:]]</code></td>
                                    <td><code>[\p{L}\p{Nd}]</code></td>
                                    <td>字母或数字</td>
                                    <td>a, 5, 中</td>
                                </tr>
                                <tr>
                                    <td><code>[[:punct:]]</code></td>
                                    <td><code>\p{P}</code></td>
                                    <td>标点符号</td>
                                    <td>!, ?, 。</td>
                                </tr>
                                <tr>
                                    <td><code>[[:space:]]</code></td>
                                    <td><code>\p{Z}</code></td>
                                    <td>空白字符</td>
                                    <td>空格, \t, \n</td>
                                </tr>
                                <tr>
                                    <td><code>[[:xdigit:]]</code></td>
                                    <td><code>[0-9A-Fa-f]</code></td>
                                    <td>十六进制数字</td>
                                    <td>0, A, f</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <div class="unicode-demo">
                    <h3>🧪 Unicode匹配演示</h3>
                    <div class="demo-container">
                        <div class="demo-input-group">
                            <label>测试文本:</label>
                            <input type="text" id="unicodeText" value="Hello世界123αβγ！@#" placeholder="输入包含多种字符的文本">
                        </div>
                        <div class="demo-patterns">
                            <div class="pattern-demo">
                                <h4>Unicode字母匹配</h4>
                                <button onclick="testUnicode('letters')">测试 \p{L}</button>
                                <div id="lettersResult" class="result-area"></div>
                            </div>
                            <div class="pattern-demo">
                                <h4>中文字符匹配</h4>
                                <button onclick="testUnicode('chinese')">测试 \p{Script=Han}</button>
                                <div id="chineseResult" class="result-area"></div>
                            </div>
                            <div class="pattern-demo">
                                <h4>数字字符匹配</h4>
                                <button onclick="testUnicode('numbers')">测试 \p{N}</button>
                                <div id="numbersResult" class="result-area"></div>
                            </div>
                            <div class="pattern-demo">
                                <h4>标点符号匹配</h4>
                                <button onclick="testUnicode('punctuation')">测试 \p{P}</button>
                                <div id="punctuationResult" class="result-area"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="practical-unicode">
                    <h3>💼 实际应用场景</h3>
                    <div class="application-grid">
                        <div class="app-item">
                            <h4>多语言用户名验证</h4>
                            <pre><code class="language-java">// 支持多语言字符的用户名
Pattern pattern = Pattern.compile("^[\\p{L}\\p{N}_]{3,20}$");

// 测试
String[] usernames = {"张三", "John123", "محمد", "Αλέξανδρος"};
for (String name : usernames) {
    System.out.println(name + ": " + pattern.matcher(name).matches());
}</code></pre>
                        </div>
                        
                        <div class="app-item">
                            <h4>国际化文本处理</h4>
                            <pre><code class="language-java">// 提取所有字母字符
Pattern letterPattern = Pattern.compile("\\p{L}+");

// 提取所有数字（包括全角数字）
Pattern numberPattern = Pattern.compile("\\p{N}+");

// 移除所有标点符号
String cleaned = text.replaceAll("\\p{P}", "");</code></pre>
                        </div>
                        
                        <div class="app-item">
                            <h4>特定脚本文本提取</h4>
                            <pre><code class="language-java">// 提取中文内容
Pattern chinesePattern = Pattern.compile("\\p{Script=Han}+");

// 提取阿拉伯文内容
Pattern arabicPattern = Pattern.compile("\\p{Script=Arabic}+");

// 提取拉丁字母内容
Pattern latinPattern = Pattern.compile("\\p{Script=Latin}+");</code></pre>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 9: Boundary Matching -->
        <section class="slide">
            <div class="slide-content">
                <h2>边界匹配和实用示例</h2>
                <p>边界匹配帮助我们精确控制匹配的位置，避免误匹配。</p>
                
                <div class="syntax-section">
                    <h3>🎯 边界匹配符</h3>
                    <div class="boundary-examples">
                        <div class="boundary-item">
                            <code>^</code>
                            <span class="description">行的开始</span>
                            <span class="example">^Hello 匹配以"Hello"开头的行</span>
                        </div>
                        <div class="boundary-item">
                            <code>$</code>
                            <span class="description">行的结束</span>
                            <span class="example">world$ 匹配以"world"结尾的行</span>
                        </div>
                        <div class="boundary-item">
                            <code>\b</code>
                            <span class="description">单词边界</span>
                            <span class="example">\bcat\b 匹配独立的单词"cat"</span>
                        </div>
                        <div class="boundary-item">
                            <code>\B</code>
                            <span class="description">非单词边界</span>
                            <span class="example">\Bcat\B 匹配"cat"但不在单词边界</span>
                        </div>
                        <div class="boundary-item">
                            <code>\A</code>
                            <span class="description">字符串开始</span>
                            <span class="example">\AStart 匹配整个字符串的开始</span>
                        </div>
                        <div class="boundary-item">
                            <code>\Z</code>
                            <span class="description">字符串结束</span>
                            <span class="example">End\Z 匹配整个字符串的结束</span>
                        </div>
                    </div>
                </div>

                <div class="practical-example">
                    <h3>💡 完整验证示例</h3>
                    <div class="example-showcase">
                        <div class="showcase-item">
                            <strong>邮箱验证：</strong>
                            <code>^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$</code>
                            <p>完整的邮箱格式验证</p>
                        </div>
                        <div class="showcase-item">
                            <strong>手机号码：</strong>
                            <code>^1[3-9]\d{9}$</code>
                            <p>中国大陆手机号格式</p>
                        </div>
                        <div class="showcase-item">
                            <strong>身份证号：</strong>
                            <code>^\d{17}[\dXx]$</code>
                            <p>18位身份证号码</p>
                        </div>
                        <div class="showcase-item">
                            <strong>IP地址：</strong>
                            <code>^((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)$</code>
                            <p>IPv4地址格式验证</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 10: Practical Examples -->
        <section class="slide">
            <div class="slide-content">
                <h2>实战示例</h2>
                
                <div class="example-container">
                    <h3>📧 邮箱验证器</h3>
                    <pre><code class="language-java">import java.util.regex.Pattern;

public class EmailValidator {
    private static final String EMAIL_PATTERN = 
        "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$";
    
    private static final Pattern pattern = Pattern.compile(EMAIL_PATTERN);
    
    public static boolean isValidEmail(String email) {
        return pattern.matcher(email).matches();
    }
    
    public static void main(String[] args) {
        System.out.println(isValidEmail("user@example.com"));    // true
        System.out.println(isValidEmail("invalid.email"));      // false
        System.out.println(isValidEmail("test@domain.co.uk"));  // true
    }
}</code></pre>
                </div>

                <div class="example-container">
                    <h3>📱 手机号码提取器</h3>
                    <pre><code class="language-java">import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.ArrayList;
import java.util.List;

public class PhoneExtractor {
    public static List&lt;String&gt; extractPhones(String text) {
        String phonePattern = "1[3-9]\\d{9}";
        Pattern pattern = Pattern.compile(phonePattern);
        Matcher matcher = pattern.matcher(text);
        
        List&lt;String&gt; phones = new ArrayList&lt;&gt;();
        while (matcher.find()) {
            phones.add(matcher.group());
        }
        return phones;
    }
    
    public static void main(String[] args) {
        String text = "联系方式：13812345678，备用号码：15987654321";
        List&lt;String&gt; phones = extractPhones(text);
        phones.forEach(System.out::println);
        // 输出：13812345678, 15987654321
    }
}</code></pre>
                </div>
            </div>
        </section>

        <!-- Slide 12: Groups and Capturing -->
        <section class="slide">
            <div class="slide-content">
                <h2>分组和捕获</h2>
                <p>分组是正则表达式的强大功能，允许我们提取匹配的子字符串并进行复杂的模式匹配。</p>

                <div class="advanced-feature">
                    <h3>🎯 基础分组</h3>
                    <p>使用括号 <code>()</code> 创建分组，可以提取匹配的子字符串：</p>
                    <pre><code class="language-java">import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class GroupExample {
    public static void main(String[] args) {
        String text = "生日：1990-05-15";
        String pattern = "(\\d{4})-(\\d{2})-(\\d{2})";
        
        Pattern p = Pattern.compile(pattern);
        Matcher m = p.matcher(text);
        
        if (m.find()) {
            System.out.println("完整日期：" + m.group(0));  // 1990-05-15
            System.out.println("年份：" + m.group(1));      // 1990
            System.out.println("月份：" + m.group(2));      // 05
            System.out.println("日期：" + m.group(3));      // 15
        }
    }
}</code></pre>
                </div>

                <div class="advanced-feature">
                    <h3>🔧 高级分组技巧</h3>
                    <div class="group-techniques">
                        <div class="technique-item">
                            <h4>非捕获分组 <code>(?:...)</code></h4>
                            <p>分组但不捕获内容，提高性能</p>
                            <pre><code class="language-java">// 捕获分组
Pattern.compile("(https?)://(.+)");

// 非捕获分组
Pattern.compile("(?:https?)://(.+)");</code></pre>
                        </div>
                        <div class="technique-item">
                            <h4>命名分组 <code>(?&lt;name&gt;...)</code></h4>
                            <p>给分组命名，便于引用</p>
                            <pre><code class="language-java">String pattern = "(?&lt;year&gt;\\d{4})-(?&lt;month&gt;\\d{2})-(?&lt;day&gt;\\d{2})";
Pattern p = Pattern.compile(pattern);
Matcher m = p.matcher("2024-01-15");

if (m.find()) {
    System.out.println("年：" + m.group("year"));
    System.out.println("月：" + m.group("month"));
    System.out.println("日：" + m.group("day"));
}</code></pre>
                        </div>
                        <div class="technique-item">
                            <h4>反向引用 <code>\1, \2</code></h4>
                            <p>在正则表达式中引用之前的分组</p>
                            <pre><code class="language-java">// 匹配重复的单词
String pattern = "\\b(\\w+)\\s+\\1\\b";
String text = "这是是一个测试测试";
// 匹配 "是是" 和 "测试测试"</code></pre>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 13: Text Replacement and Flags -->
        <section class="slide">
            <div class="slide-content">
                <h2>文本替换和匹配标志</h2>
                <p>正则表达式不仅能匹配文本，还能进行智能替换和使用各种标志控制匹配行为。</p>

                <div class="advanced-feature">
                    <h3>🔄 文本替换</h3>
                    <p>使用正则表达式进行智能文本替换：</p>
                    <pre><code class="language-java">public class TextReplacer {
    public static void main(String[] args) {
        String text = "今天是2024年1月15日，明天是2024年1月16日";
        
        // 将所有日期格式从 YYYY年MM月DD日 改为 YYYY-MM-DD
        String pattern = "(\\d{4})年(\\d{1,2})月(\\d{1,2})日";
        String replacement = "$1-$2-$3";
        
        String result = text.replaceAll(pattern, replacement);
        System.out.println(result);
        // 输出：今天是2024-1-15，明天是2024-1-16
    }
}</code></pre>
                </div>

                <div class="advanced-feature">
                    <h3>🔧 高级替换技巧</h3>
                    <pre><code class="language-java">public class AdvancedReplacement {
    public static void main(String[] args) {
        // 使用Matcher进行复杂替换
        String text = "价格：$100, $200, $300";
        Pattern pattern = Pattern.compile("\\$(\\d+)");
        Matcher matcher = pattern.matcher(text);
        
        StringBuffer result = new StringBuffer();
        while (matcher.find()) {
            int price = Integer.parseInt(matcher.group(1));
            int discountPrice = (int)(price * 0.8); // 8折
            matcher.appendReplacement(result, "¥" + discountPrice);
        }
        matcher.appendTail(result);
        
        System.out.println(result.toString());
        // 输出：价格：¥80, ¥160, ¥240
    }
}</code></pre>
                </div>

                <div class="advanced-feature">
                    <h3>🚩 匹配标志</h3>
                    <div class="flag-grid">
                        <div class="flag-item">
                            <code>Pattern.CASE_INSENSITIVE</code>
                            <p>忽略大小写匹配</p>
                        </div>
                        <div class="flag-item">
                            <code>Pattern.MULTILINE</code>
                            <p>多行模式，^和$匹配每行</p>
                        </div>
                        <div class="flag-item">
                            <code>Pattern.DOTALL</code>
                            <p>点号匹配包括换行符</p>
                        </div>
                        <div class="flag-item">
                            <code>Pattern.UNICODE_CASE</code>
                            <p>Unicode大小写匹配</p>
                        </div>
                        <div class="flag-item">
                            <code>Pattern.COMMENTS</code>
                            <p>允许正则表达式中的注释</p>
                        </div>
                        <div class="flag-item">
                            <code>Pattern.LITERAL</code>
                            <p>将模式作为字面量处理</p>
                        </div>
                    </div>
                    
                    <div class="flag-example">
                        <h4>标志使用示例：</h4>
                        <pre><code class="language-java">// 组合多个标志
Pattern pattern = Pattern.compile(
    "hello.*world", 
    Pattern.CASE_INSENSITIVE | Pattern.DOTALL
);</code></pre>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 14: Pattern Flags Deep Dive -->
        <section class="slide">
            <div class="slide-content">
                <h2>正则表达式标志详解与演示</h2>
                <p>深入理解每种匹配标志的具体作用和使用场景，通过实际代码演示其效果。</p>

                <div class="flags-theory">
                    <h3>🚩 标志分类与作用机制</h3>
                    <div class="flag-categories">
                        <div class="flag-category">
                            <h4>字符匹配类</h4>
                            <ul>
                                <li><strong>CASE_INSENSITIVE</strong> - 忽略ASCII大小写</li>
                                <li><strong>UNICODE_CASE</strong> - 支持Unicode大小写折叠</li>
                                <li><strong>LITERAL</strong> - 禁用所有元字符</li>
                            </ul>
                        </div>
                        <div class="flag-category">
                            <h4>边界行为类</h4>
                            <ul>
                                <li><strong>MULTILINE</strong> - 改变^和$的行为</li>
                                <li><strong>DOTALL</strong> - 改变点号的匹配范围</li>
                            </ul>
                        </div>
                        <div class="flag-category">
                            <h4>表达式格式类</h4>
                            <ul>
                                <li><strong>COMMENTS</strong> - 允许空白和注释</li>
                                <li><strong>CANON_EQ</strong> - 规范等价匹配</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="flag-demos">
                    <h3>💡 标志演示与对比</h3>
                    
                    <div class="demo-section">
                        <h4>1. CASE_INSENSITIVE vs UNICODE_CASE</h4>
                        <div class="demo-grid">
                            <div class="demo-item">
                                <strong>CASE_INSENSITIVE (ASCII)</strong>
                                <pre><code class="language-java">Pattern pattern = Pattern.compile("hello", Pattern.CASE_INSENSITIVE);
// 匹配: "hello", "HELLO", "Hello", "HeLLo"
// 不匹配Unicode大小写变体</code></pre>
                            </div>
                            <div class="demo-item">
                                <strong>UNICODE_CASE (完整Unicode)</strong>
                                <pre><code class="language-java">Pattern pattern = Pattern.compile("café", 
    Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
// 匹配: "café", "CAFÉ", "Café"
// 支持Unicode字符的大小写变换</code></pre>
                            </div>
                        </div>
                    </div>

                    <div class="demo-section">
                        <h4>2. MULTILINE 模式详解</h4>
                        <div class="multiline-demo">
                            <div class="demo-comparison">
                                <div class="demo-before">
                                    <strong>默认模式</strong>
                                    <pre><code class="language-java">String text = "第一行\n第二行\n第三行";
Pattern pattern = Pattern.compile("^第二行$");
// 不匹配 - ^和$只匹配整个字符串的开始和结束</code></pre>
                                </div>
                                <div class="demo-after">
                                    <strong>MULTILINE模式</strong>
                                    <pre><code class="language-java">String text = "第一行\n第二行\n第三行";
Pattern pattern = Pattern.compile("^第二行$", Pattern.MULTILINE);
// 匹配成功 - ^和$匹配每行的开始和结束</code></pre>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="demo-section">
                        <h4>3. DOTALL 模式对比</h4>
                        <div class="dotall-demo">
                            <div class="demo-comparison">
                                <div class="demo-before">
                                    <strong>默认模式</strong>
                                    <pre><code class="language-java">String text = "开始\n中间\n结束";
Pattern pattern = Pattern.compile("开始.*结束");
// 不匹配 - 点号不匹配换行符</code></pre>
                                </div>
                                <div class="demo-after">
                                    <strong>DOTALL模式</strong>
                                    <pre><code class="language-java">String text = "开始\n中间\n结束";
Pattern pattern = Pattern.compile("开始.*结束", Pattern.DOTALL);
// 匹配成功 - 点号匹配包括换行符在内的任意字符</code></pre>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="demo-section">
                        <h4>4. COMMENTS 模式 - 可读性增强</h4>
                        <pre><code class="language-java">Pattern emailPattern = Pattern.compile(
    """
    ^                           # 字符串开始
    [a-zA-Z0-9._%+-]+          # 用户名部分
    @                          # @ 符号
    [a-zA-Z0-9.-]+             # 域名部分
    \\.                        # 点号
    [a-zA-Z]{2,}               # 顶级域名
    $                          # 字符串结束
    """, Pattern.COMMENTS);
// 允许在正则表达式中添加注释和空白，提高可读性</code></pre>
                    </div>

                    <div class="demo-section">
                        <h4>5. LITERAL 模式 - 元字符转义</h4>
                        <div class="literal-demo">
                            <div class="demo-comparison">
                                <div class="demo-before">
                                    <strong>普通模式</strong>
                                    <pre><code class="language-java">Pattern pattern = Pattern.compile("$100.50");
// 错误：$和.被当作元字符处理</code></pre>
                                </div>
                                <div class="demo-after">
                                    <strong>LITERAL模式</strong>
                                    <pre><code class="language-java">Pattern pattern = Pattern.compile("$100.50", Pattern.LITERAL);
// 正确：所有字符都被当作字面量处理</code></pre>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="practical-flags">
                    <h3>🎯 实际应用场景</h3>
                    <div class="scenario-grid">
                        <div class="scenario-item">
                            <h4>日志分析</h4>
                            <pre><code class="language-java">// 多行日志匹配
Pattern logPattern = Pattern.compile(
    "^ERROR.*?Exception.*$", 
    Pattern.MULTILINE | Pattern.DOTALL
);</code></pre>
                        </div>
                        <div class="scenario-item">
                            <h4>国际化文本处理</h4>
                            <pre><code class="language-java">// Unicode大小写不敏感搜索
Pattern searchPattern = Pattern.compile(
    searchTerm, 
    Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE
);</code></pre>
                        </div>
                        <div class="scenario-item">
                            <h4>配置文件解析</h4>
                            <pre><code class="language-java">// 带注释的复杂模式
Pattern configPattern = Pattern.compile(
    """
    ^\\s*                      # 行首空白
    ([a-zA-Z_][\\w]*)         # 配置项名称
    \\s*=\\s*                 # 等号
    (.*)                      # 配置值
    $                         # 行尾
    """, Pattern.COMMENTS | Pattern.MULTILINE
);</code></pre>
                        </div>
                    </div>
                </div>

                <div class="interactive-flags">
                    <h3>🧪 标志效果演示</h3>
                    <div class="flag-tester">
                        <div class="input-section">
                            <label>测试文本：</label>
                            <textarea id="flagTestText" placeholder="输入测试文本...">Hello World
HELLO world
café CAFÉ
第一行
第二行</textarea>
                        </div>
                        <div class="pattern-section">
                            <label>正则模式：</label>
                            <input type="text" id="flagPattern" placeholder="输入正则表达式..." value="hello.*world">
                        </div>
                        <div class="flags-section">
                            <label>选择标志：</label>
                            <div class="flag-checkboxes">
                                <label><input type="checkbox" id="caseInsensitive"> CASE_INSENSITIVE</label>
                                <label><input type="checkbox" id="multiline"> MULTILINE</label>
                                <label><input type="checkbox" id="dotall"> DOTALL</label>
                                <label><input type="checkbox" id="unicodeCase"> UNICODE_CASE</label>
                            </div>
                        </div>
                        <button onclick="testFlags()" class="test-button">测试标志效果</button>
                        <div id="flagResults" class="results-display"></div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 15: Interactive Exercise -->
        <section class="slide">
            <div class="slide-content">
                <h2>互动练习</h2>
                <p>让我们通过实际练习来巩固正则表达式的知识！</p>

                <div class="regex-exercise">
                    <div class="exercise-container">
                        <h3>🎮 正则表达式测试器</h3>
                        <div class="test-area">
                            <div class="input-group">
                                <label for="regexInput">正则表达式：</label>
                                <input type="text" id="regexInput" placeholder="输入正则表达式，如：\\d{3}-\\d{4}" value="\\d{3}-\\d{4}">
                            </div>
                            <div class="input-group">
                                <label for="testText">测试文本：</label>
                                <textarea id="testText" placeholder="输入要测试的文本">电话号码：123-4567，传真：987-6543</textarea>
                            </div>
                            <button onclick="testRegex()" class="test-btn">测试匹配</button>
                            <div id="regexResult" class="result-area"></div>
                        </div>
                    </div>

                    <div class="exercise-challenges">
                        <h3>🏆 挑战题目</h3>
                        <div class="challenge-list">
                            <div class="challenge-item">
                                <h4>挑战 1：验证中国身份证号</h4>
                                <p>要求：18位数字，最后一位可能是X</p>
                                <button onclick="loadChallenge(1)" class="challenge-btn">加载挑战</button>
                            </div>
                            <div class="challenge-item">
                                <h4>挑战 2：提取URL中的域名</h4>
                                <p>从完整URL中提取域名部分</p>
                                <button onclick="loadChallenge(2)" class="challenge-btn">加载挑战</button>
                            </div>
                            <div class="challenge-item">
                                <h4>挑战 3：验证强密码</h4>
                                <p>至少8位，包含大小写字母、数字和特殊字符</p>
                                <button onclick="loadChallenge(3)" class="challenge-btn">加载挑战</button>
                            </div>
                        </div>
                    </div>
                </div>

                <script>
                function testRegex() {
                    const regexInput = document.getElementById('regexInput').value;
                    const testText = document.getElementById('testText').value;
                    const resultDiv = document.getElementById('regexResult');
                    
                    try {
                        const regex = new RegExp(regexInput, 'g');
                        const matches = testText.match(regex);
                        
                        if (matches) {
                            resultDiv.innerHTML = `
                                <div class="success">
                                    <h4>✅ 匹配成功！</h4>
                                    <p><strong>找到 ${matches.length} 个匹配：</strong></p>
                                    <ul>${matches.map(match => `<li>${match}</li>`).join('')}</ul>
                                </div>
                            `;
                        } else {
                            resultDiv.innerHTML = `
                                <div class="no-match">
                                    <h4>❌ 没有找到匹配</h4>
                                    <p>请检查正则表达式或测试文本</p>
                                </div>
                            `;
                        }
                    } catch (error) {
                        resultDiv.innerHTML = `
                            <div class="error">
                                <h4>⚠️ 正则表达式错误</h4>
                                <p>${error.message}</p>
                            </div>
                        `;
                    }
                }

                function loadChallenge(challengeNumber) {
                    const regexInput = document.getElementById('regexInput');
                    const testText = document.getElementById('testText');
                    
                    switch(challengeNumber) {
                        case 1:
                            regexInput.value = '';
                            testText.value = '身份证号码：110101199001011234，无效号码：12345，另一个：320123198505156789';
                            break;
                        case 2:
                            regexInput.value = '';
                            testText.value = 'https://www.example.com/path?query=1\nhttp://subdomain.test.org/page\nftp://files.company.net/download';
                            break;
                        case 3:
                            regexInput.value = '';
                            testText.value = 'Password123!\nweakpass\nStrongP@ss1\n12345678\nMySecure#Pass2024';
                            break;
                    }
                }

                // 初始化时运行一次测试
                document.addEventListener('DOMContentLoaded', function() {
                    testRegex();
                });
                </script>
            </div>
        </section>

        <!-- Slide 16: Best Practices -->
        <section class="slide">
            <div class="slide-content">
                <h2>最佳实践</h2>

                <div class="best-practices">
                    <div class="practice-section">
                        <h3>✅ 编写高质量正则表达式</h3>
                        <div class="practice-list">
                            <div class="practice-item">
                                <span class="practice-icon">🎯</span>
                                <div>
                                    <h4>预编译正则表达式</h4>
                                    <p>对于重复使用的正则表达式，使用 <code>Pattern.compile()</code> 预编译以提高性能</p>
                                    <pre><code class="language-java">// 推荐做法
private static final Pattern EMAIL_PATTERN = 
    Pattern.compile("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$");

public boolean isValidEmail(String email) {
    return EMAIL_PATTERN.matcher(email).matches();
}</code></pre>
                                </div>
                            </div>
                            <div class="practice-item">
                                <span class="practice-icon">📝</span>
                                <div>
                                    <h4>使用原始字符串</h4>
                                    <p>在Java中使用双反斜杠 <code>\\</code> 或考虑使用字符串字面量</p>
                                    <pre><code class="language-java">// Java中的转义
String regex = "\\d{3}-\\d{2}-\\d{4}";  // 匹配 123-45-6789

// 使用Pattern.quote()避免转义问题
String literal = Pattern.quote("$100.00");  // 匹配字面量 $100.00</code></pre>
                                </div>
                            </div>
                            <div class="practice-item">
                                <span class="practice-icon">🔍</span>
                                <div>
                                    <h4>测试边界情况</h4>
                                    <p>确保正则表达式在空字符串、特殊字符等情况下正常工作</p>
                                    <pre><code class="language-java">// 测试各种情况
String[] testCases = {"", "abc", "123", "abc123", "!@#"};
Pattern pattern = Pattern.compile("\\w+");

for (String test : testCases) {
    System.out.println(test + " -> " + pattern.matcher(test).matches());
}</code></pre>
                                </div>
                            </div>
                            <div class="practice-item">
                                <span class="practice-icon">📚</span>
                                <div>
                                    <h4>添加注释和文档</h4>
                                    <p>复杂的正则表达式应该添加注释说明其用途和匹配规则</p>
                                    <pre><code class="language-java">/**
 * 匹配中国大陆手机号码
 * 格式：1[3-9]xxxxxxxxx (11位数字，以1开头，第二位为3-9)
 */
private static final Pattern PHONE_PATTERN = 
    Pattern.compile("^1[3-9]\\d{9}$");</code></pre>
                                </div>
                            </div>
                            <div class="practice-item">
                                <span class="practice-icon">🎨</span>
                                <div>
                                    <h4>使用命名分组</h4>
                                    <p>对于复杂的匹配，使用命名分组提高可读性</p>
                                    <pre><code class="language-java">// 使用命名分组解析日期
Pattern datePattern = Pattern.compile(
    "(?&lt;year&gt;\\d{4})-(?&lt;month&gt;\\d{2})-(?&lt;day&gt;\\d{2})"
);

Matcher matcher = datePattern.matcher("2023-12-25");
if (matcher.matches()) {
    String year = matcher.group("year");
    String month = matcher.group("month");
    String day = matcher.group("day");
}</code></pre>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 17: Pattern.quote Deep Dive -->
        <section class="slide">
            <div class="slide-content">
                <h2>Pattern.quote() 深度解析</h2>
                <p>深入理解Pattern.quote()的工作原理、使用场景和最佳实践，掌握字面量匹配的核心技巧。</p>

                <div class="quote-theory">
                    <h3>🔧 Pattern.quote() 工作原理</h3>
                    <div class="principle-grid">
                        <div class="principle-item">
                            <h4>核心功能</h4>
                            <p>将任意字符串转换为正则表达式字面量，禁用所有元字符的特殊含义</p>
                            <pre><code class="language-java">// 原始字符串包含元字符
String userInput = "$100.50 (20% off)";

// 直接使用会出错
Pattern wrong = Pattern.compile(userInput);  // 错误：$和.被当作元字符

// 使用quote()安全处理
Pattern correct = Pattern.compile(Pattern.quote(userInput));  // 正确：字面量匹配</code></pre>
                        </div>
                        <div class="principle-item">
                            <h4>转换机制</h4>
                            <p>在字符串前后添加 \Q 和 \E 标记，创建字面量区域</p>
                            <pre><code class="language-java">String input = "Hello.World$123";
String quoted = Pattern.quote(input);
System.out.println(quoted);
// 输出: \QHello.World$123\E

// 等价于手动添加转义标记
String manual = "\\Q" + input + "\\E";</code></pre>
                        </div>
                    </div>
                </div>

                <div class="quote-scenarios">
                    <h3>🎯 使用场景详解</h3>
                    
                    <div class="scenario-section">
                        <h4>1. 用户输入安全处理</h4>
                        <div class="scenario-demo">
                            <div class="demo-problem">
                                <strong>❌ 危险做法</strong>
                                <pre><code class="language-java">public boolean searchInText(String text, String userQuery) {
    // 危险：用户输入可能包含正则元字符
    Pattern pattern = Pattern.compile(userQuery);
    return pattern.matcher(text).find();
}

// 用户输入 ".*" 会匹配所有内容
// 用户输入 "(a+)+" 可能导致回溯爆炸</code></pre>
                            </div>
                            <div class="demo-solution">
                                <strong>✅ 安全做法</strong>
                                <pre><code class="language-java">public boolean searchInText(String text, String userQuery) {
    // 安全：将用户输入作为字面量处理
    Pattern pattern = Pattern.compile(Pattern.quote(userQuery));
    return pattern.matcher(text).find();
}

// 用户输入 ".*" 只匹配字面量 ".*"
// 完全避免正则注入攻击</code></pre>
                            </div>
                        </div>
                    </div>

                    <div class="scenario-section">
                        <h4>2. 配置文件和模板处理</h4>
                        <pre><code class="language-java">public class ConfigProcessor {
    public String replaceVariables(String template, Map&lt;String, String&gt; variables) {
        String result = template;
        
        for (Map.Entry&lt;String, String&gt; entry : variables.entrySet()) {
            String placeholder = "${" + entry.getKey() + "}";
            String value = entry.getValue();
            
            // 安全替换：placeholder和value都作为字面量
            result = result.replaceAll(
                Pattern.quote(placeholder), 
                Matcher.quoteReplacement(value)
            );
        }
        
        return result;
    }
}

// 使用示例
Map&lt;String, String&gt; vars = new HashMap&lt;&gt;();
vars.put("price", "$100.50");  // 包含特殊字符
vars.put("discount", "20%");   // 包含特殊字符

String template = "Price: ${price}, Discount: ${discount}";
String result = processor.replaceVariables(template, vars);
// 输出: "Price: $100.50, Discount: 20%"</code></pre>
                    </div>

                    <div class="scenario-section">
                        <h4>3. 文件路径和URL处理</h4>
                        <pre><code class="language-java">public class PathMatcher {
    public boolean isPathAllowed(String requestPath, List&lt;String&gt; allowedPaths) {
        for (String allowedPath : allowedPaths) {
            // 精确匹配路径，避免路径遍历攻击
            Pattern pattern = Pattern.compile("^" + Pattern.quote(allowedPath) + "$");
            if (pattern.matcher(requestPath).matches()) {
                return true;
            }
        }
        return false;
    }
}

// 安全示例
List&lt;String&gt; allowed = Arrays.asList(
    "/api/users",
    "/static/css/style.css",
    "/images/logo.png"
);

// 这些会被正确拒绝
// "/api/users/../admin"  - 路径遍历尝试
// "/api/users.backup"   - 类似路径但不完全匹配</code></pre>
                    </div>
                </div>

                <div class="quote-advanced">
                    <h3>🚀 高级技巧与组合使用</h3>
                    
                    <div class="advanced-section">
                        <h4>1. 部分字面量匹配</h4>
                        <pre><code class="language-java">public class SmartMatcher {
    public Pattern createFlexiblePattern(String prefix, String literalPart, String suffix) {
        // 组合：正则表达式 + 字面量 + 正则表达式
        String pattern = prefix + Pattern.quote(literalPart) + suffix;
        return Pattern.compile(pattern);
    }
}

// 示例：匹配包含特定字面量的邮箱
Pattern emailPattern = smartMatcher.createFlexiblePattern(
    "\\w+",                    // 正则：用户名
    "@company.com",            // 字面量：特定域名
    "$"                        // 正则：行结束
);

// 匹配: "john@company.com", "admin@company.com"
// 不匹配: "john@company.com.evil.com" (防止域名欺骗)</code></pre>
                    </div>

                    <div class="advanced-section">
                        <h4>2. 动态模式构建</h4>
                        <pre><code class="language-java">public class DynamicPatternBuilder {
    public Pattern buildSearchPattern(List&lt;String&gt; keywords, boolean caseSensitive) {
        StringBuilder patternBuilder = new StringBuilder();
        
        for (int i = 0; i &lt; keywords.size(); i++) {
            if (i &gt; 0) {
                patternBuilder.append("|");  // OR操作符
            }
            // 每个关键词都作为字面量处理
            patternBuilder.append(Pattern.quote(keywords.get(i)));
        }
        
        int flags = caseSensitive ? 0 : Pattern.CASE_INSENSITIVE;
        return Pattern.compile(patternBuilder.toString(), flags);
    }
}

// 使用示例
List&lt;String&gt; keywords = Arrays.asList("C++", "C#", ".NET", "Java");
Pattern pattern = builder.buildSearchPattern(keywords, false);

// 安全匹配这些包含特殊字符的技术关键词</code></pre>
                    </div>
                </div>

                <div class="quote-performance">
                    <h3>⚡ 性能考虑与最佳实践</h3>
                    <div class="performance-grid">
                        <div class="performance-item">
                            <h4>性能优化</h4>
                            <pre><code class="language-java">public class OptimizedMatcher {
    // 缓存编译后的模式
    private final Map&lt;String, Pattern&gt; patternCache = new ConcurrentHashMap&lt;&gt;();
    
    public boolean matches(String text, String literal) {
        Pattern pattern = patternCache.computeIfAbsent(literal, 
            key -&gt; Pattern.compile(Pattern.quote(key)));
        return pattern.matcher(text).find();
    }
}</code></pre>
                        </div>
                        <div class="performance-item">
                            <h4>内存优化</h4>
                            <pre><code class="language-java">// 对于简单的字面量匹配，考虑使用String方法
public boolean containsLiteral(String text, String literal) {
    // 更高效的字面量搜索
    return text.contains(literal);
}

// 只在需要正则功能时使用Pattern.quote()
public boolean matchesWithBoundary(String text, String literal) {
    String pattern = "\\b" + Pattern.quote(literal) + "\\b";
    return Pattern.compile(pattern).matcher(text).find();
}</code></pre>
                        </div>
                    </div>
                </div>

                <div class="quote-interactive">
                    <h3>🧪 Pattern.quote() 演示</h3>
                    <div class="quote-tester">
                        <div class="input-section">
                            <label>输入字符串（可包含特殊字符）：</label>
                            <input type="text" id="quoteInput" placeholder="例如：$100.50 (20% off)" value="$100.50 (20% off)">
                        </div>
                        <div class="input-section">
                            <label>测试文本：</label>
                            <textarea id="quoteTestText" placeholder="输入要搜索的文本...">商品价格：$100.50 (20% off)
特价商品：$99.99 (10% off)
原价：$100.50</textarea>
                        </div>
                        <button onclick="testQuote()" class="test-button">测试 Pattern.quote() 效果</button>
                        <div id="quoteResults" class="results-display"></div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 18: Backtracking Catastrophe Deep Dive -->
        <section class="slide">
            <div class="slide-content">
                <h2>🔥 回溯爆炸深度解析</h2>
                
                <div class="backtrack-theory">
                    <h3>🧠 什么是回溯爆炸？</h3>
                    <div class="concept-grid">
                        <div class="concept-item">
                            <h4>定义</h4>
                            <p>正则表达式引擎在匹配失败时，会回退并尝试其他可能的匹配路径。当这种回退过程呈指数级增长时，就发生了回溯爆炸。</p>
                        </div>
                        <div class="concept-item">
                            <h4>时间复杂度</h4>
                            <p>正常情况：O(n)<br>回溯爆炸：O(2^n) 或更糟</p>
                        </div>
                    </div>
                </div>

                <div class="dangerous-patterns">
                    <h3>⚠️ 危险模式识别</h3>
                    <div class="pattern-grid">
                        <div class="pattern-item danger">
                            <h4>嵌套量词</h4>
                            <pre><code class="language-regex">(a+)+b
(a*)*b
(a+)+$</code></pre>
                            <p class="danger-level">危险级别: 🔴 极高</p>
                        </div>
                        <div class="pattern-item warning">
                            <h4>交替分支重叠</h4>
                            <pre><code class="language-regex">(a|a)*b
(ab|a)*b
(.*|.+)x</code></pre>
                            <p class="danger-level">危险级别: 🟡 中等</p>
                        </div>
                        <div class="pattern-item caution">
                            <h4>贪婪量词链</h4>
                            <pre><code class="language-regex">.*.*.*x
.+.+.+y</code></pre>
                            <p class="danger-level">危险级别: 🟠 较高</p>
                        </div>
                    </div>
                </div>

                <div class="backtrack-demo">
                    <h3>🔍 回溯过程可视化</h3>
                    <div class="demo-container">
                        <div class="demo-input">
                            <label>测试字符串:</label>
                            <input type="text" id="backtrackText" value="aaaaaaaaaaaaaaaaaaaaaaaaaaab" placeholder="输入测试字符串">
                        </div>
                        <div class="demo-patterns">
                            <div class="pattern-test">
                                <h4>危险模式: (a+)+b</h4>
                                <button onclick="testBacktracking('dangerous')">测试回溯</button>
                                <div id="dangerousResult" class="result-area"></div>
                            </div>
                            <div class="pattern-test">
                                <h4>安全模式: a+b</h4>
                                <button onclick="testBacktracking('safe')">测试匹配</button>
                                <div id="safeResult" class="result-area"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="solution-strategies">
                    <h3>🛡️ 解决策略</h3>
                    <div class="strategy-grid">
                        <div class="strategy-item">
                            <h4>1. 原子分组 (?>...)</h4>
                            <div class="before-after">
                                <div class="before">
                                    <strong>危险:</strong>
                                    <pre><code>(a+)+b</code></pre>
                                </div>
                                <div class="after">
                                    <strong>安全:</strong>
                                    <pre><code>(?>a+)b</code></pre>
                                </div>
                            </div>
                            <p>原子分组一旦匹配成功就不会回溯</p>
                        </div>
                        
                        <div class="strategy-item">
                            <h4>2. 占有量词 +, *, ?</h4>
                            <div class="before-after">
                                <div class="before">
                                    <strong>危险:</strong>
                                    <pre><code>.*+.*+x</code></pre>
                                </div>
                                <div class="after">
                                    <strong>安全:</strong>
                                    <pre><code>.*+x</code></pre>
                                </div>
                            </div>
                            <p>占有量词不会释放已匹配的字符</p>
                        </div>
                        
                        <div class="strategy-item">
                            <h4>3. 具体化模式</h4>
                            <div class="before-after">
                                <div class="before">
                                    <strong>模糊:</strong>
                                    <pre><code>(.*)*</code></pre>
                                </div>
                                <div class="after">
                                    <strong>具体:</strong>
                                    <pre><code>[a-zA-Z0-9]*</code></pre>
                                </div>
                            </div>
                            <p>使用具体的字符类替代通配符</p>
                        </div>
                        
                        <div class="strategy-item">
                            <h4>4. 边界锚定</h4>
                            <div class="before-after">
                                <div class="before">
                                    <strong>无界:</strong>
                                    <pre><code>(a+)+</code></pre>
                                </div>
                                <div class="after">
                                    <strong>有界:</strong>
                                    <pre><code>^(a+)+$</code></pre>
                                </div>
                            </div>
                            <p>明确匹配边界减少回溯可能</p>
                        </div>
                    </div>
                </div>

                <div class="performance-tips">
                    <h3>⚡ 性能监控与调试</h3>
                    <div class="monitoring-code">
                        <pre><code class="language-java">// 性能监控示例
public class RegexPerformanceMonitor {
    public static void testPattern(String pattern, String text) {
        long startTime = System.nanoTime();
        
        try {
            Pattern p = Pattern.compile(pattern);
            Matcher m = p.matcher(text);
            boolean found = m.find();
            
            long endTime = System.nanoTime();
            long duration = (endTime - startTime) / 1_000_000; // 转换为毫秒
            
            System.out.printf("模式: %s%n", pattern);
            System.out.printf("匹配结果: %s%n", found);
            System.out.printf("执行时间: %d ms%n", duration);
            
            if (duration > 100) {
                System.out.println("⚠️ 警告：执行时间过长，可能存在回溯问题");
            }
        } catch (Exception e) {
            System.out.println("❌ 模式编译失败: " + e.getMessage());
        }
    }
}</code></pre>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 19: Common Pitfalls and Performance -->
        <section class="slide">
            <div class="slide-content">
                <h2>常见陷阱与性能优化</h2>

                <div class="pitfalls-performance">
                    <div class="practice-section">
                        <h3>⚠️ 常见陷阱</h3>
                        <div class="pitfall-list">
                            <div class="pitfall-item">
                                <h4>贪婪匹配问题</h4>
                                <p><code>.*</code> 会尽可能多地匹配字符，使用 <code>.*?</code> 进行非贪婪匹配</p>
                                <pre><code class="language-java">String html = "&lt;div&gt;content&lt;/div&gt;&lt;div&gt;more&lt;/div&gt;";

// 贪婪：匹配整个字符串 (错误)
html.replaceAll("&lt;.*&gt;", "");  // 结果: ""

// 非贪婪：匹配单个标签 (正确)
html.replaceAll("&lt;.*?&gt;", "");  // 结果: "contentmore"</code></pre>
                            </div>
                            <div class="pitfall-item">
                                <h4>转义字符混乱</h4>
                                <p>Java字符串中的反斜杠需要双重转义</p>
                                <pre><code class="language-java">// 错误：编译时报错
Pattern.compile("\d+");

// 正确：双重转义
Pattern.compile("\\d+");

// 或使用字符类
Pattern.compile("[0-9]+");</code></pre>
                            </div>
                            <div class="pitfall-item">
                                <h4>回溯爆炸</h4>
                                <p>复杂的正则表达式可能导致回溯爆炸，影响性能</p>
                                <pre><code class="language-java">// 危险：可能导致性能问题
Pattern.compile("(a+)+b");

// 安全：更好的选择
Pattern.compile("a+b");

// 使用原子分组避免回溯
Pattern.compile("(?>a+)b");</code></pre>
                            </div>
                            <div class="pitfall-item">
                                <h4>边界匹配误用</h4>
                                <p>混淆字符串边界和单词边界</p>
                                <pre><code class="language-java">String text = "hello world";

// 字符串边界
Pattern.compile("^hello").matcher(text).find();  // true

// 单词边界
Pattern.compile("\\bhello\\b").matcher(text).find();  // true
Pattern.compile("\\bworld\\b").matcher(text).find();  // true</code></pre>
                            </div>
                        </div>
                    </div>

                    <div class="practice-section">
                        <h3>🚀 性能优化建议</h3>
                        <div class="tip-grid">
                            <div class="tip-item">
                                <h4>使用具体字符类</h4>
                                <p>用 <code>[0-9]</code> 替代 <code>\d</code> 在某些情况下更快</p>
                                <pre><code class="language-java">// 更快的数字匹配
Pattern.compile("[0-9]+");
// 而不是
Pattern.compile("\\d+");</code></pre>
                            </div>
                            <div class="tip-item">
                                <h4>避免过度使用分组</h4>
                                <p>不需要捕获时使用非捕获组 <code>(?:...)</code></p>
                                <pre><code class="language-java">// 非捕获分组，性能更好
Pattern.compile("(?:abc|def)+");
// 而不是
Pattern.compile("(abc|def)+");</code></pre>
                            </div>
                            <div class="tip-item">
                                <h4>锚定匹配</h4>
                                <p>使用 <code>^</code> 和 <code>$</code> 限制匹配范围</p>
                                <pre><code class="language-java">// 精确匹配，避免不必要的搜索
Pattern.compile("^\\d{3}-\\d{2}-\\d{4}$");
// 而不是
Pattern.compile("\\d{3}-\\d{2}-\\d{4}");</code></pre>
                            </div>
                            <div class="tip-item">
                                <h4>预编译和重用</h4>
                                <p>重复使用的正则表达式应该预编译并缓存</p>
                                <pre><code class="language-java">// 使用静态常量
private static final Pattern PATTERN = 
    Pattern.compile("regex");

// 或使用缓存
private static final Map&lt;String, Pattern&gt; 
    PATTERN_CACHE = new ConcurrentHashMap&lt;&gt;();</code></pre>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 20: Summary -->
        <section class="slide">
            <div class="slide-content">
                <h2>总结</h2>
                
                <div class="summary-container">
                    <div class="summary-section">
                        <h3>🎯 核心知识点</h3>
                        <div class="knowledge-points">
                            <div class="point-item">
                                <span class="point-number">1</span>
                                <div>
                                    <h4>正则表达式语法</h4>
                                    <p>掌握字符类、量词、边界匹配等基础语法</p>
                                </div>
                            </div>
                            <div class="point-item">
                                <span class="point-number">2</span>
                                <div>
                                    <h4>Java API使用</h4>
                                    <p>熟练使用Pattern和Matcher类进行文本处理</p>
                                </div>
                            </div>
                            <div class="point-item">
                                <span class="point-number">3</span>
                                <div>
                                    <h4>实际应用</h4>
                                    <p>能够编写验证、提取、替换等实用功能</p>
                                </div>
                            </div>
                            <div class="point-item">
                                <span class="point-number">4</span>
                                <div>
                                    <h4>性能优化</h4>
                                    <p>了解最佳实践，避免常见性能陷阱</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="summary-section">
                        <h3>💡 学习建议</h3>
                        <div class="learning-tips">
                            <div class="tip">
                                <span class="tip-icon">📖</span>
                                <p><strong>多练习：</strong>正则表达式需要大量练习才能熟练掌握</p>
                            </div>
                            <div class="tip">
                                <span class="tip-icon">🔧</span>
                                <p><strong>使用工具：</strong>利用在线正则表达式测试工具验证表达式</p>
                            </div>
                            <div class="tip">
                                <span class="tip-icon">📚</span>
                                <p><strong>查阅文档：</strong>遇到复杂需求时查阅Java正则表达式文档</p>
                            </div>
                            <div class="tip">
                                <span class="tip-icon">🎯</span>
                                <p><strong>实际应用：</strong>在项目中寻找使用正则表达式的机会</p>
                            </div>
                        </div>
                    </div>

                    <div class="summary-section">
                        <h3>🚀 下一步学习</h3>
                        <div class="next-steps">
                            <div class="step">高级正则表达式特性（前瞻、后顾断言）</div>
                            <div class="step">正则表达式在不同编程语言中的差异</div>
                            <div class="step">文本处理和数据清洗实战项目</div>
                            <div class="step">正则表达式性能调优技巧</div>
                        </div>
                    </div>
                </div>

                <div class="final-message">
                    <h3>🎉 恭喜完成学习！</h3>
                    <p>正则表达式是程序员的重要工具，掌握它将大大提高你的文本处理能力。继续练习，在实际项目中应用所学知识！</p>
                </div>
            </div>
        </section>



        <!-- UI Elements -->
        <div class="progress-bar-container">
            <div id="progress-bar"></div>
        </div>
        <div class="controls">
            <button id="prevBtn">上一页</button>
            <span id="slide-counter">1 / X</span>
            <button id="nextBtn">下一页</button>
        </div>
    </main>

    <style>
        /* 正则表达式教学专用样式 */
        .title-decoration {
            margin-top: 2rem;
            display: flex;
            justify-content: center;
            gap: 2rem;
            flex-wrap: wrap;
        }

        .regex-symbol {
            background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            animation: float 3s ease-in-out infinite;
        }

        .regex-symbol:nth-child(2) {
            animation-delay: 1s;
        }

        .regex-symbol:nth-child(3) {
            animation-delay: 2s;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        .concept-illustration {
            margin: 2rem 0;
        }

        .analogy-box {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 1.5rem;
            border-radius: 12px;
            border-left: 4px solid #667eea;
        }

        .analogy-box h3 {
            margin-top: 0;
            color: #333;
        }

        .key-features {
            margin: 2rem 0;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin-top: 1rem;
        }

        .feature-item {
            background: white;
            padding: 1.5rem;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .feature-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 30px rgba(0,0,0,0.15);
        }

        .feature-icon {
            font-size: 2rem;
            display: block;
            margin-bottom: 0.5rem;
        }

        .feature-item h4 {
            margin: 0.5rem 0;
            color: #333;
        }

        .feature-item p {
            margin: 0;
            color: #666;
            font-size: 0.9rem;
        }

        .syntax-table {
            margin: 2rem 0;
        }

        .syntax-table h3 {
            color: #333;
            margin-bottom: 1rem;
        }

        .syntax-table table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        .syntax-table th,
        .syntax-table td {
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        .syntax-table th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: bold;
        }

        .syntax-table tr:hover {
            background: #f8f9ff;
        }

        .syntax-table code {
            background: #f1f3f4;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            color: #d73a49;
        }

        .syntax-section {
            margin: 2rem 0;
        }

        .example-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .example-item {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            border-left: 4px solid #667eea;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .example-item code {
            display: block;
            background: #f8f9fa;
            padding: 0.5rem;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            color: #d73a49;
            margin-bottom: 0.5rem;
        }

        .boundary-examples {
            margin-top: 1rem;
        }

        .boundary-item {
            display: grid;
            grid-template-columns: auto 1fr auto;
            gap: 1rem;
            padding: 1rem;
            background: white;
            margin-bottom: 0.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            align-items: center;
        }

        .boundary-item code {
            background: #f1f3f4;
            padding: 0.3rem 0.6rem;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            color: #d73a49;
            font-weight: bold;
        }

        .boundary-item .description {
            color: #333;
            font-weight: 500;
        }

        .boundary-item .example {
            color: #666;
            font-size: 0.9rem;
            font-family: 'Courier New', monospace;
        }

        .practical-example {
            margin: 2rem 0;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            padding: 1.5rem;
            border-radius: 12px;
            color: white;
        }

        .practical-example h3 {
            margin-top: 0;
            color: white;
        }

        .example-showcase {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .showcase-item {
            background: rgba(255,255,255,0.1);
            padding: 1rem;
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }

        .showcase-item strong {
            display: block;
            margin-bottom: 0.5rem;
        }

        .showcase-item code {
            background: rgba(255,255,255,0.2);
            padding: 0.3rem 0.6rem;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            word-break: break-all;
        }

        .java-regex-classes {
            display: flex;
            flex-direction: column;
            gap: 2rem;
            margin: 2rem 0;
        }

        .class-explanation {
            background: white;
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        .class-explanation h3 {
            margin-top: 0;
            color: #333;
        }

        .class-explanation pre {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
            margin: 1rem 0 0 0;
        }

        /* String方法介绍样式 */
        .string-methods-intro {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2rem;
            border-radius: 15px;
            margin: 2rem 0;
        }

        .method-explanation {
            background: white;
            color: #333;
            padding: 1.5rem;
            border-radius: 12px;
            margin: 1rem 0;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .method-explanation h4 {
            margin-top: 0;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 0.5rem;
        }

        .method-explanation pre {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
            margin: 1rem 0;
            border-left: 4px solid #3498db;
        }

        .string-limitations {
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
            padding: 2rem;
            border-radius: 15px;
            margin: 2rem 0;
        }

        .limitation-examples {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-top: 1rem;
        }

        .limitation-item {
            background: white;
            padding: 1.5rem;
            border-radius: 10px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }

        .limitation-item h5 {
            margin-top: 0;
            color: #e74c3c;
            font-size: 1.1rem;
        }

        .limitation-item pre {
             background: #f8f9fa;
             padding: 1rem;
             border-radius: 6px;
             margin: 0.5rem 0;
             font-size: 0.9rem;
         }

         /* 实践示例样式 */
         .practical-example {
             background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
             color: white;
             padding: 2rem;
             border-radius: 15px;
             margin: 2rem 0;
         }

         .practical-example h3 {
             margin-top: 0;
             color: white;
         }

         .practical-example pre {
             background: rgba(255,255,255,0.1);
             border: 1px solid rgba(255,255,255,0.2);
             padding: 1.5rem;
             border-radius: 10px;
             overflow-x: auto;
             margin: 1rem 0;
         }

         .practical-example code {
             color: #f8f9fa;
         }

         .common-methods {
            margin: 2rem 0;
        }

        .method-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .method-item {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .method-item:hover {
            transform: translateY(-3px);
        }

        .method-item code {
            display: block;
            background: #f1f3f4;
            padding: 0.5rem;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            color: #d73a49;
            margin-bottom: 0.5rem;
        }

        .example-container {
            margin: 2rem 0;
            background: white;
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        .example-container h3 {
            margin-top: 0;
            color: #333;
        }

        .example-container pre {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
            margin: 1rem 0 0 0;
        }

        .advanced-feature {
            margin: 2rem 0;
            background: white;
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        .advanced-feature h3 {
            margin-top: 0;
            color: #333;
        }

        .flag-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .flag-item {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .flag-item code {
            display: block;
            background: white;
            padding: 0.5rem;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            color: #d73a49;
            margin-bottom: 0.5rem;
        }

        .regex-exercise {
            background: white;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            margin: 2rem 0;
        }

        .exercise-container {
            margin-bottom: 2rem;
        }

        .test-area {
            background: #f8f9fa;
            padding: 1.5rem;
            border-radius: 8px;
            margin-top: 1rem;
        }

        .input-group {
            margin-bottom: 1rem;
        }

        .input-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: bold;
            color: #333;
        }

        .input-group input,
        .input-group textarea {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            transition: border-color 0.3s ease;
        }

        .input-group input:focus,
        .input-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .input-group textarea {
            height: 100px;
            resize: vertical;
        }

        .test-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        .test-btn:hover {
            transform: translateY(-2px);
        }

        .result-area {
            margin-top: 1rem;
            min-height: 50px;
        }

        .result-area .success {
            background: #d4edda;
            color: #155724;
            padding: 1rem;
            border-radius: 6px;
            border-left: 4px solid #28a745;
        }

        .result-area .no-match {
            background: #f8d7da;
            color: #721c24;
            padding: 1rem;
            border-radius: 6px;
            border-left: 4px solid #dc3545;
        }

        .result-area .error {
            background: #fff3cd;
            color: #856404;
            padding: 1rem;
            border-radius: 6px;
            border-left: 4px solid #ffc107;
        }

        .challenge-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .challenge-item {
            background: #f8f9fa;
            padding: 1.5rem;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .challenge-item h4 {
            margin-top: 0;
            color: #333;
        }

        .challenge-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .challenge-btn:hover {
            background: #5a67d8;
        }

        .best-practices {
            margin: 2rem 0;
        }

        .practice-section {
            margin: 2rem 0;
        }

        .practice-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .practice-item {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .practice-icon {
            font-size: 1.5rem;
            flex-shrink: 0;
        }

        .practice-item h4 {
            margin: 0 0 0.5rem 0;
            color: #333;
        }

        .practice-item p {
            margin: 0;
            color: #666;
        }

        .pitfall-list {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .pitfall-item {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            border-left: 4px solid #ffc107;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .pitfall-item h4 {
            margin-top: 0;
            color: #333;
        }

        .pitfall-item pre {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 6px;
            overflow-x: auto;
            margin: 1rem 0 0 0;
        }

        .performance-tips {
            margin: 2rem 0;
        }

        .tip-grid {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            margin-top: 1rem;
        }

        .tip-item {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-left: 4px solid var(--primary-color);
        }

        .tip-item h4 {
            margin-top: 0;
            color: #333;
        }

        .tip-item p {
            margin: 0;
            color: #666;
        }

        .summary-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin: 2rem 0;
        }

        .summary-section {
            background: white;
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        .summary-section h3 {
            margin-top: 0;
            color: #333;
        }

        .knowledge-points {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .point-item {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
        }

        .point-number {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            width: 2rem;
            height: 2rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            flex-shrink: 0;
        }

        .point-item h4 {
            margin: 0 0 0.5rem 0;
            color: #333;
        }

        .point-item p {
            margin: 0;
            color: #666;
        }

        .learning-tips {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .tip {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
        }

        .tip-icon {
            font-size: 1.5rem;
            flex-shrink: 0;
        }

        .tip p {
            margin: 0;
            color: #666;
        }

        .next-steps {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .step {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 6px;
            border-left: 4px solid #667eea;
            color: #333;
        }

        .final-message {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2rem;
            border-radius: 12px;
            text-align: center;
            margin-top: 2rem;
        }

        .final-message h3 {
            margin-top: 0;
            color: white;
        }

        .final-message p {
            margin: 0;
            font-size: 1.1rem;
        }

        /* 响应式设计 */
        @media (max-width: 768px) {
            .feature-grid {
                grid-template-columns: 1fr;
            }
            
            .java-regex-classes {
                grid-template-columns: 1fr;
            }
            
            .summary-container {
                grid-template-columns: 1fr;
            }
            
            .challenge-list {
                grid-template-columns: 1fr;
            }
            
            .boundary-item {
                grid-template-columns: 1fr;
                gap: 0.5rem;
            }
            
            .title-decoration {
                gap: 1rem;
            }
        }

        /* FSM理论相关样式 */
        .fsm-theory {
            margin: 2rem 0;
        }

        .theory-section {
            margin: 2rem 0;
            padding: 1.5rem;
            background: #f8f9fa;
            border-radius: 12px;
            border-left: 4px solid #667eea;
        }

        .fsm-definition ul {
            list-style: none;
            padding: 0;
        }

        .fsm-definition li {
            padding: 0.5rem 0;
            border-bottom: 1px solid #e9ecef;
        }

        .fsm-definition li:last-child {
            border-bottom: none;
        }

        .fsm-diagram {
            margin: 1.5rem 0;
            padding: 2rem;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .state-machine {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .state {
            width: 60px;
            height: 60px;
            border: 3px solid #667eea;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
            font-weight: bold;
            color: #333;
            text-align: center;
            line-height: 1.2;
            transition: all 0.3s ease;
        }

        .state.start-state {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .state.accept-state {
            border: 3px double #28a745;
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
        }

        .state.active {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.6);
        }

        .transition {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #667eea;
            padding: 0.5rem;
            background: #f8f9fa;
            border-radius: 4px;
            border: 1px solid #dee2e6;
        }

        .loop-transition {
            position: absolute;
            margin-top: -80px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #28a745;
            font-size: 1.2rem;
        }

        .state-machine.complex {
            position: relative;
        }

        .fsm-explanation-text {
            margin-top: 1rem;
            padding: 1rem;
            background: #e3f2fd;
            border-radius: 8px;
        }

        .fsm-explanation-text ol {
            margin: 0.5rem 0;
        }

        .fsm-features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .feature-point {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            padding: 1rem;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .feature-point .feature-icon {
            font-size: 1.5rem;
            margin-top: 0.2rem;
        }

        .feature-point h5 {
            margin: 0 0 0.5rem 0;
            color: #333;
        }

        .feature-point p {
            margin: 0;
            color: #666;
            font-size: 0.9rem;
        }

        .importance-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .importance-item {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            padding: 1.5rem;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .importance-item:hover {
            transform: translateY(-3px);
        }

        .importance-icon {
            font-size: 1.5rem;
            margin-top: 0.2rem;
        }

        .importance-item h4 {
            margin: 0 0 0.5rem 0;
            color: #333;
        }

        .importance-item p {
            margin: 0;
            color: #666;
            font-size: 0.9rem;
        }

        .interactive-demo {
            margin: 2rem 0;
            padding: 1.5rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            color: white;
        }

        .demo-controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .demo-controls input {
            flex: 1;
            min-width: 200px;
            padding: 0.5rem;
            border: none;
            border-radius: 4px;
            font-size: 1rem;
        }

        .demo-controls button {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 4px;
            background: white;
            color: #667eea;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .demo-controls button:hover {
            background: #f8f9fa;
            transform: translateY(-2px);
        }

        .demo-result {
            padding: 1rem;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            min-height: 50px;
            font-family: 'Courier New', monospace;
        }

        /* 贪婪匹配相关样式 */
        .greedy-theory {
            margin: 2rem 0;
        }

        .mechanism-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-top: 1rem;
        }

        .mechanism-item {
            padding: 1.5rem;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border-left: 4px solid #667eea;
        }

        .mechanism-item h4 {
            margin: 0 0 1rem 0;
            color: #333;
            font-size: 1.2rem;
        }

        .mechanism-item p {
            margin: 0.5rem 0;
            color: #666;
        }

        .example-box {
            margin-top: 1rem;
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 3px solid #28a745;
        }

        .example-box p {
            margin: 0.3rem 0;
            font-size: 0.9rem;
        }

        .greedy-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .greedy-table th {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 1rem;
            text-align: left;
            font-weight: bold;
        }

        .greedy-table td {
            padding: 0.8rem 1rem;
            border-bottom: 1px solid #e9ecef;
        }

        .greedy-table tr:hover {
            background: #f8f9fa;
        }

        .greedy-table code {
            background: #e3f2fd;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }

        .demo-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5rem;
            margin-top: 1rem;
        }

        .demo-case {
            padding: 1.5rem;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .demo-case h4 {
            margin: 0 0 1rem 0;
            color: #333;
            border-bottom: 2px solid #667eea;
            padding-bottom: 0.5rem;
        }

        .demo-content p {
            margin: 0.5rem 0;
            font-size: 0.9rem;
        }

        .result-bad {
            color: #dc3545;
            background: #f8d7da;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }

        .result-good {
            color: #28a745;
            background: #d4edda;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }

        .performance-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-top: 1rem;
        }

        .performance-item {
            padding: 1.5rem;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .performance-item h4 {
            margin: 0 0 1rem 0;
            color: #333;
        }

        .performance-item ul {
            margin: 1rem 0;
            padding-left: 1.5rem;
        }

        .performance-item li {
            margin: 0.5rem 0;
            color: #666;
        }

        /* 回溯爆炸相关样式 */
        .backtrack-theory {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .concept-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 15px;
        }

        .concept-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #feca57;
        }

        .dangerous-patterns {
            margin: 20px 0;
        }

        .pattern-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .pattern-item {
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid;
        }

        .pattern-item.danger {
            background: #ffe6e6;
            border-left-color: #e74c3c;
        }

        .pattern-item.warning {
            background: #fff3cd;
            border-left-color: #f39c12;
        }

        .pattern-item.caution {
            background: #fff0e6;
            border-left-color: #ff7675;
        }

        .danger-level {
            font-weight: bold;
            margin-top: 10px;
        }

        .backtrack-demo {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .demo-container {
            margin-top: 15px;
        }

        .demo-input {
            margin-bottom: 20px;
        }

        .demo-input label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .demo-input input {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
        }

        .demo-patterns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .pattern-test {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #ddd;
        }

        .pattern-test button {
            background: #3498db;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
        }

        .pattern-test button:hover {
            background: #2980b9;
        }

        .result-area {
            margin-top: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            min-height: 40px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .solution-strategies {
            margin: 20px 0;
        }

        .strategy-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 15px;
        }

        .strategy-item {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #27ae60;
        }

        .before-after {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 15px 0;
        }

        .before, .after {
            padding: 10px;
            border-radius: 5px;
        }

        .before {
            background: #ffe6e6;
            border-left: 3px solid #e74c3c;
        }

        .after {
            background: #e8f5e8;
            border-left: 3px solid #27ae60;
        }

        .performance-tips {
            background: #e8f4f8;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .monitoring-code {
            margin-top: 15px;
        }

        /* Unicode相关样式 */
        .unicode-theory {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .unicode-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 15px;
        }

        .unicode-category {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #feca57;
        }

        .category-details {
            margin-top: 10px;
        }

        .category-item {
            margin-bottom: 10px;
        }

        .subcategories {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-top: 8px;
            padding-left: 15px;
        }

        .subcategories span {
            font-size: 0.9em;
            background: rgba(255, 255, 255, 0.1);
            padding: 3px 8px;
            border-radius: 4px;
        }

        .script-blocks {
            margin: 20px 0;
        }

        .script-grid {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 15px;
        }

        .script-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #28a745;
        }

        .script-item h4 {
            margin: 0 0 10px 0;
            color: #333;
        }

        .posix-classes {
            margin: 20px 0;
        }

        .unicode-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .unicode-table th {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: bold;
        }

        .unicode-table td {
            padding: 10px 12px;
            border-bottom: 1px solid #eee;
        }

        .unicode-table tr:nth-child(even) {
            background: #f8f9fa;
        }

        .unicode-table code {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }

        .unicode-demo {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .demo-input-group {
            margin-bottom: 20px;
        }

        .demo-input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .demo-input-group input {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
        }

        .demo-patterns {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        .pattern-demo {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #ddd;
        }

        .pattern-demo h4 {
            margin: 0 0 10px 0;
            color: #333;
        }

        .pattern-demo button {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin-bottom: 10px;
        }

        .pattern-demo button:hover {
            background: #218838;
        }

        .practical-unicode {
            margin: 20px 0;
        }

        .application-grid {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 15px;
        }

        .app-item {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #17a2b8;
        }

        .app-item h4 {
            margin: 0 0 15px 0;
            color: #333;
        }

        /* 标志演示样式 */
        .flags-theory {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 15px;
            margin: 20px 0;
        }

        .flag-categories {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 20px;
        }

        .flag-category {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .flag-category h4 {
            color: #ffd700;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .flag-category ul {
            list-style: none;
            padding: 0;
        }

        .flag-category li {
            margin: 10px 0;
            padding-left: 20px;
            position: relative;
        }

        .flag-category li::before {
            content: "🔸";
            position: absolute;
            left: 0;
        }

        .flag-demos {
            margin: 30px 0;
        }

        .demo-section {
            margin: 25px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 5px solid #007bff;
        }

        .demo-section h4 {
            color: #007bff;
            margin-bottom: 15px;
        }

        .demo-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 15px;
        }

        .demo-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }

        .demo-item strong {
            color: #495057;
            display: block;
            margin-bottom: 10px;
        }

        .demo-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 15px;
        }

        .demo-before, .demo-after {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }

        .demo-before {
            border-left: 4px solid #dc3545;
        }

        .demo-after {
            border-left: 4px solid #28a745;
        }

        .demo-before strong {
            color: #dc3545;
        }

        .demo-after strong {
            color: #28a745;
        }

        .practical-flags {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 15px;
            margin: 30px 0;
        }

        .scenario-grid {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 20px;
        }

        .scenario-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .scenario-item h4 {
            color: #ffd700;
            margin-bottom: 15px;
        }

        .interactive-flags {
            background: #e3f2fd;
            padding: 25px;
            border-radius: 15px;
            margin: 30px 0;
            border: 2px solid #2196f3;
        }

        .flag-tester {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .input-section, .pattern-section, .flags-section {
            margin-bottom: 20px;
        }

        .input-section label, .pattern-section label, .flags-section label {
            display: block;
            font-weight: bold;
            margin-bottom: 8px;
            color: #333;
        }

        .input-section textarea {
            width: 100%;
            height: 120px;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            resize: vertical;
        }

        .pattern-section input {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
        }

        .flag-checkboxes {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .flag-checkboxes label {
            display: flex;
            align-items: center;
            font-weight: normal;
            cursor: pointer;
            padding: 8px;
            border-radius: 5px;
            transition: background-color 0.3s;
        }

        .flag-checkboxes label:hover {
            background-color: #f0f0f0;
        }

        .flag-checkboxes input[type="checkbox"] {
            margin-right: 8px;
            transform: scale(1.2);
        }

        .test-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .test-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .results-display {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
            min-height: 50px;
        }

        .flag-result {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
        }

        .flag-result.match {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .flag-result.no-match {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }

        .flag-result strong {
            display: block;
            margin-bottom: 5px;
        }

        /* Pattern.quote 样式 */
        .quote-theory {
            margin: 2rem 0;
            padding: 1.5rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            color: white;
        }

        .quote-theory h3 {
            color: white;
            margin-bottom: 1.5rem;
            text-align: center;
        }

        .principle-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5rem;
            margin-top: 1rem;
        }

        .principle-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 1.5rem;
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }

        .principle-item h4 {
            color: #ffd700;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .principle-item p {
            color: #e8e8e8;
            margin-bottom: 1rem;
            line-height: 1.6;
        }

        .quote-scenarios {
            margin: 2rem 0;
        }

        .quote-scenarios h3 {
            color: #333;
            margin-bottom: 1.5rem;
            text-align: center;
        }

        .scenario-section {
            margin: 2rem 0;
            padding: 1.5rem;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #28a745;
        }

        .scenario-section h4 {
            color: #28a745;
            margin-bottom: 1rem;
        }

        .scenario-demo {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
            margin: 1rem 0;
        }

        .demo-problem, .demo-solution {
            padding: 1rem;
            border-radius: 8px;
        }

        .demo-problem {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
        }

        .demo-problem strong {
            color: #721c24;
        }

        .demo-solution {
            background: #d4edda;
            border: 1px solid #c3e6cb;
        }

        .demo-solution strong {
            color: #155724;
        }

        .quote-advanced {
            margin: 2rem 0;
            padding: 1.5rem;
            background: linear-gradient(135deg, #ff7e5f 0%, #feb47b 100%);
            border-radius: 12px;
            color: white;
        }

        .quote-advanced h3 {
            color: white;
            margin-bottom: 1.5rem;
            text-align: center;
        }

        .advanced-section {
            margin: 1.5rem 0;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }

        .advanced-section h4 {
            color: #ffd700;
            margin-bottom: 1rem;
        }

        .quote-performance {
            margin: 2rem 0;
        }

        .quote-performance h3 {
            color: #333;
            margin-bottom: 1.5rem;
            text-align: center;
        }

        .performance-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 1.5rem;
        }

        .performance-item {
            padding: 1.5rem;
            background: #e3f2fd;
            border-radius: 10px;
            border-left: 4px solid #2196f3;
        }

        .performance-item h4 {
            color: #1976d2;
            margin-bottom: 1rem;
        }

        .quote-interactive {
            margin: 2rem 0;
            padding: 1.5rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            color: white;
        }

        .quote-interactive h3 {
            color: white;
            margin-bottom: 1.5rem;
            text-align: center;
        }

        .quote-tester {
            background: rgba(255, 255, 255, 0.1);
            padding: 1.5rem;
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }

        .quote-tester .input-section {
            margin: 1rem 0;
        }

        .quote-tester label {
            display: block;
            margin-bottom: 0.5rem;
            color: #ffd700;
            font-weight: bold;
        }

        .quote-tester input, .quote-tester textarea {
            width: 100%;
            padding: 0.8rem;
            border: none;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .quote-tester textarea {
            height: 100px;
            resize: vertical;
        }

        .quote-tester .test-button {
            background: #ffd700;
            color: #333;
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            margin: 1rem 0;
            transition: all 0.3s ease;
        }

        .quote-tester .test-button:hover {
            background: #ffed4e;
            transform: translateY(-2px);
        }

        .quote-results {
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            color: #333;
        }

        .quote-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin: 1rem 0;
        }

        .quote-result {
            padding: 1rem;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .quote-result.direct {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
        }

        .quote-result.quoted {
            background: #d4edda;
            border: 1px solid #c3e6cb;
        }

        .quote-result h5 {
            margin: 0 0 0.5rem 0;
            font-size: 1rem;
        }

        .quote-highlight {
            background: #ffeb3b;
            padding: 2px 4px;
            border-radius: 3px;
            color: #333;
        }

        /* 量词样式 */
        .quantifier-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin: 2rem 0;
        }

        .quantifier-item {
            background: #f8f9fa;
            padding: 1.5rem;
            border-radius: 10px;
            border-left: 4px solid #007bff;
        }

        .quantifier-item h3 {
            color: #007bff;
            margin-bottom: 1rem;
        }

        .quantifier-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        .quantifier-table th,
        .quantifier-table td {
            padding: 0.8rem;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }

        .quantifier-table th {
            background: #e9ecef;
            font-weight: bold;
            color: #495057;
        }

        .quantifier-table code {
            background: #f8f9fa;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #e83e8c;
        }

        .quantifier-demo {
            margin: 2rem 0;
            padding: 1.5rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            color: white;
        }

        .quantifier-demo h3 {
            color: white;
            margin-bottom: 1rem;
            text-align: center;
        }

        .quantifier-demo .demo-controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .quantifier-demo input {
            flex: 1;
            min-width: 200px;
            padding: 0.8rem;
            border: none;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }

        .quantifier-demo .demo-button {
            background: #ffd700;
            color: #333;
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .quantifier-demo .demo-button:hover {
            background: #ffed4e;
            transform: translateY(-2px);
        }

        .quantifier-demo .demo-result {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            font-family: 'Courier New', monospace;
        }

        </style>

    <script>
        // FSM演示功能
        function demonstrateFSM() {
            const input = document.getElementById('fsmInput').value;
            const pattern = document.getElementById('fsmPattern').value;
            const resultDiv = document.getElementById('fsmResult');
            
            if (!input || !pattern) {
                resultDiv.innerHTML = '<span style="color: #ffcccb;">请输入文本和正则表达式</span>';
                return;
            }
            
            try {
                const regex = new RegExp(pattern, 'g');
                const matches = [...input.matchAll(regex)];
                
                if (matches.length > 0) {
                    let result = `匹配成功！找到 ${matches.length} 个匹配项：\n`;
                    matches.forEach((match, index) => {
                        result += `${index + 1}. "${match[0]}" (位置: ${match.index})\n`;
                    });
                    resultDiv.innerHTML = `<span style="color: #90EE90;">${result}</span>`;
                } else {
                    resultDiv.innerHTML = '<span style="color: #ffcccb;">没有找到匹配项</span>';
                }
                
                // 简单的状态机可视化
                visualizeSimpleFSM(pattern, input);
                
            } catch (error) {
                resultDiv.innerHTML = `<span style="color: #ffcccb;">正则表达式错误: ${error.message}</span>`;
            }
        }
        
        function visualizeSimpleFSM(pattern, input) {
            // 这里可以添加更复杂的FSM可视化逻辑
            // 目前只是一个简单的演示
            console.log(`FSM处理: 模式"${pattern}" 匹配文本"${input}"`);
        }
        
        // 贪婪匹配演示功能
        function demonstrateGreedy() {
            const text = document.getElementById('greedyText').value;
            const pattern = document.getElementById('greedyPattern').value;
            const resultDiv = document.getElementById('greedyResult');
            
            if (!text || !pattern) {
                resultDiv.innerHTML = '<span style="color: #ffcccb;">请输入文本和正则表达式</span>';
                return;
            }
            
            try {
                const regex = new RegExp(pattern, 'g');
                const matches = [...text.matchAll(regex)];
                
                let result = '<div style="margin-bottom: 1rem;"><strong>🟢 贪婪匹配结果：</strong></div>';
                if (matches.length > 0) {
                    result += `<div style="color: #90EE90;">找到 ${matches.length} 个匹配项：</div>`;
                    matches.forEach((match, index) => {
                        result += `<div>${index + 1}. "${match[0]}" (位置: ${match.index}-${match.index + match[0].length - 1})</div>`;
                    });
                } else {
                    result += '<div style="color: #ffcccb;">没有找到匹配项</div>';
                }
                
                resultDiv.innerHTML = result;
                
            } catch (error) {
                resultDiv.innerHTML = `<span style="color: #ffcccb;">正则表达式错误: ${error.message}</span>`;
            }
        }
        
        function demonstrateLazy() {
            const text = document.getElementById('greedyText').value;
            let pattern = document.getElementById('greedyPattern').value;
            const resultDiv = document.getElementById('greedyResult');
            
            if (!text || !pattern) {
                resultDiv.innerHTML = '<span style="color: #ffcccb;">请输入文本和正则表达式</span>';
                return;
            }
            
            // 将贪婪量词转换为非贪婪量词
            const lazyPattern = pattern
                .replace(/\*(?!\?)/g, '*?')
                .replace(/\+(?!\?)/g, '+?')
                .replace(/\?(?!\?)/g, '??')
                .replace(/\{(\d+),(\d+)\}(?!\?)/g, '{$1,$2}?');
            
            try {
                const regex = new RegExp(lazyPattern, 'g');
                const matches = [...text.matchAll(regex)];
                
                let result = '<div style="margin-bottom: 1rem;"><strong>🔴 非贪婪匹配结果：</strong></div>';
                result += `<div style="margin-bottom: 0.5rem;">转换后的模式: <code>${lazyPattern}</code></div>`;
                
                if (matches.length > 0) {
                    result += `<div style="color: #90EE90;">找到 ${matches.length} 个匹配项：</div>`;
                    matches.forEach((match, index) => {
                        result += `<div>${index + 1}. "${match[0]}" (位置: ${match.index}-${match.index + match[0].length - 1})</div>`;
                    });
                } else {
                    result += '<div style="color: #ffcccb;">没有找到匹配项</div>';
                }
                
                resultDiv.innerHTML = result;
                
            } catch (error) {
                resultDiv.innerHTML = `<span style="color: #ffcccb;">正则表达式错误: ${error.message}</span>`;
            }
        }

        // 回溯爆炸演示功能
        function testBacktracking(type) {
            const text = document.getElementById('backtrackText').value;
            const dangerousResult = document.getElementById('dangerousResult');
            const safeResult = document.getElementById('safeResult');
            
            if (!text) {
                const message = '<span style="color: #ffcccb;">请输入测试字符串</span>';
                dangerousResult.innerHTML = message;
                safeResult.innerHTML = message;
                return;
            }
            
            if (type === 'dangerous') {
                // 测试危险模式 (a+)+b
                const startTime = performance.now();
                
                try {
                    // 设置超时保护，避免浏览器卡死
                    const timeoutId = setTimeout(() => {
                        dangerousResult.innerHTML = '<span style="color: #ff6b6b;">⚠️ 超时！检测到回溯爆炸风险</span>';
                    }, 1000);
                    
                    const regex = /^(a+)+b$/;
                    const result = regex.test(text);
                    
                    clearTimeout(timeoutId);
                    const endTime = performance.now();
                    const duration = (endTime - startTime).toFixed(2);
                    
                    let resultHtml = `<div><strong>模式:</strong> (a+)+b</div>`;
                    resultHtml += `<div><strong>结果:</strong> ${result ? '匹配' : '不匹配'}</div>`;
                    resultHtml += `<div><strong>耗时:</strong> ${duration} ms</div>`;
                    
                    if (duration > 100) {
                        resultHtml += '<div style="color: #ff6b6b;">⚠️ 性能警告：执行时间过长</div>';
                    }
                    
                    dangerousResult.innerHTML = resultHtml;
                    
                } catch (error) {
                    dangerousResult.innerHTML = `<span style="color: #ff6b6b;">错误: ${error.message}</span>`;
                }
                
            } else if (type === 'safe') {
                // 测试安全模式 a+b
                const startTime = performance.now();
                
                try {
                    const regex = /^a+b$/;
                    const result = regex.test(text);
                    
                    const endTime = performance.now();
                    const duration = (endTime - startTime).toFixed(2);
                    
                    let resultHtml = `<div><strong>模式:</strong> a+b</div>`;
                    resultHtml += `<div><strong>结果:</strong> ${result ? '匹配' : '不匹配'}</div>`;
                    resultHtml += `<div><strong>耗时:</strong> ${duration} ms</div>`;
                    resultHtml += '<div style="color: #27ae60;">✅ 性能良好：线性时间复杂度</div>';
                    
                    safeResult.innerHTML = resultHtml;
                    
                } catch (error) {
                    safeResult.innerHTML = `<span style="color: #ff6b6b;">错误: ${error.message}</span>`;
                }
            }
        }

        // Unicode演示功能
        function testUnicode(type) {
            const text = document.getElementById('unicodeText').value;
            
            if (!text) {
                const message = '<span style="color: #ffcccb;">请输入测试文本</span>';
                document.getElementById('lettersResult').innerHTML = message;
                document.getElementById('chineseResult').innerHTML = message;
                document.getElementById('numbersResult').innerHTML = message;
                document.getElementById('punctuationResult').innerHTML = message;
                return;
            }
            
            let pattern, resultId, description;
            
            switch(type) {
                case 'letters':
                    // 注意：JavaScript不完全支持\p{L}，这里用近似模式
                    pattern = /[a-zA-Z\u00C0-\u017F\u4e00-\u9fa5\u0370-\u03FF\u0400-\u04FF]/g;
                    resultId = 'lettersResult';
                    description = 'Unicode字母匹配 (近似\\p{L})';
                    break;
                case 'chinese':
                    pattern = /[\u4e00-\u9fa5]/g;
                    resultId = 'chineseResult';
                    description = '中文字符匹配 (\\u4e00-\\u9fa5)';
                    break;
                case 'numbers':
                    pattern = /[\d\u0660-\u0669\u06F0-\u06F9\uFF10-\uFF19]/g;
                    resultId = 'numbersResult';
                    description = 'Unicode数字匹配 (包括全角数字)';
                    break;
                case 'punctuation':
                    pattern = /[!-/:-@\[-`{-~\u2000-\u206F\u3000-\u303F]/g;
                    resultId = 'punctuationResult';
                    description = 'Unicode标点符号匹配';
                    break;
                default:
                    return;
            }
            
            try {
                const matches = [...text.matchAll(pattern)];
                
                let resultHtml = `<div><strong>${description}</strong></div>`;
                if (matches.length > 0) {
                    resultHtml += `<div style="color: #28a745;">找到 ${matches.length} 个匹配项：</div>`;
                    const uniqueMatches = [...new Set(matches.map(m => m[0]))];
                    resultHtml += `<div style="font-family: 'Courier New', monospace; background: #e9ecef; padding: 8px; border-radius: 4px; margin-top: 5px;">`;
                    resultHtml += uniqueMatches.join(' ');
                    resultHtml += `</div>`;
                } else {
                    resultHtml += '<div style="color: #dc3545;">没有找到匹配项</div>';
                }
                
                document.getElementById(resultId).innerHTML = resultHtml;
                
            } catch (error) {
                document.getElementById(resultId).innerHTML = `<span style="color: #dc3545;">错误: ${error.message}</span>`;
            }
        }

        // 标志演示功能
        function testFlags() {
            const text = document.getElementById('flagTestText').value;
            const pattern = document.getElementById('flagPattern').value;
            
            if (!text || !pattern) {
                document.getElementById('flagResults').innerHTML = '<div style="color: #dc3545;">请输入测试文本和正则模式</div>';
                return;
            }
            
            const caseInsensitive = document.getElementById('caseInsensitive').checked;
            const multiline = document.getElementById('multiline').checked;
            const dotall = document.getElementById('dotall').checked;
            const unicodeCase = document.getElementById('unicodeCase').checked;
            
            let flags = '';
            if (caseInsensitive) flags += 'i';
            if (multiline) flags += 'm';
            if (dotall) flags += 's';
            if (unicodeCase) flags += 'u';
            
            let resultsHtml = '<h4>测试结果：</h4>';
            
            try {
                // 测试不同标志组合
                const testCases = [
                    { name: '无标志', flags: '' },
                    { name: '当前选择的标志', flags: flags }
                ];
                
                if (flags !== '') {
                    // 添加单独标志测试
                    if (caseInsensitive) testCases.push({ name: '仅 CASE_INSENSITIVE', flags: 'i' });
                    if (multiline) testCases.push({ name: '仅 MULTILINE', flags: 'm' });
                    if (dotall) testCases.push({ name: '仅 DOTALL', flags: 's' });
                    if (unicodeCase) testCases.push({ name: '仅 UNICODE_CASE', flags: 'u' });
                }
                
                testCases.forEach(testCase => {
                    try {
                        const regex = new RegExp(pattern, testCase.flags);
                        const matches = [...text.matchAll(new RegExp(pattern, testCase.flags + 'g'))];
                        
                        const resultClass = matches.length > 0 ? 'match' : 'no-match';
                        const resultIcon = matches.length > 0 ? '✅' : '❌';
                        
                        resultsHtml += `<div class="flag-result ${resultClass}">`;
                        resultsHtml += `<strong>${resultIcon} ${testCase.name} (${testCase.flags || '无'})</strong>`;
                        
                        if (matches.length > 0) {
                            resultsHtml += `<div>找到 ${matches.length} 个匹配项：</div>`;
                            const uniqueMatches = [...new Set(matches.map(m => m[0]))];
                            resultsHtml += `<div style="font-family: 'Courier New', monospace; background: rgba(0,0,0,0.1); padding: 5px; border-radius: 3px; margin-top: 5px;">`;
                            resultsHtml += uniqueMatches.slice(0, 5).join(', ');
                            if (uniqueMatches.length > 5) resultsHtml += ` ... (共${uniqueMatches.length}个)`;
                            resultsHtml += `</div>`;
                        } else {
                            resultsHtml += '<div>没有找到匹配项</div>';
                        }
                        
                        resultsHtml += '</div>';
                        
                    } catch (error) {
                        resultsHtml += `<div class="flag-result no-match">`;
                        resultsHtml += `<strong>❌ ${testCase.name} - 错误</strong>`;
                        resultsHtml += `<div style="color: #dc3545;">${error.message}</div>`;
                        resultsHtml += '</div>';
                    }
                });
                
                // 添加标志说明
                if (flags) {
                    resultsHtml += '<div style="margin-top: 20px; padding: 15px; background: #e3f2fd; border-radius: 8px;">';
                    resultsHtml += '<h5>当前标志说明：</h5>';
                    resultsHtml += '<ul style="margin: 10px 0; padding-left: 20px;">';
                    if (caseInsensitive) resultsHtml += '<li><strong>i (CASE_INSENSITIVE)</strong>: 忽略大小写</li>';
                    if (multiline) resultsHtml += '<li><strong>m (MULTILINE)</strong>: ^和$匹配每行的开始和结束</li>';
                    if (dotall) resultsHtml += '<li><strong>s (DOTALL)</strong>: 点号匹配包括换行符在内的任意字符</li>';
                    if (unicodeCase) resultsHtml += '<li><strong>u (UNICODE)</strong>: 启用Unicode模式</li>';
                    resultsHtml += '</ul></div>';
                }
                
            } catch (error) {
                resultsHtml += `<div class="flag-result no-match">`;
                resultsHtml += `<strong>❌ 正则表达式错误</strong>`;
                resultsHtml += `<div style="color: #dc3545;">${error.message}</div>`;
                resultsHtml += '</div>';
            }
            
            document.getElementById('flagResults').innerHTML = resultsHtml;
        }

        // 页面加载完成后绑定事件
        document.addEventListener('DOMContentLoaded', function() {
            // 绑定FSM演示按钮
            const demoButton = document.querySelector('#fsmDemo button');
            if (demoButton) {
                demoButton.addEventListener('click', demonstrateFSM);
            }
            
            // 绑定回车键
            const inputs = document.querySelectorAll('#fsmDemo input');
            inputs.forEach(input => {
                input.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        demonstrateFSM();
                    }
                });
            });
            
            // 绑定贪婪匹配演示的回车键
            const greedyInputs = document.querySelectorAll('#greedyDemo input');
            greedyInputs.forEach(input => {
                input.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        demonstrateGreedy();
                    }
                });
            });
        });

        // Pattern.quote 演示功能
        function testQuote() {
            const input = document.getElementById('quoteInput').value;
            const testText = document.getElementById('quoteTestText').value;
            const resultDiv = document.getElementById('quoteResults');
            
            if (!input.trim()) {
                resultDiv.innerHTML = '<div style="color: #ff6b6b;">请输入要测试的字符串</div>';
                return;
            }
            
            if (!testText.trim()) {
                resultDiv.innerHTML = '<div style="color: #ff6b6b;">请输入测试文本</div>';
                return;
            }
            
            try {
                // 模拟Pattern.quote的效果（JavaScript中的等价实现）
                function escapeRegExp(string) {
                    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                }
                
                // 直接使用输入作为正则表达式（危险做法）
                let directMatches = [];
                let directError = null;
                try {
                    const directRegex = new RegExp(input, 'g');
                    directMatches = [...testText.matchAll(directRegex)];
                } catch (error) {
                    directError = error.message;
                }
                
                // 使用转义后的字符串（安全做法，等价于Pattern.quote）
                const escapedInput = escapeRegExp(input);
                const quotedRegex = new RegExp(escapedInput, 'g');
                const quotedMatches = [...testText.matchAll(quotedRegex)];
                
                let result = '<div class="quote-comparison">';
                
                // 直接使用的结果
                result += '<div class="quote-result direct">';
                result += '<h5>❌ 直接使用（危险）</h5>';
                result += `<div><strong>模式:</strong> <code>${input}</code></div>`;
                
                if (directError) {
                    result += `<div style="color: #721c24; margin-top: 0.5rem;"><strong>错误:</strong> ${directError}</div>`;
                } else {
                    if (directMatches.length > 0) {
                        result += `<div style="color: #721c24; margin-top: 0.5rem;"><strong>匹配:</strong> ${directMatches.length} 个</div>`;
                        directMatches.forEach((match, index) => {
                            if (index < 3) { // 只显示前3个匹配
                                const highlightedText = testText.substring(0, match.index) + 
                                    '<span class="quote-highlight">' + match[0] + '</span>' + 
                                    testText.substring(match.index + match[0].length);
                                result += `<div style="font-size: 0.8rem; margin-top: 0.3rem;">${index + 1}. "${match[0]}" (位置: ${match.index})</div>`;
                            }
                        });
                        if (directMatches.length > 3) {
                            result += `<div style="font-size: 0.8rem; color: #666;">...还有 ${directMatches.length - 3} 个匹配</div>`;
                        }
                    } else {
                        result += '<div style="color: #721c24; margin-top: 0.5rem;"><strong>结果:</strong> 无匹配</div>';
                    }
                }
                result += '</div>';
                
                // 使用quote的结果
                result += '<div class="quote-result quoted">';
                result += '<h5>✅ 使用转义（安全）</h5>';
                result += `<div><strong>转义后:</strong> <code>${escapedInput}</code></div>`;
                
                if (quotedMatches.length > 0) {
                    result += `<div style="color: #155724; margin-top: 0.5rem;"><strong>匹配:</strong> ${quotedMatches.length} 个字面量</div>`;
                    quotedMatches.forEach((match, index) => {
                        if (index < 3) { // 只显示前3个匹配
                            result += `<div style="font-size: 0.8rem; margin-top: 0.3rem;">${index + 1}. "${match[0]}" (位置: ${match.index})</div>`;
                        }
                    });
                    if (quotedMatches.length > 3) {
                        result += `<div style="font-size: 0.8rem; color: #666;">...还有 ${quotedMatches.length - 3} 个匹配</div>`;
                    }
                } else {
                    result += '<div style="color: #155724; margin-top: 0.5rem;"><strong>结果:</strong> 无字面量匹配</div>';
                }
                result += '</div>';
                
                result += '</div>';
                
                // 添加说明
                result += '<div style="margin-top: 1rem; padding: 1rem; background: #e7f3ff; border-radius: 6px; color: #333;">';
                result += '<strong>💡 说明:</strong><br>';
                result += '• <strong>直接使用:</strong> 将输入字符串作为正则表达式模式，特殊字符会被解释为元字符<br>';
                result += '• <strong>使用转义:</strong> 等价于Java的Pattern.quote()，将所有字符作为字面量处理<br>';
                result += '• <strong>安全性:</strong> 转义方法避免了正则注入攻击和意外的模式匹配';
                result += '</div>';
                
                resultDiv.innerHTML = result;
                
            } catch (error) {
                resultDiv.innerHTML = `<div style="color: #ff6b6b;">测试过程中发生错误: ${error.message}</div>`;
            }
         }

        // 量词演示功能
        function testQuantifiers() {
            const pattern = document.getElementById('quantifierPattern').value;
            const text = document.getElementById('quantifierText').value;
            const resultDiv = document.getElementById('quantifierResult');
            
            if (!pattern.trim()) {
                resultDiv.innerHTML = '<div style="color: #ff6b6b;">请输入正则表达式模式</div>';
                return;
            }
            
            if (!text.trim()) {
                resultDiv.innerHTML = '<div style="color: #ff6b6b;">请输入测试文本</div>';
                return;
            }
            
            try {
                const regex = new RegExp(pattern, 'g');
                const matches = [...text.matchAll(regex)];
                
                let result = `<div style="margin-bottom: 1rem;"><strong>模式:</strong> <code>${pattern}</code></div>`;
                result += `<div style="margin-bottom: 1rem;"><strong>测试文本:</strong> "${text}"</div>`;
                
                if (matches.length > 0) {
                    result += `<div style="color: #90EE90; margin-bottom: 0.5rem;"><strong>找到 ${matches.length} 个匹配项:</strong></div>`;
                    
                    // 高亮显示匹配项
                    let highlightedText = text;
                    let offset = 0;
                    
                    matches.forEach((match, index) => {
                        const start = match.index + offset;
                        const end = start + match[0].length;
                        const before = highlightedText.substring(0, start);
                        const highlighted = `<span style="background: #ffeb3b; color: #333; padding: 2px 4px; border-radius: 3px;">${match[0]}</span>`;
                        const after = highlightedText.substring(end);
                        
                        highlightedText = before + highlighted + after;
                        offset += highlighted.length - match[0].length;
                        
                        result += `<div style="margin: 0.3rem 0;">${index + 1}. "${match[0]}" (位置: ${match.index}-${match.index + match[0].length - 1})</div>`;
                    });
                    
                    result += `<div style="margin-top: 1rem;"><strong>高亮显示:</strong></div>`;
                    result += `<div style="background: rgba(255,255,255,0.1); padding: 0.8rem; border-radius: 4px; margin-top: 0.5rem;">${highlightedText}</div>`;
                    
                    // 分析量词类型
                    result += '<div style="margin-top: 1rem;"><strong>量词分析:</strong></div>';
                    if (pattern.includes('*')) {
                        result += '<div>• 包含 * (0次或多次)</div>';
                    }
                    if (pattern.includes('+')) {
                        result += '<div>• 包含 + (1次或多次)</div>';
                    }
                    if (pattern.includes('?')) {
                        result += '<div>• 包含 ? (0次或1次)</div>';
                    }
                    if (pattern.includes('{')) {
                        result += '<div>• 包含 {n,m} (指定次数范围)</div>';
                    }
                    
                } else {
                    result += '<div style="color: #ffcccb;">没有找到匹配项</div>';
                    result += '<div style="margin-top: 0.5rem; font-size: 0.9rem;">💡 提示: 检查量词是否正确，或尝试调整测试文本</div>';
                }
                
                resultDiv.innerHTML = result;
                
            } catch (error) {
                resultDiv.innerHTML = `<div style="color: #ffcccb;">正则表达式错误: ${error.message}</div>`;
            }
        }
    </script>

    <script src="../prism/prism.js"></script>
    <script src="./js/ppt.js"></script>
    <script src="../prism/prism-autoloader.min.js"></script>
</body>
</html>