<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java正则表达式详解</title>
    <link rel="stylesheet" href="./css/style.css">
    <link rel="stylesheet" href="./css/hacker-cmd.css">
    <link rel="stylesheet" href="../prism/prism.css">
    <link rel="stylesheet" href="./css/animation.css">
</head>
<body>

    <main id="presentation">
        <!-- Slide 1: Title -->
        <section class="slide title-slide active">
            <h1>Java 正则表达式</h1>
            <p>Regular Expressions in Java</p>
            <strong>掌握文本处理的强大工具</strong>
        </section>

        <!-- Slide 2: What is Regular Expression -->
        <section class="slide">
            <div class="slide-content">
                <h2>什么是正则表达式？</h2>
                <p>正则表达式（Regular Expression，简称 Regex）是一种强大的文本模式匹配工具，就像是文本世界的"搜索引擎"。</p>
                
                <h3>🔍 生活中的类比</h3>
                <p>想象你在图书馆寻找书籍：</p>
                <ul>
                    <li><strong>普通搜索：</strong> "找到书名是《Java编程思想》的书" - 精确匹配</li>
                    <li><strong>正则搜索：</strong> "找到所有以'Java'开头，包含'编程'的书" - 模式匹配</li>
                </ul>

                <h3>正则表达式的核心能力</h3>
                <ul>
                    <li><strong>🎯 模式匹配：</strong>检查文本是否符合特定模式</li>
                    <li><strong>🔍 文本搜索：</strong>在大量文本中快速找到目标</li>
                    <li><strong>✂️ 文本替换：</strong>批量替换符合模式的文本</li>
                    <li><strong>📝 数据验证：</strong>验证邮箱、电话号码等格式</li>
                </ul>
            </div>
        </section>

        <!-- Slide 2.5: Finite State Automaton Theory -->
        <section class="slide">
            <div class="slide-content">
                <h2>🔧 什么是有限状态自动机？</h2>
                <p><strong>有限状态自动机</strong>是一个数学模型，由以下组成：</p>
                <ul>
                    <li><strong>状态集合：</strong>有限个状态，包括初始状态和接受状态</li>
                    <li><strong>字母表：</strong>输入符号的集合</li>
                    <li><strong>转移函数：</strong>定义状态间的转移规则</li>
                    <li><strong>初始状态：</strong>自动机开始的状态</li>
                    <li><strong>接受状态：</strong>表示匹配成功的状态</li>
                </ul>

                <h3>🎯 正则表达式如何工作</h3>
                <h4>示例：匹配 "ab*c" 的状态机</h4>
                <img src="images/5-reg-abc.png" alt="匹配字符串 ab*c 的状态机示意图" style="max-width: 40%; height: auto; margin: 1rem 0;">
                <p><strong>示例：匹配字符串 "ab*c" 的状态机</strong></p>
                <pre><code>S1 --a--> S2 --b--> S2(自循环) --c--> S3(接受状态)</code></pre>
                <p><strong>工作过程：</strong></p>
                <ol>
                    <li>从初始状态 S1 开始</li>
                    <li>读取字符 'a'，转移到状态 S2</li>
                    <li>读取任意数量的 'b'（可以为 0 个），保持在状态 S2</li>
                    <li>读取字符 'c'，转移到接受状态 S3</li>
                    <li>到达接受状态，匹配成功！</li>
                </ol>


            </div>
        </section>

        <!-- Slide 3: Java Regular Expressions (Moved from Slide 10) -->
        <section class="slide">
            <div class="slide-content">
                <h2>String类的文本处理方法</h2>
                <p>在学习正则表达式之前，让我们先了解String类中常用的文本处理方法：</p>

                <div class="string-methods-intro">
                    <div class="method-explanation">
                        <h3>🔄 replace() 和 replaceAll()</h3>
                        <p>字符串替换操作</p>
                        <pre><code class="language-java">String text = "Hello World, Hello Java";

// replace() - 替换所有匹配的字符序列
String result1 = text.replace("Hello", "Hi");
// 结果: "Hi World, Hi Java"

// replaceAll() - 支持正则表达式的替换
String result2 = text.replaceAll("Hello", "Hi");
// 结果: "Hi World, Hi Java"

// replaceAll() 的正则表达式威力
String phoneText = "电话: 123-456-7890, 手机: 987-654-3210";
String masked = phoneText.replaceAll("\\d{3}-\\d{3}-\\d{4}", "***-***-****");
// 结果: "电话: ***-***-****, 手机: ***-***-****"</code></pre>
                    </div>

                    <div class="method-explanation">
                        <h3>✂️ split() 方法</h3>
                        <p>字符串分割操作</p>
                        <pre><code class="language-java">String data = "apple,banana,orange";

// 简单分割
String[] fruits = data.split(",");
// 结果: ["apple", "banana", "orange"]

// 使用正则表达式分割
String complexData = "apple,banana;orange:grape";
String[] allFruits = complexData.split("[,;:]");
// 结果: ["apple", "banana", "orange", "grape"]

// 处理多个空格
String sentence = "Hello    world   Java";
String[] words = sentence.split("\\s+");
// 结果: ["Hello", "world", "Java"]</code></pre>
                    </div>
                </div>

            </div>
        </section>

        <!-- Slide 3.5: String方法的局限性与优势 -->
        <section class="slide">
            <div class="slide-content">
                <h2>String方法的局限性</h2>
                <div class="string-limitations">
                    
                    <div class="limitation-examples">
                        <div class="limitation-item">
                            <h4>复杂模式匹配</h4>
                            <p>如何验证邮箱格式？电话号码格式？</p>
                            <pre><code class="language-java">// 使用String方法很难实现
String email = "user@example.com";
// 如何验证这是一个有效的邮箱？</code></pre>
                        </div>
                        <div class="limitation-item">
                            <h4>灵活的文本提取</h4>
                            <p>如何从文本中提取所有的数字？所有的URL？</p>
                            <pre><code class="language-java">// String方法无法轻松实现
String text = "价格：￥199.99，折扣：8.5折";
// 如何提取所有数字？</code></pre>
                        </div>
                    </div>
                </div>

                <div class="regex-introduction">
                    <h3>正则表达式的优势</h3>
                    <p>正则表达式提供了强大的模式匹配能力，可以轻松解决上述问题：</p>
                    <ul>
                        <li><strong>模式匹配</strong>：定义复杂的文本模式</li>
                        <li><strong>数据验证</strong>：验证邮箱、电话、身份证等格式</li>
                        <li><strong>文本提取</strong>：从复杂文本中提取特定信息</li>
                        <li><strong>高效替换</strong>：基于模式的智能替换</li>
                    </ul>
                </div>
            </div>
        </section>
        <!-- Slide 4: Basic Syntax -->
        <section class="slide">
            <div class="slide-content">
                <h2>正则表达式基础语法</h2>
                <p>正则表达式由普通字符和特殊字符（元字符）组成，就像编程语言的语法一样。</p>

                <h3>1. 基础字符介绍</h3>
                <table>
                    <thead>
                        <tr>
                            <th>类别</th>
                            <th>表达方式</th>
                            <th>示例匹配</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>小写字母</td>
                            <td><code>[a-z]</code></td>
                            <td>a, m, z</td>
                        </tr>
                        <tr>
                            <td>大写字母</td>
                            <td><code>[A-Z]</code></td>
                            <td>A, M, Z</td>
                        </tr>
                        <tr>
                            <td>数字字符</td>
                            <td><code>[0-9]</code></td>
                            <td>0, 5, 9</td>
                        </tr>
                        <tr>
                            <td>常见标点</td>
                            <td><code>[,.!?;:_@#-]</code></td>
                            <td>., !, -, @, #</td>
                        </tr>
                    </tbody>
                </table>
                <p>注意：某些符号在正则中具有特殊意义（如 <code>.</code>、<code>*</code>、<code>+</code>），若要匹配它们本身，可放入字符类或使用转义（如 <code>\.</code>）。</p>

                <h3>2. 特殊含义字符</h3>
                <table>
                    <thead>
                        <tr>
                            <th>符号</th>
                            <th>含义</th>
                            <th>示例</th>
                            <th>匹配结果</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>\s</code></td>
                            <td>空白字符</td>
                            <td><code>\s+</code></td>
                            <td>空格、制表符、换行</td>
                        </tr>
                        <tr>
                            <td><code>\d</code></td>
                            <td>数字 [0-9]</td>
                            <td><code>\d{2}</code></td>
                            <td>12, 09, 99</td>
                        </tr>
                        <tr>
                            <td><code>\w</code></td>
                            <td>字母、数字、下划线</td>
                            <td><code>\w+</code></td>
                            <td>hello, test_123</td>
                        </tr>
                        <tr>
                            <td><code>.</code></td>
                            <td>任意单个字符</td>
                            <td><code>a.c</code></td>
                            <td>abc, a1c, a@c</td>
                        </tr>
                        <tr>
                            <td><code>\S</code></td>
                            <td>非空白字符</td>
                            <td><code>\S+</code></td>
                            <td>非空白的连续片段</td>
                        </tr>
                        <tr>
                            <td><code>\D</code></td>
                            <td>非数字</td>
                            <td><code>\D+</code></td>
                            <td>非数字的连续片段</td>
                        </tr>
                        <tr>
                            <td><code>\W</code></td>
                            <td>非字母、数字、下划线</td>
                            <td><code>\W+</code></td>
                            <td>标点或其他符号序列</td>
                        </tr>
                    </tbody>
                </table>

                <h3>3. 边界规则</h3>
                <table>
                    <thead>
                        <tr>
                            <th>符号</th>
                            <th>作用</th>
                            <th>示例</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>^</code></td>
                            <td>行的开始</td>
                            <td><code>^Hello</code> 匹配以 "Hello" 开头的行</td>
                        </tr>
                        <tr>
                            <td><code>$</code></td>
                            <td>行的结束</td>
                            <td><code>world$</code> 匹配以 "world" 结尾的行</td>
                        </tr>
                        <tr>
                            <td><code>\b</code></td>
                            <td>单词边界</td>
                            <td><code>\bcat\b</code> 匹配独立单词 "cat"</td>
                        </tr>
                        <tr>
                            <td><code>\B</code></td>
                            <td>非单词边界</td>
                            <td><code>\Bcat\B</code> 匹配 "cat" 但不在单词边界</td>
                        </tr>
                        <tr>
                            <td><code>\A</code></td>
                            <td>字符串开始</td>
                            <td><code>\AStart</code> 匹配整个字符串的开始</td>
                        </tr>
                        <tr>
                            <td><code>\Z</code></td>
                            <td>字符串结束</td>
                            <td><code>End\Z</code> 匹配整个字符串的结束</td>
                        </tr>
                    </tbody>
                </table>

                <h3>4. 高级字符</h3>
                <table>
                    <thead>
                        <tr>
                            <th>表达式</th>
                            <th>含义</th>
                            <th>结合边界示例</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>[a-z&&[^bc]]</code></td>
                            <td>交集：小写字母但不包括 b/c</td>
                            <td><code>\b[a-z&&[^bc]]+\b</code> 匹配不含 b/c 的英文词</td>
                        </tr>
                        <tr>
                            <td><code>[a-zA-Z]</code></td>
                            <td>并集：所有英文字母</td>
                            <td><code>\b[a-zA-Z]{3,}\b</code> 匹配长度≥3 的英文单词</td>
                        </tr>
                        <tr>
                            <td><code>\p{L}</code></td>
                            <td>Unicode 字母类</td>
                            <td><code>^\p{L}+</code> 匹配行首连续字母序列</td>
                        </tr>
                        <tr>
                            <td><code>[^\s]</code></td>
                            <td>非空白字符</td>
                            <td><code>[^\s]+$</code> 匹配行尾最后一段非空白字符</td>
                        </tr>
                    </tbody>
                </table>

                <h3>5. 量词规则</h3>
                <table>
                    <thead>
                        <tr>
                            <th>符号</th>
                            <th>含义</th>
                            <th>示例</th>
                            <th>匹配结果</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>*</code></td>
                            <td>0次或多次</td>
                            <td><code>ab*</code></td>
                            <td>a, ab, abbb</td>
                        </tr>
                        <tr>
                            <td><code>+</code></td>
                            <td>1次或多次</td>
                            <td><code>ab+</code></td>
                            <td>ab, abbb</td>
                        </tr>
                        <tr>
                            <td><code>?</code></td>
                            <td>0次或1次</td>
                            <td><code>ab?</code></td>
                            <td>a, ab</td>
                        </tr>
                        <tr>
                            <td><code>{n,m}</code></td>
                            <td>n到m次</td>
                            <td><code>\d{3,5}</code></td>
                            <td>123, 1234, 12345</td>
                        </tr>
                    </tbody>
                </table>

                <h3>6. 实际应用示例</h3>
                <ul>
                    <li><strong>十六进制颜色：</strong> <code>#[0-9a-fA-F]{6}</code> - CSS颜色代码</li>
                    <li><strong>日期（YYYY-MM-DD）：</strong> <code>^\d{4}-\d{2}-\d{2}$</code> - 整行必须是日期格式</li>
                </ul>

            </div>
        </section>

        <!-- Slide 5: Pattern and Matcher Classes -->
        <section class="slide">
            <div class="slide-content">
                <h2 id="pattern-matcher">Pattern和Matcher类：Java正则表达式的核心</h2>
                <p>学习了正则表达式语法后，让我们掌握Java中专门用于正则表达式操作的两个核心类。</p>

                <div class="java-regex-classes">
                    <div class="class-explanation">
                        <h3>🎯 Pattern类 - 正则表达式的编译器</h3>
                        <p><strong>作用：</strong>将正则表达式字符串编译成可重用的模式对象</p>
                        <p><strong>特点：</strong>线程安全，可以被多个线程同时使用</p>
                        <pre><code class="language-java">// 编译正则表达式
Pattern pattern = Pattern.compile("\\d{3}-\\d{2}-\\d{4}");

// 带标志的编译
Pattern pattern = Pattern.compile("hello", Pattern.CASE_INSENSITIVE);</code></pre>
                    </div>

                    <div class="class-explanation">
                        <h3>🔍 Matcher类 - 匹配执行器</h3>
                        <p><strong>作用：</strong>对特定字符串执行匹配操作</p>
                        <p><strong>特点：</strong>非线程安全，每个线程需要独立的Matcher实例</p>
                        <pre><code class="language-java">// 创建Matcher对象
String text = "电话：123-45-6789";
Matcher matcher = pattern.matcher(text);

// 执行匹配操作
if (matcher.find()) {
    System.out.println("找到匹配：" + matcher.group());
}</code></pre>
                    </div>
                </div>

                <div class="common-methods">
                    <h3>🛠️ 常用方法一览</h3>
                    <table>
                        <thead>
                            <tr>
                                <th>方法</th>
                                <th>作用</th>
                                <th>示例</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>find()</code></td>
                                <td>查找下一个匹配</td>
                                <td><code>boolean found = matcher.find();</code></td>
                            </tr>
                            <tr>
                                <td><code>matches()</code></td>
                                <td>整个字符串是否匹配</td>
                                <td><code>boolean isMatch = matcher.matches();</code></td>
                            </tr>
                            <tr>
                                <td><code>group()</code></td>
                                <td>获取匹配的内容</td>
                                <td><code>String result = matcher.group();</code></td>
                            </tr>
                        </tbody>
                    </table>
                </div>

            </div>
        </section>


        <!-- Slide 6: Greedy vs Non-Greedy Matching -->
        <section class="slide">
            <div class="slide-content">
                <h2 id="greedy">贪婪与非贪婪匹配</h2>
                <p>理解正则表达式的两种匹配策略，掌握精确控制匹配行为的技巧。</p>

                <h3>🔍 匹配机制原理</h3>
                <ul>
                    <li><strong>贪婪匹配 (Greedy)：</strong>尽可能多地匹配字符，先匹配最长可能的字符串，然后回溯</li>
                    <li><strong>非贪婪匹配 (Non-Greedy/Lazy)：</strong>尽可能少地匹配字符，先匹配最短可能的字符串，必要时扩展</li>
                </ul>

                <h3>📊 量词对比表</h3>
                <table>
                    <thead>
                        <tr>
                            <th>贪婪量词</th>
                            <th>非贪婪量词</th>
                            <th>含义</th>
                            <th>匹配策略</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>*</code></td>
                            <td><code>*?</code></td>
                            <td>0次或多次</td>
                            <td>贪婪：尽可能多 / 非贪婪：尽可能少</td>
                        </tr>
                        <tr>
                            <td><code>+</code></td>
                            <td><code>+?</code></td>
                            <td>1次或多次</td>
                            <td>贪婪：尽可能多 / 非贪婪：只匹配1次</td>
                        </tr>
                        <tr>
                            <td><code>?</code></td>
                            <td><code>??</code></td>
                            <td>0次或1次</td>
                            <td>贪婪：优先匹配1次 / 非贪婪：优先匹配0次</td>
                        </tr>
                        <tr>
                            <td><code>{n,m}</code></td>
                            <td><code>{n,m}?</code></td>
                            <td>n到m次</td>
                            <td>贪婪：优先匹配m次 / 非贪婪：优先匹配n次</td>
                        </tr>
                    </tbody>
                </table>

                <h3>🎭 实战演示</h3>
                <h4>案例1：HTML标签提取</h4>
                <p><strong>文本：</strong><code>"&lt;div&gt;Hello&lt;/div&gt;&lt;span&gt;World&lt;/span&gt;"</code></p>
                <ul>
                    <li><strong>贪婪模式 <code>&lt;.*&gt;</code>：</strong>匹配整个字符串 ❌</li>
                    <li><strong>非贪婪模式 <code>&lt;.*?&gt;</code>：</strong>分别匹配每个标签 ✅</li>
                </ul>
                <table>
                    <thead>
                        <tr>
                            <th>模式</th>
                            <th>正则</th>
                            <th>匹配结果</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>贪婪</td>
                            <td><code>&lt;.*&gt;</code></td>
                            <td><code>&lt;div&gt;Hello&lt;/div&gt;&lt;span&gt;World&lt;/span&gt;</code></td>
                        </tr>
                        <tr>
                            <td>非贪婪</td>
                            <td><code>&lt;.*?&gt;</code></td>
                            <td><code>&lt;div&gt;</code>，<code>&lt;/div&gt;</code>，<code>&lt;span&gt;</code>，<code>&lt;/span&gt;</code></td>
                        </tr>
                    </tbody>
                </table>

                <h4>案例2：引号内容提取</h4>
                <p><strong>文本：</strong><code>"name=\"John\" age=\"25\""</code></p>
                <ul>
                    <li><strong>贪婪模式 <code>".*"</code>：</strong>匹配 "John\" age=\"25" ❌</li>
                    <li><strong>非贪婪模式 <code>".*?"</code>：</strong>分别匹配 "John" 和 "25" ✅</li>
                </ul>
                <table>
                    <thead>
                        <tr>
                            <th>模式</th>
                            <th>正则</th>
                            <th>匹配结果</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>贪婪</td>
                            <td><code>".*"</code></td>
                            <td><code>"John\" age=\"25"</code></td>
                        </tr>
                        <tr>
                            <td>非贪婪</td>
                            <td><code>".*?"</code></td>
                            <td><code>"John"</code>，<code>"25"</code></td>
                        </tr>
                    </tbody>
                </table>

                <h3>💻 Java代码示例</h3>
                <pre><code class="language-java">import java.util.regex.*;

public class GreedyDemo {
    public static void main(String[] args) {
        String text = "&lt;div&gt;Hello&lt;/div&gt;&lt;span&gt;World&lt;/span&gt;";
        
        // 贪婪匹配
        Pattern greedyPattern = Pattern.compile("&lt;.*&gt;");
        Matcher greedyMatcher = greedyPattern.matcher(text);
        System.out.println("贪婪匹配结果:");
        while (greedyMatcher.find()) {
            System.out.println("  " + greedyMatcher.group());
        }
        
        // 非贪婪匹配
        Pattern lazyPattern = Pattern.compile("&lt;.*?&gt;");
        Matcher lazyMatcher = lazyPattern.matcher(text);
        System.out.println("非贪婪匹配结果:");
        while (lazyMatcher.find()) {
            System.out.println("  " + lazyMatcher.group());
        }
    }
}</code></pre>

            </div>
        </section>






        <!-- Slide 9: Boundary Matching -->
        <section class="slide">
            <div class="slide-content">
                <h2>完整验证示例</h2>
                <div class="practical-example">
                    <div class="example-showcase">
                        <div class="showcase-item">
                            <strong>邮箱验证：</strong>
                            <code>^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$</code>
                            <p>完整的邮箱格式验证</p>
                        </div>
                        <div class="showcase-item">
                            <strong>手机号码：</strong>
                            <code>^1[3-9]\d{9}$</code>
                            <p>中国大陆手机号格式</p>
                        </div>
                        <div class="showcase-item">
                            <strong>身份证号：</strong>
                            <code>^\d{17}[\dXx]$</code>
                            <p>18位身份证号码</p>
                        </div>
                        <div class="showcase-item">
                            <strong>IP地址：</strong>
                            <code>^((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)$</code>
                            <p>IPv4地址格式验证</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 10: Practical Examples -->
        <section class="slide">
            <div class="slide-content">
                <h2>实战示例</h2>
                
                <div class="example-container">
                    <h3>📧 邮箱验证器</h3>
                    <pre><code class="language-java">import java.util.regex.Pattern;

public class EmailValidator {
    private static final String EMAIL_PATTERN = 
        "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$";
    
    private static final Pattern pattern = Pattern.compile(EMAIL_PATTERN);
    
    public static boolean isValidEmail(String email) {
        return pattern.matcher(email).matches();
    }
    
    public static void main(String[] args) {
        System.out.println(isValidEmail("user@example.com"));    // true
        System.out.println(isValidEmail("invalid.email"));      // false
        System.out.println(isValidEmail("test@domain.co.uk"));  // true
    }
}</code></pre>
                </div>

                <div class="example-container">
                    <h3>📱 手机号码提取器</h3>
                    <pre><code class="language-java">import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.ArrayList;
import java.util.List;

public class PhoneExtractor {
    public static List&lt;String&gt; extractPhones(String text) {
        String phonePattern = "1[3-9]\\d{9}";
        Pattern pattern = Pattern.compile(phonePattern);
        Matcher matcher = pattern.matcher(text);
        
        List&lt;String&gt; phones = new ArrayList&lt;&gt;();
        while (matcher.find()) {
            phones.add(matcher.group());
        }
        return phones;
    }
    
    public static void main(String[] args) {
        String text = "联系方式：13812345678，备用号码：15987654321";
        List&lt;String&gt; phones = extractPhones(text);
        phones.forEach(System.out::println);
        // 输出：13812345678, 15987654321
    }
}</code></pre>
                </div>
            </div>
        </section>

        <!-- Slide 12: Groups and Capturing -->
        <section class="slide">
            <div class="slide-content">
                <h2>分组和捕获</h2>
                <p>分组是正则表达式的强大功能，允许我们提取匹配的子字符串并进行复杂的模式匹配。</p>

                <div class="advanced-feature">
                    <h3>🎯 基础分组</h3>
                    <p>使用括号 <code>()</code> 创建分组，可以提取匹配的子字符串：</p>
                    <pre><code class="language-java">import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class GroupExample {
    public static void main(String[] args) {
        String text = "生日：1990-05-15";
        String pattern = "(\\d{4})-(\\d{2})-(\\d{2})";
        
        Pattern p = Pattern.compile(pattern);
        Matcher m = p.matcher(text);
        
        if (m.find()) {
            System.out.println("完整日期：" + m.group(0));  // 1990-05-15
            System.out.println("年份：" + m.group(1));      // 1990
            System.out.println("月份：" + m.group(2));      // 05
            System.out.println("日期：" + m.group(3));      // 15
        }
    }
}</code></pre>
                </div>

                <div class="advanced-feature">
                    <h3>🔧 高级分组技巧</h3>
                    <div class="group-techniques">
                        <div class="technique-item">
                            <h4>非捕获分组 <code>(?:...)</code></h4>
                            <p>分组但不捕获内容，提高性能</p>
                            <pre><code class="language-java">// 捕获分组
Pattern.compile("(https?)://(.+)");

// 非捕获分组
Pattern.compile("(?:https?)://(.+)");</code></pre>
                        </div>
                        <div class="technique-item">
                            <h4>命名分组 <code>(?&lt;name&gt;...)</code></h4>
                            <p>给分组命名，便于引用</p>
                            <pre><code class="language-java">String pattern = "(?&lt;year&gt;\\d{4})-(?&lt;month&gt;\\d{2})-(?&lt;day&gt;\\d{2})";
Pattern p = Pattern.compile(pattern);
Matcher m = p.matcher("2024-01-15");

if (m.find()) {
    System.out.println("年：" + m.group("year"));
    System.out.println("月：" + m.group("month"));
    System.out.println("日：" + m.group("day"));
}</code></pre>
                        </div>
                        <div class="technique-item">
                            <h4>反向引用 <code>\1, \2</code></h4>
                            <p>在正则表达式中引用之前的分组</p>
                            <pre><code class="language-java">// 匹配重复的单词（不使用边界符）
String pattern = "(\\w+)\\s+\\1";
String text = "hello hello world world";
// 匹配到 "hello hello" 和 "world world"</code></pre>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 13: Text Replacement and Flags -->
        <section class="slide">
            <div class="slide-content">
                <h2 id="replace-flags">文本替换和匹配标志</h2>
                <p>正则表达式不仅能匹配文本，还能进行智能替换和使用各种标志控制匹配行为。</p>

                <div class="advanced-feature">
                    <h3>🔄 文本替换</h3>
                    <p>使用正则表达式进行智能文本替换：</p>
                    <pre><code class="language-java">public class TextReplacer {
    public static void main(String[] args) {
        String text = "今天是2024年1月15日，明天是2024年1月16日";
        
        // 将所有日期格式从 YYYY年MM月DD日 改为 YYYY-MM-DD
        String pattern = "(\\d{4})年(\\d{1,2})月(\\d{1,2})日";
        String replacement = "$1-$2-$3";
        
        String result = text.replaceAll(pattern, replacement);
        System.out.println(result);
        // 输出：今天是2024-1-15，明天是2024-1-16
    }
}</code></pre>
                </div>

                <div class="advanced-feature">
                    <h3>🔧 高级替换技巧</h3>
                    <pre><code class="language-java">public class AdvancedReplacement {
    public static void main(String[] args) {
        // 使用Matcher进行复杂替换
        String text = "价格：$100, $200, $300, 快来买！";
        Pattern pattern = Pattern.compile("\\$(\\d+)");
        Matcher matcher = pattern.matcher(text);
        
        // 创建可变的字符串缓冲区，用于逐步构建替换后的结果
        StringBuffer result = new StringBuffer();
        
        // 循环查找所有匹配的价格数字
        while (matcher.find()) {
            // 提取捕获组中的价格字符串并转为整数
            int price = Integer.parseInt(matcher.group(1));
            // 计算8折后的新价格
            int discountPrice = (int)(price * 0.8); // 8折
            // 将匹配到的部分替换为带人民币符号的折扣价
            matcher.appendReplacement(result, "¥" + discountPrice);
        }
        
        // 将剩余未匹配的文本追加到结果末尾
        matcher.appendTail(result);
        
        // 输出最终完成替换的字符串
        System.out.println(result.toString());
        // 输出：价格：¥80, ¥160, ¥240, 快来买！
    }
}</code></pre>
                </div>

                <div class="advanced-feature">
                    <h3>🚩 匹配标志</h3>
                    <table>
                        <thead>
                            <tr>
                                <th>标志</th>
                                <th>含义</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>Pattern.CASE_INSENSITIVE</code></td>
                                <td>忽略大小写匹配</td>
                            </tr>
                            <tr>
                                <td><code>Pattern.MULTILINE</code></td>
                                <td>多行模式，<code>^</code> 和 <code>$</code> 匹配每行</td>
                            </tr>
                            <tr>
                                <td><code>Pattern.DOTALL</code></td>
                                <td>点号 <code>.</code> 匹配包括换行符在内的所有字符</td>
                            </tr>
                            <tr>
                                <td><code>Pattern.UNICODE_CASE</code></td>
                                <td>启用 Unicode 大小写匹配（与 <code>CASE_INSENSITIVE</code> 配合）</td>
                            </tr>
                            <tr>
                                <td><code>Pattern.COMMENTS</code></td>
                                <td>允许在正则中使用空白和注释（<code>#</code> 之后为注释）</td>
                            </tr>
                            <tr>
                                <td><code>Pattern.LITERAL</code></td>
                                <td>将模式整体作为字面量处理（禁用元字符语义）</td>
                            </tr>
                        </tbody>
                    </table>
                    
                    <div class="flag-example">
                        <h4>标志使用示例：</h4>
                        <pre><code class="language-java">// 组合多个标志
Pattern pattern = Pattern.compile(
    "hello.*world", 
    Pattern.CASE_INSENSITIVE | Pattern.DOTALL
);</code></pre>
                    </div>
                </div>
            </div>
        </section>






        <!-- Slide 18: Backtracking Catastrophe Deep Dive -->
        <section class="slide">
            <div class="slide-content">
                <h2>回溯爆炸</h2>

                <h3>1. 定义</h3>
                <p>回溯爆炸是指正则引擎在尝试匹配失败后，为寻找其他可能的匹配路径而不断回退并重试多种分支与分组拆分，导致尝试次数随输入长度呈指数级增长（常见为 O(2^n)），从而引发性能问题甚至程序卡死。</p>

                <h3>2. 实例演示</h3>
                <table>
                    <thead>
                        <tr>
                            <th>模式</th>
                            <th>文本</th>
                            <th>表现</th>
                            <th>原因</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>(a+)+b</code></td>
                            <td><code>aaaaaaaaaaaaaaaaaaaaaaaaaaab</code></td>
                            <td>可能极慢</td>
                            <td>
                                嵌套量词在同一字符上形成两层循环，潜在回溯空间巨大。
                                <details>
                                    <summary>一步一步（自动机视角）</summary>
                                    <ol>
                                        <li>外层 <code>+</code> 开始第 1 次迭代，进入内层 <code>a+</code>。</li>
                                        <li>内层 <code>a+</code> 贪婪地吞掉尽可能多的 <code>a</code>（通常整段 <code>a…a</code>）。</li>
                                        <li>尝试匹配末尾 <code>b</code>。若文本末尾正好是 <code>b</code>，此处直接成功；若后继字串导致 <code>b</code> 不匹配，则触发回溯。</li>
                                        <li>回溯时，内层 <code>a+</code> 会“吐出”一个或多个 <code>a</code>，外层 <code>+</code> 启动下一次迭代，用新的 <code>a+</code> 继续匹配剩余的 <code>a</code>，再尝试 <code>b</code>。</li>
                                        <li>这种“吐出-再分组”的分割组合随 <code>a</code> 的长度急剧增多（长度为 <code>n</code> 的 <code>a</code> 段可被划分为约 <code>2^{n-1}</code> 种正整数分割）。</li>
                                    </ol>
                                    <p>注：对本行文本（末尾确有 <code>b</code>）通常较快；但该结构在其他输入或上下文中极易触发指数级回溯。</p>
                                </details>
                            </td>
                        </tr>
                        <tr>
                            <td><code>(a+)+b</code></td>
                            <td><code>aaaaaaaaaaaaaaaaaaaaaaaaaaa</code>（无 <code>b</code>）</td>
                            <td>更慢或卡顿</td>
                            <td>
                                所有分支最终都失败，引擎枚举所有分割并在每次失败后继续回退。
                                <details>
                                    <summary>一步一步（自动机视角）</summary>
                                    <ol>
                                        <li>第 1 步：内层 <code>a+</code> 贪婪吞掉全部 <code>a</code>。</li>
                                        <li>第 2 步：尝试匹配末尾 <code>b</code> —— 失败（因为没有 <code>b</code>）。</li>
                                        <li>第 3 步：回溯。内层 <code>a+</code> 吐出 1 个 <code>a</code>；外层 <code>+</code> 开启第 2 次迭代，用新的 <code>a+</code> 匹配剩余的 <code>a</code>；再次尝试 <code>b</code> —— 仍失败。</li>
                                        <li>第 4 步：继续回溯与重组。对长度 <code>n</code> 的 <code>a</code>，会枚举所有正整数分割，如 <code>[n]</code>、<code>[n-1,1]</code>、<code>[n-2,2]</code>、<code>[n-2,1,1]</code>、…，每一种分割方案都要在末尾尝试 <code>b</code>。</li>
                                        <li>第 5 步：所有尝试失败后才返回“不匹配”。尝试次数随 <code>n</code> 近似呈指数增长（分割数约为 <code>2^{n-1}</code>）。</li>
                                    </ol>
                                    <pre><code>示例（n=4 的分割枚举）
[4]       -> aaaa | b (失败)
[3,1]     -> aaa + a | b (失败)
[2,2]     -> aa + aa | b (失败)
[2,1,1]   -> aa + a + a | b (失败)
[1,3]     -> a + aaa | b (失败)
[1,2,1]   -> a + aa + a | b (失败)
[1,1,2]   -> a + a + aa | b (失败)
[1,1,1,1] -> a + a + a + a | b (失败)</code></pre>
                                </details>
                            </td>
                        </tr>
                    </tbody>
                </table>
                <pre><code class="language-java">// 简单耗时对比（Java）
String text1 = "aaaaaaaaaaaaaaaaaaaaaaaaaaab";
String text2 = "aaaaaaaaaaaaaaaaaaaaaaaaaaa";
String bad = "(a+)+b";
String good = "a+b"; // 去除嵌套量词

long t1 = System.nanoTime();
Pattern.compile(bad).matcher(text2).find();
long t2 = System.nanoTime();
System.out.println("危险模式耗时(ms): " + (t2 - t1) / 1_000_000);

long t3 = System.nanoTime();
Pattern.compile(good).matcher(text2 + "b").find();
long t4 = System.nanoTime();
System.out.println("修复后耗时(ms): " + (t4 - t3) / 1_000_000);</code></pre>

                <h3>3. 解决方案（针对上述示例）</h3>
                <table>
                    <thead>
                        <tr>
                            <th>方案</th>
                            <th>替换模式</th>
                            <th>效果</th>
                            <th>说明</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>去除嵌套量词</td>
                            <td><code>a+b</code></td>
                            <td>快速稳定</td>
                            <td>等价于“若干 a 后跟一个 b”，无需穷举拆分</td>
                        </tr>
                        <tr>
                            <td>使用占有量词</td>
                            <td><code>a++b</code></td>
                            <td>消除回溯</td>
                            <td>占有量词（<code>++</code>、<code>*+</code>、<code>?+</code>）不回退，减少路径尝试</td>
                        </tr>
                        <tr>
                            <td>边界锚定</td>
                            <td><code>^a+b$</code></td>
                            <td>收窄搜索空间</td>
                            <td>明确匹配范围，避免无谓的整段扫描</td>
                        </tr>
                    </tbody>
                </table>

                <h3>4. 最佳实践</h3>
                <ul>
                    <li>避免“同一字符上的嵌套量词”（如 <code>(.*)+</code>、<code>(a+)+</code>）。</li>
                    <li>优先使用“更具体的字符类与有界量词”（如 <code>[a-zA-Z0-9]{1,20}</code> 替代 <code>.*</code>）。</li>
                    <li>在不需要回退时使用占有量词（<code>*+</code>、<code>++</code>、<code>?+</code>）。</li>
                    <li>通过边界（<code>^</code>、<code>$</code>、<code>\b</code>）或上下文限制（前后查找）缩小匹配范围。</li>
                    <li>减少重叠的交替分支（将 <code>(ab|a)</code> 改写为 <code>a(b)?</code>）。</li>
                    <li>为最坏情况做测试与基准，避免在不可信输入上使用过于宽泛的模式。</li>
                </ul>
            </div>
        </section>

        <!-- Slide 19: Common Pitfalls and Performance -->
        <section class="slide">
            <div class="slide-content">
                <h2>常见陷阱与性能优化</h2>

                <div class="pitfalls-performance">
                    <div class="practice-section">
                        <h3>⚠️ 常见陷阱</h3>
                <div class="pitfall-list">
                    <div class="pitfall-item">
                        <h4>贪婪匹配问题</h4>
                        <p><code>.*</code> 会尽可能多地匹配字符，建议使用 <code>.*?</code> 进行非贪婪匹配。</p>
                    </div>
                            <div class="pitfall-item">
                                <h4>转义字符混乱</h4>
                                <p>Java字符串中的反斜杠需要双重转义</p>
                                <pre><code class="language-java">// 错误：编译时报错
Pattern.compile("\d+");

// 正确：双重转义
Pattern.compile("\\d+");

// 或使用字符类
Pattern.compile("[0-9]+");</code></pre>
                            </div>
                            <div class="pitfall-item">
                                <h4>回溯爆炸</h4>
                                <p>复杂的正则表达式可能导致回溯爆炸，影响性能</p>
                                <pre><code class="language-java">// 危险：可能导致性能问题
Pattern.compile("(a+)+b");

// 安全：更好的选择
Pattern.compile("a+b");

// 使用原子分组避免回溯
Pattern.compile("(?>a+)b");</code></pre>
                            </div>
                            <div class="pitfall-item">
                                <h4>边界匹配误用</h4>
                                <p>混淆字符串边界和单词边界</p>
                                <pre><code class="language-java">String text = "hello world";

// 字符串边界
Pattern.compile("^hello").matcher(text).find();  // true

// 单词边界
Pattern.compile("\\bhello\\b").matcher(text).find();  // true
Pattern.compile("\\bworld\\b").matcher(text).find();  // true</code></pre>
                            </div>
                        </div>
                    </div>

                    <div class="practice-section">
                        <h3>🚀 性能优化建议</h3>
                        <div class="tip-grid">
                            <div class="tip-item">
                                <h4>使用具体字符类</h4>
                                <p>用 <code>[0-9]</code> 替代 <code>\d</code> 在某些情况下更快</p>
                                <pre><code class="language-java">// 更快的数字匹配
Pattern.compile("[0-9]+");
// 而不是
Pattern.compile("\\d+");</code></pre>
                            </div>
                            <div class="tip-item">
                                <h4>避免过度使用分组</h4>
                                <p>不需要捕获时使用非捕获组 <code>(?:...)</code></p>
                                <pre><code class="language-java">// 非捕获分组，性能更好
Pattern.compile("(?:abc|def)+");
// 而不是
Pattern.compile("(abc|def)+");</code></pre>
                            </div>
                            <div class="tip-item">
                                <h4>锚定匹配</h4>
                                <p>使用 <code>^</code> 和 <code>$</code> 限制匹配范围</p>
                                <pre><code class="language-java">// 精确匹配，避免不必要的搜索
Pattern.compile("^\\d{3}-\\d{2}-\\d{4}$");
// 而不是
Pattern.compile("\\d{3}-\\d{2}-\\d{4}");</code></pre>
                            </div>
                            <div class="tip-item">
                                <h4>预编译和重用</h4>
                                <p>重复使用的正则表达式应该预编译并缓存</p>
                                <pre><code class="language-java">// 使用静态常量
private static final Pattern PATTERN = 
    Pattern.compile("regex");

// 或使用缓存
private static final Map&lt;String, Pattern&gt; 
    PATTERN_CACHE = new ConcurrentHashMap&lt;&gt;();</code></pre>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>





        <!-- UI Elements -->
        <div class="progress-bar-container">
            <div id="progress-bar"></div>
        </div>
        <div class="controls">
            <button id="prevBtn">上一页</button>
            <span id="slide-counter">1 / X</span>
            <button id="nextBtn">下一页</button>
        </div>
    </main>



    

    <script src="../prism/prism.js"></script>
    <script src="./js/ppt.js"></script>
    <script src="../prism/prism-autoloader.min.js"></script>
    <script src="./js/nav.js"></script>
</body>
</html>