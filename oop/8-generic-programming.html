<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>泛型程序设计</title>
    <link rel="stylesheet" href="./css/style.css">
    <link rel="stylesheet" href="./css/animation.css">
    <link rel="stylesheet" href="./css/hacker-cmd.css">
    <link rel="stylesheet" href="../prism/prism.css">
</head>

<body>

    <main id="presentation">
        <!-- Slide 1: Title -->
        <section class="slide title-slide active">
            <h1>泛型程序设计</h1>
            <p>Generic Programming - Deep Dive</p>
            <strong>深入理解泛型原理、掌握类型安全编程实践</strong>
        </section>

        <!-- Quote Slide -->
        <section class="slide">
            <div class="slide-content" style="text-align: center;">
                <blockquote
                    style="font-size: 1.3em; font-style: italic; border-left: 4px solid var(--accent-color); padding-left: 20px;">
                    <p>泛型让我们能够编写类型安全且可重用的代码，是Java编程的重要基石</p>
                    <cite style="display: block; text-align: right; margin-top: 20px;">— Effective Java</cite>
                </blockquote>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>学习目标</h2>
                <ul>
                    <li><strong>深入理解泛型原理</strong>：掌握类型安全机制、类型擦除原理与实现机制</li>
                    <li><strong>精通泛型语法</strong>：泛型类、泛型方法、泛型接口的高级应用技巧</li>
                    <li><strong>掌握泛型界限</strong>：通配符、extends/super界限的灵活运用</li>
                    <li><strong>实践泛型设计</strong：自定义泛型集合类、工具类的设计与实现</li>
                    <li><strong>泛型与现代Java</strong>：泛型与Lambda、Stream API的结合使用</li>
                </ul>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>类型安全问题：从Object到泛型</h2>
                <p><strong>问题场景</strong>：设计学生成绩管理系统，需要支持不同类型的成绩表示</p>

                <h3>传统Object方案的缺陷</h3>
                <div class="code-block">
                    <pre><code class="language-java">public class Score {
    String name;
    String id;
    Object value;  //使用Object存储不同类型

    public Score(String name, String id, Object value) {
        this.name = name;
        this.id = id;
        this.value = value;
    }

    // 问题：类型不安全，运行时才暴露错误
    public Integer getScore() {
        return (Integer) value;  //可能抛出ClassCastException
    }
}</code></pre>
                </div>

                <h3>Object方案的核心问题</h3>
                <ul>
                    <li><strong>编译时类型安全缺失</strong>：无法在编译阶段发现类型错误</li>
                    <li><strong>强制类型转换</strong>：需要手动转换，增加代码复杂度</li>
                    <li><strong>运行时异常风险</strong>：ClassCastException难以预测</li>
                    <li><strong>代码可读性差</strong>：无法从类型推断出实际用途</li>
                </ul>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>泛型的解决方案</h2>
                <p><strong>泛型的核心价值</strong>：将类型安全从运行时前移到编译时</p>

                <div class="code-block">
                    <pre><code class="language-java">// 泛型解决方案
public class Score&lt;T&gt; {
    private final String name;
    private final String id;
    private final T value;   //类型参数T

    public Score(String name, String id, T value) {
        this.name = name;
        this.id = id;
        this.value = value;
    }

    public T getValue() {
        return value;  //无需强制转换，类型安全
    }
}</code></pre>
                </div>

                <h3>泛型带来的改进</h3>
                <div class="code-block">
                    <pre><code class="language-java">// 编译时类型安全
Score&lt;String&gt; score1 = new Score&lt;&gt;("计算机网络", "EP074512", "优秀");
Score&lt;Integer&gt; score2 = new Score&lt;&gt;("数据结构", "EP074513", 95);

// 类型明确，IDE智能提示
String result1 = score1.getValue();  //自动推断为String
Integer result2 = score2.getValue(); //自动推断为Integer

// 编译时错误检查
score1.setValue(100);  //编译错误：类型不匹配</code></pre>
                </div>

                <p class="conclusion">泛型通过类型参数将类型安全从运行时前移到编译时，实现了真正的类型安全编程。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>泛型的类型参数系统</h2>
                <p><strong>类型参数命名规范</strong>：使用有意义的单个大写字母</p>

                <div class="code-block">
                    <pre><code class="language-java">// 常用类型参数命名
E - Element (集合中的元素类型)
K - Key (映射中的键类型)
V - Value (映射中的值类型)
T - Type (通用类型参数)
N - Number (数值类型)
S, U, V - 第二、三、四个类型参数</code></pre>
                </div>

                <h3>多个类型参数的应用</h3>
                <div class="code-block">
                    <pre><code class="language-java">// 泛型类支持多个类型参数
public class Pair&lt;K, V&gt; {
    private final K key;
    private final V value;

    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    public K getKey() { return key; }
    public V getValue() { return value; }
}

// 实际使用
Pair&lt;String, Integer&gt; student = new Pair&lt;&gt;("张三", 95);
Pair&lt;String, String&gt; course = new Pair&lt;&gt;("Java", "优秀");</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>泛型的使用限制</h2>
                <p>由于类型擦除机制，泛型在使用时有一些重要限制</p>

                <h3>1. 基本类型不支持</h3>
                <div class="code-block">
                    <pre><code class="language-java">// 错误：不能使用基本类型
List&lt;int&gt; list = new ArrayList&lt;&gt;();  //编译错误

// 正确：使用包装类
List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</code></pre>
                </div>

                <h3>2. 静态上下文限制</h3>
                <div class="code-block">
                    <pre><code class="language-java">public class GenericClass&lt;T&gt; {
    // 错误：静态方法不能使用类的类型参数
    public static void staticMethod(T param) { }  //编译错误

    // 正确：静态方法需要定义自己的类型参数
    public static &lt;E&gt; void staticMethod(E param) { }
}</code></pre>
                </div>

                <h3>3. 其他重要限制</h3>
                <ul>
                    <li><strong>不能创建泛型数组</strong>：T[] array = new T[10]; // 编译错误</li>
                    <li><strong>不能进行泛型类型判断</strong>：obj instanceof List&lt;String&gt; // 编译错误</li>
                    <li><strong>不能创建泛型实例</strong>：T t = new T(); // 编译错误</li>
                </ul>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>泛型通配符</h2>
                <p>使用?通配符可以接受任意类型的泛型对象</p>
                <div class="code-block">
                    <pre><code class="language-java">public static void main(String[] args) {
    Test&lt;?&gt; test = new Test&lt;Integer&gt;();
    test = new Test&lt;String&gt;();
    Object o = test.value;    //通配符类型为Object
}</code></pre>
                </div>
                <p><strong>多个类型变量</strong>：使用逗号分隔</p>
                <div class="code-block">
                    <pre><code class="language-java">public class Test&lt;A, B, C&gt; {
    public A a;
    public B b;
    public C c;
}

Test&lt;String, Integer, Character&gt; test = new Test&lt;&gt;();</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>泛型与多态</h2>
                <p>接口和抽象类都支持泛型，子类可以明确类型或继续使用泛型</p>
                <div class="code-block">
                    <pre><code class="language-java">public interface Study&lt;T&gt; {
    T test();
}

// 明确泛型类型
static class A implements Study&lt;Integer&gt; {
    @Override
    public Integer test() {
        return null;
    }
}

// 继续使用泛型
static class B&lt;T&gt; implements Study&lt;T&gt; {
    @Override
    public T test() {
        return null;
    }
}</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>泛型方法</h2>
                <p>当方法需要接受的参数类型不确定时，可以定义泛型方法</p>
                <div class="code-block">
                    <pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        String str = test("Hello World!");
    }

    private static &lt;T&gt; T test(T t){
        // 在返回值类型前添加&lt;&gt;并填写泛型变量
        return t;
    }
}</code></pre>
                </div>
                <p><strong>实际应用示例</strong>：</p>
                <div class="code-block">
                    <pre><code class="language-java">private &lt;T&gt; void add(T[] arr, T t){
    arr[0] = t;
}</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>泛型方法的应用</h2>
                <p>Java工具类中大量使用泛型方法</p>
                <div class="code-block">
                    <pre><code class="language-java">// Arrays.sort()使用泛型接口
Integer[] arr = {1, 4, 5, 2, 6, 3, 0, 7, 9, 8};
Arrays.sort(arr, new Comparator&lt;Integer&gt;() {
    @Override
    public int compare(Integer o1, Integer o2) {
        return o2 - o1;    // 降序排序
    }
});

// 使用Lambda表达式简化
Arrays.sort(arr, (o1, o2) -&gt; o2 - o1);</code></pre>
                </div>
                <div class="code-block">
                    <pre><code class="language-java">// 数组复制方法
String[] arr = {"AAA", "BBB", "CCC"};
String[] newArr = Arrays.copyOf(arr, 3);  //泛型方法</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>泛型界限</h2>
                <p>可以限制泛型的类型范围，只允许特定类型或其子类</p>
                <div class="code-block">
                    <pre><code class="language-java">public class Score&lt;T extends Number&gt; {
    // 设定类型参数上界，必须是Number或是Number的子类
    private final String name;
    private final String id;
    private final T value;

    public Score(String name, String id, T value) {
        this.name = name;
        this.id = id;
        this.value = value;
    }
}</code></pre>
                </div>
                <p><strong>使用限制</strong>：具体类型只能是指定上界类型或其子类</p>
                <div class="code-block">
                    <pre><code class="language-java">Score&lt;Integer&gt; score1 = new Score&lt;&gt;("数据结构", "EP074512", 95);  //正确
Score&lt;String&gt; score2 = new Score&lt;&gt;("计算机网络", "EP074513", "优秀");  //编译错误</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>泛型界限的通配符使用</h2>
                <p>通配符也支持泛型界限</p>
                <div class="code-block">
                    <pre><code class="language-java">// 上界通配符
Score&lt;? extends Integer&gt; score = new Score&lt;&gt;("数据结构", "EP074512", 60);
Number o = score.getValue();   //类型为上界Number

// 下界通配符（仅适用于通配符）
Score&lt;? super Number&gt; score2 = new Score&lt;&gt;("数据结构", "EP074512", 60);
Object obj = score2.getValue();   //类型仍为Object</code></pre>
                </div>
                <p class="conclusion">通过设定泛型上限，可以更灵活地控制泛型的具体类型范围。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>类型擦除深度解析</h2>
                <p><strong>什么是类型擦除</strong>：Java泛型是编译时特性，在运行时类型信息会被擦除</p>

                <h3>类型擦除的基本规则</h3>
                <div class="code-block">
                    <pre><code class="language-java">// 编译时：泛型版本
public class GenericContainer&lt;T&gt; {
    private T element;

    public void set(T element) { this.element = element; }
    public T get() { return element; }
}

// 运行时：类型擦除后
public class GenericContainer {
    private Object element;

    public void set(Object element) { this.element = element; }
    public Object get() { return element; }
}</code></pre>
                </div>

                <h3>类型擦除的两种情况</h3>
                <ul>
                    <li><strong>无界类型擦除</strong>：&lt;T&gt; → Object</li>
                    <li><strong>有界类型擦除</strong>：&lt;T extends Number&gt; → Number</li>
                </ul>

                <p class="conclusion">类型擦除保证了向后兼容性，但同时也带来了一些限制。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>类型擦除的影响与桥接方法</h2>
                <h3>类型擦除的核心影响</h3>
                <ul>
                    <li><strong>编译时类型检查</strong>：泛型仅在编译阶段进行类型安全检查</li>
                    <li><strong>运行时类型信息丢失</strong>：泛型类型信息在运行时被擦除</li>
                    <li><strong>自动类型转换</strong>：编译器自动插入强制类型转换</li>
                    <li><strong>桥接方法生成</strong>：保持多态的兼容性</li>
                </ul>

                <h3>桥接方法的生成</h3>
                <div class="code-block">
                    <pre><code class="language-java">// 源代码
public class StringComparator implements Comparator&lt;String&gt; {
    @Override
    public int compare(String s1, String s2) {
        return s1.length() - s2.length();
    }
}

// 编译后：实际生成两个方法
public class StringComparator implements Comparator {
    // 原始方法
    public int compare(String s1, String s2) {
        return s1.length() - s2.length();
    }

    // 桥接方法（编译器自动生成）
    public int compare(Object o1, Object o2) {
        return compare((String) o1, (String) o2);
    }
}</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>泛型与反射的结合</h2>
                <p>虽然类型擦除会丢失泛型信息，但Java通过反射机制保留部分泛型元数据</p>

                <h3>获取泛型信息</h3>
                <div class="code-block">
                    <pre><code class="language-java">public class GenericClass&lt;T&gt; {
    private List&lt;T&gt; items;
    private Map&lt;String, T&gt; cache;

    // 通过反射获取字段的泛型类型信息
    public static void analyzeGenericFields() throws Exception {
        Field itemsField = GenericClass.class.getDeclaredField("items");
        Type itemsType = itemsField.getGenericType();

        if (itemsType instanceof ParameterizedType) {
            ParameterizedType pType = (ParameterizedType) itemsType;
            System.out.println("原始类型: " + pType.getRawType());
            System.out.println("类型参数: " + Arrays.toString(pType.getActualTypeArguments()));
        }
    }
}</code></pre>
                </div>

                <h3>反射操作泛型</h3>
                <div class="code-block">
                    <pre><code class="language-java">// 创建泛型类型的实例
public static &lt;T&gt; T createInstance(Class&lt;T&gt; clazz) throws Exception {
    return clazz.getDeclaredConstructor().newInstance();
}

// 获取方法的泛型返回类型
Method method = GenericClass.class.getMethod("getItems");
Type returnType = method.getGenericReturnType();</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>函数式接口概述</h2>
                <p>JDK 1.8新增的专门用于Lambda表达式的接口</p>
                <ul>
                    <li><strong>Supplier&lt;T&gt;</strong>：供给型函数式接口，提供对象</li>
                    <li><strong>Consumer&lt;T&gt;</strong>：消费型函数式接口，消费对象</li>
                    <li><strong>Function&lt;T,R&gt;</strong>：函数型函数式接口，转换对象</li>
                    <li><strong>Predicate&lt;T&gt;</strong>：断言型函数式接口，判断条件</li>
                </ul>
                <p class="conclusion">这些接口都可以直接使用Lambda表达式，极大简化代码编写。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>Supplier供给型接口</h2>
                <p>专门用于供给使用的接口，只有一个get方法</p>
                <div class="code-block">
                    <pre><code class="language-java">@FunctionalInterface
public interface Supplier&lt;T&gt; {
    T get();   //实现此方法，实现供给功能
}</code></pre>
                </div>
                <div class="code-block">
                    <pre><code class="language-java">public class Student {
    public void hello(){
        System.out.println("我是学生！");
    }
}

// 专门供给Student对象的Supplier
private static final Supplier&lt;Student&gt; STUDENT_SUPPLIER = Student::new;
public static void main(String[] args) {
    Student student = STUDENT_SUPPLIER.get();
    student.hello();
}</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>Consumer消费型接口</h2>
                <p>专门用于消费某个对象的接口</p>
                <div class="code-block">
                    <pre><code class="language-java">@FunctionalInterface
public interface Consumer&lt;T&gt; {
    void accept(T t);    //消费方法，没有返回值

    default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) {
        Objects.requireNonNull(after);
        return (T t) -&gt; { accept(t); after.accept(t); };
    }
}</code></pre>
                </div>
                <div class="code-block">
                    <pre><code class="language-java">// 专门消费Student对象的Consumer
private static final Consumer&lt;Student&gt; STUDENT_CONSUMER =
    student -&gt; System.out.println(student + " 真好吃！");

public static void main(String[] args) {
    Student student = new Student();
    STUDENT_CONSUMER.accept(student);
}</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>Consumer链式调用</h2>
                <p>使用andThen方法实现连续消费</p>
                <div class="code-block">
                    <pre><code class="language-java">public static void main(String[] args) {
    Student student = new Student();
    STUDENT_CONSUMER
        .andThen(stu -&gt; System.out.println("我是吃完之后的操作！"))
        .andThen(stu -&gt; System.out.println("好了好了，吃饱了！"))
        .accept(student);   //执行链式操作
}</code></pre>
                </div>
                <p class="conclusion">使用简洁的代码就可以实现复杂的消费逻辑链。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>Function函数型接口</h2>
                <p>消费一个对象，供给一个对象（前两个的融合体）</p>
                <div class="code-block">
                    <pre><code class="language-java">@FunctionalInterface
public interface Function&lt;T, R&gt; {
    R apply(T t);   //接受的参数类型，返回的结果类型

    default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) { }
    default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) { }
    static &lt;T&gt; Function&lt;T, T&gt; identity() { return t -&gt; t; }
}</code></pre>
                </div>
                <div class="code-block">
                    <pre><code class="language-java">// 将int参数转换为字符串
private static final Function&lt;Integer, String&gt; INTEGER_STRING_FUNCTION =
    Object::toString;
public static void main(String[] args) {
    String str = INTEGER_STRING_FUNCTION.apply(10);
    System.out.println(str);
}</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>Function组合操作</h2>
                <p>使用compose和andThen进行函数组合</p>
                <div class="code-block">
                    <pre><code class="language-java">public static void main(String[] args) {
    // compose：将指定函数的结果作为当前函数的实参
    String str = INTEGER_STRING_FUNCTION
        .compose((String s) -&gt; s.length())
        .apply("lbwnb");

    // andThen：将当前实现的返回值进行进一步处理
    Boolean result = INTEGER_STRING_FUNCTION
        .andThen(String::isEmpty)
        .apply(10);
}</code></pre>
                </div>
                <div class="code-block">
                    <pre><code class="language-java">// identity：原样返回
Function&lt;String, String&gt; function = Function.identity();
System.out.println(function.apply("不会吧不会吧，不会有人听到现在还是懵逼的吧"));</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>Predicate断言型接口</h2>
                <p>接收一个参数，进行自定义判断并返回boolean结果</p>
                <div class="code-block">
                    <pre><code class="language-java">@FunctionalInterface
public interface Predicate&lt;T&gt; {
    boolean test(T t);    //判断方法

    default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) { }
    default Predicate&lt;T&gt; negate() { return (t) -&gt; !test(t); }
    default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) { }
    static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) { }
}</code></pre>
                </div>
                <div class="code-block">
                    <pre><code class="language-java">public class Student {
    public int score;
}

private static final Predicate&lt;Student&gt; STUDENT_PREDICATE =
    student -&gt; student.score &gt;= 60;

public static void main(String[] args) {
    Student student = new Student();
    student.score = 80;
    if(STUDENT_PREDICATE.test(student)) {
        System.out.println("及格了，真不错，今晚奖励自己一次");
    }
}</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>Predicate组合条件</h2>
                <p>支持多个条件的组合判断</p>
                <div class="code-block">
                    <pre><code class="language-java">public static void main(String[] args) {
    Student student = new Student();
    student.score = 80;

    // and操作：需要同时满足所有条件
    boolean b1 = STUDENT_PREDICATE
        .and(stu -&gt; stu.score &gt; 90)
        .test(student);

    // negate操作：取反
    boolean b2 = STUDENT_PREDICATE.negate().test(student);

    // or操作：满足任意一个条件
    boolean b3 = STUDENT_PREDICATE
        .or(stu -&gt; student.score &gt; 90)
        .test(student);
}</code></pre>
                </div>
                <div class="code-block">
                    <pre><code class="language-java">// isEqual：判断两个对象是否相等
Predicate&lt;String&gt; predicate = Predicate.isEqual("Hello World");
System.out.println(predicate.test("Hello World"));  //true</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>Optional判空包装</h2>
                <p>Java8新增的判空包装类，有效处理空指针问题</p>
                <div class="code-block">
                    <pre><code class="language-java">// 传统方式：容易出现空指针异常
private static void test(String str){
    if(!str.isEmpty()) {   //传入null时直接爆炸
        System.out.println("字符串长度为："+str.length());
    }
}

// 传统解决方案：需要手动判空
private static void test(String str){
    if(str == null) return;
    if(!str.isEmpty()) {
        System.out.println("字符串长度为："+str.length());
    }
}</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>Optional优雅处理空值</h2>
                <p>使用Optional让空值处理更加优雅</p>
                <div class="code-block">
                    <pre><code class="language-java">private static void test(String str){
    Optional
        .ofNullable(str)   //将传入的对象包装进Optional中
        .ifPresent(s -&gt; System.out.println("字符串长度为："+s.length()));
        // 如果不为空，则执行Consumer实现
}</code></pre>
                </div>
                <p><strong>Optional的常用方法</strong>：</p>
                <div class="code-block">
                    <pre><code class="language-java">// get方法：获取被包装的对象（为空会抛出异常）
String s = Optional.ofNullable(str).get();

// orElse方法：为空时返回备选方案
String s = Optional.ofNullable(str).orElse("我是为null的情况备选方案");

// map方法：转换为另一种类型
Integer i = Optional.ofNullable(str)
    .map(String::length)
    .orElse(-1);</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>泛型实战应用：自定义集合框架</h2>
                <p><strong>目标</strong>：通过实现自定义泛型集合类，深入理解泛型的实际应用</p>

                <h3>实战1：泛型动态数组实现</h3>
                <div class="code-block">
                    <pre><code class="language-java">public class GenericArrayList&lt;E&gt; {
    private static final int DEFAULT_CAPACITY = 10;
    private Object[] elements;
    private int size;

    public GenericArrayList() {
        this.elements = new Object[DEFAULT_CAPACITY];
        this.size = 0;
    }

    // 泛型添加方法
    public boolean add(E element) {
        ensureCapacity();
        elements[size++] = element;
        return true;
    }

    // 泛型获取方法
    @SuppressWarnings("unchecked")
    public E get(int index) {
        checkIndex(index);
        return (E) elements[index];
    }

    // 泛型设置方法
    @SuppressWarnings("unchecked")
    public E set(int index, E element) {
        checkIndex(index);
        E oldValue = (E) elements[index];
        elements[index] = element;
        return oldValue;
    }
}</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>泛型动态数组：进阶功能</h2>
                <h3>实现迭代器和类型安全</h3>
                <div class="code-block">
                    <pre><code class="language-java">public class GenericArrayList&lt;E&gt; implements Iterable&lt;E&gt; {
    // ... 前面的代码

    // 实现Iterable接口
    @Override
    public Iterator&lt;E&gt; iterator() {
        return new GenericArrayListIterator();
    }

    // 内部迭代器类
    private class GenericArrayListIterator implements Iterator&lt;E&gt; {
        private int currentIndex = 0;

        @Override
        public boolean hasNext() {
            return currentIndex &lt; size;
        }

        @Override
        @SuppressWarnings("unchecked")
        public E next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            return (E) elements[currentIndex++];
        }
    }

    // 泛型删除方法
    @SuppressWarnings("unchecked")
    public E remove(int index) {
        checkIndex(index);
        E oldValue = (E) elements[index];

        int numMoved = size - index - 1;
        if (numMoved &gt; 0) {
            System.arraycopy(elements, index + 1, elements, index, numMoved);
        }

        elements[--size] = null; // 清理引用
        return oldValue;
    }
}</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>泛型实战应用：工具类设计</h2>
                <h3>实战2：泛型工具类</h3>
                <div class="code-block">
                    <pre><code class="language-java">public class GenericUtils {
    // 泛型交换方法
    public static &lt;T&gt; void swap(T[] array, int i, int j) {
        T temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    // 泛型查找最大值
    public static &lt;T extends Comparable&lt;T&gt;&gt; T findMax(T[] array) {
        if (array == null || array.length == 0) {
            return null;
        }

        T max = array[0];
        for (int i = 1; i &lt; array.length; i++) {
            if (array[i].compareTo(max) &gt; 0) {
                max = array[i];
            }
        }
        return max;
    }

    // 泛型反转数组
    public static &lt;T&gt; void reverse(T[] array) {
        int left = 0;
        int right = array.length - 1;
        while (left &lt; right) {
            swap(array, left, right);
            left++;
            right--;
        }
    }
}</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>泛型实战应用：设计模式</h2>
                <h3>实战3：泛型工厂模式</h3>
                <div class="code-block">
                    <pre><code class="language-java">// 泛型工厂接口
public interface GenericFactory&lt;T&gt; {
    T create();
}

// 具体工厂实现
public class StudentFactory implements GenericFactory&lt;Student&gt; {
    @Override
    public Student create() {
        return new Student();
    }
}

// 泛型工厂管理器
public class FactoryManager {
    private static final Map&lt;Class&lt;?&gt;, GenericFactory&lt;?&gt;&gt; factories = new HashMap&lt;&gt;();

    @SuppressWarnings("unchecked")
    public static &lt;T&gt; T createInstance(Class&lt;T&gt; type) {
        GenericFactory&lt;T&gt; factory = (GenericFactory&lt;T&gt;) factories.get(type);
        if (factory == null) {
            throw new IllegalArgumentException("No factory registered for " + type);
        }
        return factory.create();
    }

    public static &lt;T&gt; void registerFactory(Class&lt;T&gt; type, GenericFactory&lt;T&gt; factory) {
        factories.put(type, factory);
    }
}</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>泛型实战应用：Builder模式</h2>
                <h3>实战4：类型安全的Builder</h3>
                <div class="code-block">
                    <pre><code class="language-java">public class GenericBuilder&lt;T&gt; {
    private final Supplier&lt;T&gt; supplier;
    private final List&lt;Consumer&lt;T&gt;&gt; modifiers = new ArrayList&lt;&gt;();

    private GenericBuilder(Supplier&lt;T&gt; supplier) {
        this.supplier = supplier;
    }

    public static &lt;T&gt; GenericBuilder&lt;T&gt; of(Supplier&lt;T&gt; supplier) {
        return new GenericBuilder&lt;&gt;(supplier);
    }

    public &lt;P&gt; GenericBuilder&lt;T&gt; with(BiConsumer&lt;T, P&gt; consumer, P value) {
        Consumer&lt;T&gt; modifier = instance -&gt; consumer.accept(instance, value);
        modifiers.add(modifier);
        return this;
    }

    public T build() {
        T instance = supplier.get();
        modifiers.forEach(modifier -&gt; modifier.accept(instance));
        return instance;
    }
}

// 使用示例
Student student = GenericBuilder.of(Student::new)
    .with(Student::setName, "张三")
    .with(Student::setAge, 20)
    .with(Student::setScore, 95.5)
    .build();</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>泛型实战应用：类型安全的容器</h2>
                <h3>实战5：泛型缓存容器</h3>
                <div class="code-block">
                    <pre><code class="language-java">public class GenericCache&lt;K, V&gt; {
    private final Map&lt;K, V&gt; cache = new HashMap&lt;&gt;();
    private final Function&lt;K, V&gt; loader;
    private final int maxSize;

    public GenericCache(Function&lt;K, V&gt; loader, int maxSize) {
        this.loader = loader;
        this.maxSize = maxSize;
    }

    public V get(K key) {
        V value = cache.get(key);
        if (value == null) {
            value = loader.apply(key);
            if (cache.size() &gt;= maxSize) {
                // 简单的LRU策略：移除第一个元素
                K firstKey = cache.keySet().iterator().next();
                cache.remove(firstKey);
            }
            cache.put(key, value);
        }
        return value;
    }

    public void put(K key, V value) {
        if (cache.size() &gt;= maxSize) {
            K firstKey = cache.keySet().iterator().next();
            cache.remove(firstKey);
        }
        cache.put(key, value);
    }
}</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>泛型实战应用：事件处理系统</h2>
                <h3>实战6：类型安全的事件总线</h3>
                <div class="code-block">
                    <pre><code class="language-java">public class GenericEventBus {
    private final Map&lt;Class&lt;?&gt;, List&lt;Consumer&lt;?&gt;&gt;&gt; listeners = new ConcurrentHashMap&lt;&gt;();

    @SuppressWarnings("unchecked")
    public &lt;T&gt; void subscribe(Class&lt;T&gt; eventType, Consumer&lt;T&gt; listener) {
        listeners.computeIfAbsent(eventType, k -&gt; new ArrayList&lt;&gt;())
                  .add(listener);
    }

    @SuppressWarnings("unchecked")
    public &lt;T&gt; void publish(T event) {
        Class&lt;T eventType = (Class&lt;T&gt;) event.getClass();
        List&lt;Consumer&lt;?&gt;&gt; eventListeners = listeners.get(eventType);

        if (eventListeners != null) {
            eventListeners.forEach(listener -&gt;
                ((Consumer&lt;T&gt;) listener).accept(event));
        }
    }

    public &lt;T&gt; void unsubscribe(Class&lt;T&gt; eventType, Consumer&lt;T&gt; listener) {
        List&lt;Consumer&lt;?&gt;&gt; eventListeners = listeners.get(eventType);
        if (eventListeners != null) {
            eventListeners.remove(listener);
            if (eventListeners.isEmpty()) {
                listeners.remove(eventType);
            }
        }
    }
}</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>泛型实战练习：类型安全的JSON解析器</h2>
                <p><strong>目标</strong>：实现一个支持泛型的简单JSON解析器，展示泛型在实际项目中的应用</p>

                <div class="code-block">
                    <pre><code class="language-java">// 泛型JSON解析器接口
public interface JsonParser&lt;T&gt; {
    T parse(String json);
    String toJson(T object);
}

// 通用JSON解析器实现
public class GenericJsonParser {

    @SuppressWarnings("unchecked")
    public static &lt;T&gt; T parse(String json, Class&lt;T&gt; clazz) {
        if (json == null || json.trim().isEmpty()) {
            return null;
        }

        // 简化实现：仅支持基本类型和字符串
        if (clazz == String.class) {
            return (T) json.replace("\"", "");
        } else if (clazz == Integer.class || clazz == int.class) {
            return (T) Integer.valueOf(json);
        } else if (clazz == Boolean.class || clazz == boolean.class) {
            return (T) Boolean.valueOf(json);
        } else {
            throw new IllegalArgumentException("Unsupported type: " + clazz);
        }
    }

    public static &lt;T&gt; String toJson(T object) {
        if (object == null) {
            return "null";
        } else if (object instanceof String) {
            return "\"" + object + "\"";
        } else {
            return object.toString();
        }
    }
}</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>泛型实战练习：类型安全的配置管理器</h2>
                <p><strong>目标</strong>：实现一个类型安全的配置管理器，避免运行时类型转换错误</p>

                <div class="code-block">
                    <pre><code class="language-java">public class GenericConfigManager {
    private final Map&lt;String, Object&gt; configurations = new HashMap&lt;&gt;();

    // 类型安全的配置设置
    public &lt;T&gt; void setConfig(String key, T value) {
        configurations.put(key, value);
    }

    // 类型安全的配置获取
    @SuppressWarnings("unchecked")
    public &lt;T&gt; T getConfig(String key, Class&lt;T&gt; type) {
        Object value = configurations.get(key);
        if (value == null) {
            return null;
        }

        if (!type.isInstance(value)) {
            throw new ClassCastException(
                String.format("Configuration '%s' is of type %s, but %s was requested",
                    key, value.getClass().getSimpleName(), type.getSimpleName()));
        }

        return (T) value;
    }

    // 带默认值的配置获取
    public &lt;T&gt; T getConfig(String key, Class&lt;T&gt; type, T defaultValue) {
        T value = getConfig(key, type);
        return value != null ? value : defaultValue;
    }

    // 批量配置加载
    public void loadFromProperties(Properties properties) {
        properties.forEach((key, value) -&gt; {
            if (value instanceof String) {
                setConfig(key.toString(), value);
            } else {
                setConfig(key.toString(), value.toString());
            }
        });
    }
}</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>泛型实战练习：泛型仓储模式</h2>
                <p><strong>目标</strong>：实现泛型仓储模式，展示泛型在企业级应用中的实践</p>

                <div class="code-block">
                    <pre><code class="language-java">// 泛型仓储接口
public interface GenericRepository&lt;T, ID&gt; {
    T save(T entity);
    Optional&lt;T&gt; findById(ID id);
    List&lt;T&gt; findAll();
    void deleteById(ID id);
    boolean existsById(ID id);
}

// 内存实现示例
public class InMemoryRepository&lt;T, ID&gt; implements GenericRepository&lt;T, ID&gt; {
    private final Map&lt;ID, T&gt; storage = new ConcurrentHashMap&lt;&gt;();
    private final Function&lt;T, ID&gt; idExtractor;

    public InMemoryRepository(Function&lt;T, ID&gt; idExtractor) {
        this.idExtractor = idExtractor;
    }

    @Override
    public T save(T entity) {
        ID id = idExtractor.apply(entity);
        storage.put(id, entity);
        return entity;
    }

    @Override
    public Optional&lt;T&gt; findById(ID id) {
        return Optional.ofNullable(storage.get(id));
    }

    @Override
    public List&lt;T&gt; findAll() {
        return new ArrayList&lt;&gt;(storage.values());
    }

    @Override
    public void deleteById(ID id) {
        storage.remove(id);
    }

    @Override
    public boolean existsById(ID id) {
        return storage.containsKey(id);
    }
}</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>总结</h2>
                <div class="summary-points">
                    <h3>🎯 泛型核心原理</h3>
                    <ul>
                        <li><strong>类型安全机制</strong>：从Object到泛型，实现编译时类型检查</li>
                        <li><strong>类型擦除原理</strong>：深入理解泛型在编译后的处理机制</li>
                        <li><strong>桥接方法</strong>：保证泛型重写的技术实现与多态兼容性</li>
                        <li><strong>反射结合</strong>：通过反射获取和操作泛型类型信息</li>
                    </ul>

                    <h3>🔧 泛型语法精通</h3>
                    <ul>
                        <li><strong>泛型类与接口</strong>：类型参数的定义、约束与继承关系</li>
                        <li><strong>泛型方法</strong>：静态方法中的泛型应用与类型推断</li>
                        <li><strong>通配符机制</strong>：?extends与?super的灵活运用场景</li>
                        <li><strong>泛型界限</strong>：通过extends和super约束类型范围</li>
                    </ul>

                    <h3>🚀 泛型实战应用</h3>
                    <ul>
                        <li><strong>自定义集合框架</strong>：泛型动态数组的完整实现</li>
                        <li><strong>泛型工具类</strong>：类型安全的通用工具方法设计</li>
                        <li><strong>设计模式应用</strong>：泛型工厂、Builder模式的最佳实践</li>
                        <li><strong>企业级应用</strong>：配置管理、事件总线、仓储模式等实战案例</li>
                    </ul>

                    <h3>🌟 泛型与现代Java</h3>
                    <ul>
                        <li><strong>函数式编程</strong>：泛型与Lambda、Stream API的完美结合</li>
                        <li><strong>Optional类</strong>：优雅处理空值的泛型包装方案</li>
                        <li><strong>类型安全</strong>：在现代Java开发中的不可替代作用</li>
                    </ul>
                </div>
                <p class="conclusion"><strong>泛型是Java类型系统的基石</strong>，它不仅解决了类型安全问题，更为现代Java开发提供了强大的抽象能力。掌握泛型，就是掌握编写高质量、类型安全代码的关键技能。</p>
            </div>
        </section>

        <div class="progress-bar-container">
            <div id="progress-bar"></div>
        </div>
        <div class="controls">
            <button id="prevBtn">上一页</button>
            <span id="slide-counter">1 / X</span>
            <button id="nextBtn">下一页</button>
        </div>
    </main>

    <script src="./js/animation.js"></script>
    <script src="./js/ppt.js"></script>
    <script src="../prism/prism.js"></script>
    <script src="../prism/prism-autoloader.min.js"></script>
    <script src="./js/nav.js"></script>
</body>

</html>