<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>泛型程序设计</title>
    <link rel="stylesheet" href="./css/style.css">
    <link rel="stylesheet" href="./css/animation.css">
    <link rel="stylesheet" href="./css/hacker-cmd.css">
    <link rel="stylesheet" href="../prism/prism.css">
</head>

<body>

    <main id="presentation">
        <!-- Slide 1: Title -->
        <section class="slide title-slide active">
            <h1>泛型程序设计</h1>
            <p>Generic Programming - Complete Guide</p>
            <strong>泛型、数据结构与函数式编程的系统掌握</strong>
        </section>

        <!-- Quote Slide -->
        <section class="slide">
            <div class="slide-content" style="text-align: center;">
                <blockquote
                    style="font-size: 1.3em; font-style: italic; border-left: 4px solid var(--accent-color); padding-left: 20px;">
                    <p>泛型让我们能够编写类型安全且可重用的代码，是Java编程的重要基石</p>
                    <cite style="display: block; text-align: right; margin-top: 20px;">— Effective Java</cite>
                </blockquote>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>学习目标</h2>
                <ul>
                    <li>理解泛型的概念与作用，解决类型安全问题。</li>
                    <li>掌握泛型类、泛型方法和泛型接口的使用。</li>
                    <li>了解泛型界限、类型擦除等高级特性。</li>
                    <li>掌握常见数据结构：线性表、栈、队列、树等。</li>
                    <li>理解函数式接口和Optional类的使用。</li>
                </ul>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>泛型引入</h2>
                <p>为了统计学生成绩，要求设计一个Score对象，包括课程名称、课程号、课程成绩。</p>
                <p>成绩可能是String类型（优秀、良好、合格）或Integer类型（60.0、75.5、92.5）。</p>
                <div class="code-block">
                    <pre><code class="language-java">public class Score {
    String name;
    String id;
    Object value;  //使用Object存储不同类型

    public Score(String name, String id, Object value) {
        this.name = name;
        this.id = id;
        this.value = value;
    }
}</code></pre>
                </div>
                <p class="conclusion">Object类型在编译阶段缺乏类型检查，容易出现类型转换异常。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>泛型的优势</h2>
                <p>泛型在JDK 5引入，能够在编译阶段检查类型安全，提升开发效率。</p>
                <div class="code-block">
                    <pre><code class="language-java">public class Score&lt;T&gt; {   //泛型类
    String name;
    String id;
    T value;   //T会根据使用时提供的类型自动变成对应类型

    public Score(String name, String id, T value) {
        this.name = name;
        this.id = id;
        this.value = value;
    }
}</code></pre>
                </div>
                <div class="code-block">
                    <pre><code class="language-java">Score&lt;String&gt; score = new Score&lt;&gt;("计算机网络", "EP074512", "优秀");
String value = score.value;   //类型明确，无需强制转换</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>泛型的使用注意事项</h2>
                <ul>
                    <li><strong>泛型只能用于引用类型</strong>：基本类型不支持，需要使用包装类</li>
                    <li><strong>静态方法中使用限制</strong>：静态方法无法使用类的泛型变量</li>
                    <li><strong>不能创建泛型数组</strong>：编译器禁止创建参数化类型数组</li>
                    <li><strong>不能进行类型判断</strong>：instanceof操作不支持泛型</li>
                </ul>
                <div class="code-block">
                    <pre><code class="language-java">// 错误示例
public class Test&lt;T&gt; {
    public static void test(T t) { }  //编译错误

    T[] array = new T[10];  //编译错误

    Test&lt;String&gt; test = new Test&lt;&gt;();
    if (test instanceof Test&lt;String&gt;) { }  //编译错误
}</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>泛型通配符</h2>
                <p>使用?通配符可以接受任意类型的泛型对象</p>
                <div class="code-block">
                    <pre><code class="language-java">public static void main(String[] args) {
    Test&lt;?&gt; test = new Test&lt;Integer&gt;();
    test = new Test&lt;String&gt;();
    Object o = test.value;    //通配符类型为Object
}</code></pre>
                </div>
                <p><strong>多个类型变量</strong>：使用逗号分隔</p>
                <div class="code-block">
                    <pre><code class="language-java">public class Test&lt;A, B, C&gt; {
    public A a;
    public B b;
    public C c;
}

Test&lt;String, Integer, Character&gt; test = new Test&lt;&gt;();</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>泛型与多态</h2>
                <p>接口和抽象类都支持泛型，子类可以明确类型或继续使用泛型</p>
                <div class="code-block">
                    <pre><code class="language-java">public interface Study&lt;T&gt; {
    T test();
}

// 明确泛型类型
static class A implements Study&lt;Integer&gt; {
    @Override
    public Integer test() {
        return null;
    }
}

// 继续使用泛型
static class B&lt;T&gt; implements Study&lt;T&gt; {
    @Override
    public T test() {
        return null;
    }
}</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>泛型方法</h2>
                <p>当方法需要接受的参数类型不确定时，可以定义泛型方法</p>
                <div class="code-block">
                    <pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        String str = test("Hello World!");
    }

    private static &lt;T&gt; T test(T t){
        // 在返回值类型前添加&lt;&gt;并填写泛型变量
        return t;
    }
}</code></pre>
                </div>
                <p><strong>实际应用示例</strong>：</p>
                <div class="code-block">
                    <pre><code class="language-java">private &lt;T&gt; void add(T[] arr, T t){
    arr[0] = t;
}</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>泛型方法的应用</h2>
                <p>Java工具类中大量使用泛型方法</p>
                <div class="code-block">
                    <pre><code class="language-java">// Arrays.sort()使用泛型接口
Integer[] arr = {1, 4, 5, 2, 6, 3, 0, 7, 9, 8};
Arrays.sort(arr, new Comparator&lt;Integer&gt;() {
    @Override
    public int compare(Integer o1, Integer o2) {
        return o2 - o1;    // 降序排序
    }
});

// 使用Lambda表达式简化
Arrays.sort(arr, (o1, o2) -&gt; o2 - o1);</code></pre>
                </div>
                <div class="code-block">
                    <pre><code class="language-java">// 数组复制方法
String[] arr = {"AAA", "BBB", "CCC"};
String[] newArr = Arrays.copyOf(arr, 3);  //泛型方法</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>泛型界限</h2>
                <p>可以限制泛型的类型范围，只允许特定类型或其子类</p>
                <div class="code-block">
                    <pre><code class="language-java">public class Score&lt;T extends Number&gt; {
    // 设定类型参数上界，必须是Number或是Number的子类
    private final String name;
    private final String id;
    private final T value;

    public Score(String name, String id, T value) {
        this.name = name;
        this.id = id;
        this.value = value;
    }
}</code></pre>
                </div>
                <p><strong>使用限制</strong>：具体类型只能是指定上界类型或其子类</p>
                <div class="code-block">
                    <pre><code class="language-java">Score&lt;Integer&gt; score1 = new Score&lt;&gt;("数据结构", "EP074512", 95);  //正确
Score&lt;String&gt; score2 = new Score&lt;&gt;("计算机网络", "EP074513", "优秀");  //编译错误</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>泛型界限的通配符使用</h2>
                <p>通配符也支持泛型界限</p>
                <div class="code-block">
                    <pre><code class="language-java">// 上界通配符
Score&lt;? extends Integer&gt; score = new Score&lt;&gt;("数据结构", "EP074512", 60);
Number o = score.getValue();   //类型为上界Number

// 下界通配符（仅适用于通配符）
Score&lt;? super Number&gt; score2 = new Score&lt;&gt;("数据结构", "EP074512", 60);
Object obj = score2.getValue();   //类型仍为Object</code></pre>
                </div>
                <p class="conclusion">通过设定泛型上限，可以更灵活地控制泛型的具体类型范围。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>类型擦除</h2>
                <p>Java中泛型是编译时特性，运行时会被擦除为原始类型</p>
                <div class="code-block">
                    <pre><code class="language-java">// 编译前
public abstract class A&lt;T&gt;{
    abstract T test(T t);
}

// 编译后（类型擦除）
public abstract class A {
    abstract Object test(Object t);
}</code></pre>
                </div>
                <p><strong>设定上界的情况</strong>：</p>
                <div class="code-block">
                    <pre><code class="language-java">// 编译前
public abstract class A&lt;T extends Number&gt;{
    abstract T test(T t);
}

// 编译后
public abstract class A {
    abstract Number test(Number t);
}</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>类型擦除的影响</h2>
                <ul>
                    <li>泛型仅在编译阶段进行类型检查</li>
                    <li>运行时不检查具体类型，可以不指定类型使用</li>
                    <li>编译器会自动插入强制类型转换</li>
                    <li>桥接方法支持重写兼容性</li>
                </ul>
                <div class="code-block">
                    <pre><code class="language-java">// 不指定类型也是可以的（会有警告）
Test test = new Test();    //默认是原始类型

// 编译后实际是这样的
A a = new B();
String i = (String) a.test("10");   //自动插入强制转换</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>函数式接口概述</h2>
                <p>JDK 1.8新增的专门用于Lambda表达式的接口</p>
                <ul>
                    <li><strong>Supplier&lt;T&gt;</strong>：供给型函数式接口，提供对象</li>
                    <li><strong>Consumer&lt;T&gt;</strong>：消费型函数式接口，消费对象</li>
                    <li><strong>Function&lt;T,R&gt;</strong>：函数型函数式接口，转换对象</li>
                    <li><strong>Predicate&lt;T&gt;</strong>：断言型函数式接口，判断条件</li>
                </ul>
                <p class="conclusion">这些接口都可以直接使用Lambda表达式，极大简化代码编写。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>Supplier供给型接口</h2>
                <p>专门用于供给使用的接口，只有一个get方法</p>
                <div class="code-block">
                    <pre><code class="language-java">@FunctionalInterface
public interface Supplier&lt;T&gt; {
    T get();   //实现此方法，实现供给功能
}</code></pre>
                </div>
                <div class="code-block">
                    <pre><code class="language-java">public class Student {
    public void hello(){
        System.out.println("我是学生！");
    }
}

// 专门供给Student对象的Supplier
private static final Supplier&lt;Student&gt; STUDENT_SUPPLIER = Student::new;
public static void main(String[] args) {
    Student student = STUDENT_SUPPLIER.get();
    student.hello();
}</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>Consumer消费型接口</h2>
                <p>专门用于消费某个对象的接口</p>
                <div class="code-block">
                    <pre><code class="language-java">@FunctionalInterface
public interface Consumer&lt;T&gt; {
    void accept(T t);    //消费方法，没有返回值

    default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) {
        Objects.requireNonNull(after);
        return (T t) -&gt; { accept(t); after.accept(t); };
    }
}</code></pre>
                </div>
                <div class="code-block">
                    <pre><code class="language-java">// 专门消费Student对象的Consumer
private static final Consumer&lt;Student&gt; STUDENT_CONSUMER =
    student -&gt; System.out.println(student + " 真好吃！");

public static void main(String[] args) {
    Student student = new Student();
    STUDENT_CONSUMER.accept(student);
}</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>Consumer链式调用</h2>
                <p>使用andThen方法实现连续消费</p>
                <div class="code-block">
                    <pre><code class="language-java">public static void main(String[] args) {
    Student student = new Student();
    STUDENT_CONSUMER
        .andThen(stu -&gt; System.out.println("我是吃完之后的操作！"))
        .andThen(stu -&gt; System.out.println("好了好了，吃饱了！"))
        .accept(student);   //执行链式操作
}</code></pre>
                </div>
                <p class="conclusion">使用简洁的代码就可以实现复杂的消费逻辑链。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>Function函数型接口</h2>
                <p>消费一个对象，供给一个对象（前两个的融合体）</p>
                <div class="code-block">
                    <pre><code class="language-java">@FunctionalInterface
public interface Function&lt;T, R&gt; {
    R apply(T t);   //接受的参数类型，返回的结果类型

    default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) { }
    default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) { }
    static &lt;T&gt; Function&lt;T, T&gt; identity() { return t -&gt; t; }
}</code></pre>
                </div>
                <div class="code-block">
                    <pre><code class="language-java">// 将int参数转换为字符串
private static final Function&lt;Integer, String&gt; INTEGER_STRING_FUNCTION =
    Object::toString;
public static void main(String[] args) {
    String str = INTEGER_STRING_FUNCTION.apply(10);
    System.out.println(str);
}</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>Function组合操作</h2>
                <p>使用compose和andThen进行函数组合</p>
                <div class="code-block">
                    <pre><code class="language-java">public static void main(String[] args) {
    // compose：将指定函数的结果作为当前函数的实参
    String str = INTEGER_STRING_FUNCTION
        .compose((String s) -&gt; s.length())
        .apply("lbwnb");

    // andThen：将当前实现的返回值进行进一步处理
    Boolean result = INTEGER_STRING_FUNCTION
        .andThen(String::isEmpty)
        .apply(10);
}</code></pre>
                </div>
                <div class="code-block">
                    <pre><code class="language-java">// identity：原样返回
Function&lt;String, String&gt; function = Function.identity();
System.out.println(function.apply("不会吧不会吧，不会有人听到现在还是懵逼的吧"));</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>Predicate断言型接口</h2>
                <p>接收一个参数，进行自定义判断并返回boolean结果</p>
                <div class="code-block">
                    <pre><code class="language-java">@FunctionalInterface
public interface Predicate&lt;T&gt; {
    boolean test(T t);    //判断方法

    default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) { }
    default Predicate&lt;T&gt; negate() { return (t) -&gt; !test(t); }
    default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) { }
    static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) { }
}</code></pre>
                </div>
                <div class="code-block">
                    <pre><code class="language-java">public class Student {
    public int score;
}

private static final Predicate&lt;Student&gt; STUDENT_PREDICATE =
    student -&gt; student.score &gt;= 60;

public static void main(String[] args) {
    Student student = new Student();
    student.score = 80;
    if(STUDENT_PREDICATE.test(student)) {
        System.out.println("及格了，真不错，今晚奖励自己一次");
    }
}</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>Predicate组合条件</h2>
                <p>支持多个条件的组合判断</p>
                <div class="code-block">
                    <pre><code class="language-java">public static void main(String[] args) {
    Student student = new Student();
    student.score = 80;

    // and操作：需要同时满足所有条件
    boolean b1 = STUDENT_PREDICATE
        .and(stu -&gt; stu.score &gt; 90)
        .test(student);

    // negate操作：取反
    boolean b2 = STUDENT_PREDICATE.negate().test(student);

    // or操作：满足任意一个条件
    boolean b3 = STUDENT_PREDICATE
        .or(stu -&gt; student.score &gt; 90)
        .test(student);
}</code></pre>
                </div>
                <div class="code-block">
                    <pre><code class="language-java">// isEqual：判断两个对象是否相等
Predicate&lt;String&gt; predicate = Predicate.isEqual("Hello World");
System.out.println(predicate.test("Hello World"));  //true</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>Optional判空包装</h2>
                <p>Java8新增的判空包装类，有效处理空指针问题</p>
                <div class="code-block">
                    <pre><code class="language-java">// 传统方式：容易出现空指针异常
private static void test(String str){
    if(!str.isEmpty()) {   //传入null时直接爆炸
        System.out.println("字符串长度为："+str.length());
    }
}

// 传统解决方案：需要手动判空
private static void test(String str){
    if(str == null) return;
    if(!str.isEmpty()) {
        System.out.println("字符串长度为："+str.length());
    }
}</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>Optional优雅处理空值</h2>
                <p>使用Optional让空值处理更加优雅</p>
                <div class="code-block">
                    <pre><code class="language-java">private static void test(String str){
    Optional
        .ofNullable(str)   //将传入的对象包装进Optional中
        .ifPresent(s -&gt; System.out.println("字符串长度为："+s.length()));
        // 如果不为空，则执行Consumer实现
}</code></pre>
                </div>
                <p><strong>Optional的常用方法</strong>：</p>
                <div class="code-block">
                    <pre><code class="language-java">// get方法：获取被包装的对象（为空会抛出异常）
String s = Optional.ofNullable(str).get();

// orElse方法：为空时返回备选方案
String s = Optional.ofNullable(str).orElse("我是为null的情况备选方案");

// map方法：转换为另一种类型
Integer i = Optional.ofNullable(str)
    .map(String::length)
    .orElse(-1);</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>数据结构基础</h2>
                <p>在计算机科学中，数据结构是一种数据组织、管理和存储的格式</p>
                <ul>
                    <li>帮助实现对数据高效的访问和修改</li>
                    <li>体现了数据值之间的关系</li>
                    <li>支持特定的操作和函数</li>
                </ul>
                <p><strong>线性表</strong>：由同一类型的数据元素构成的有序序列</p>
                <ul>
                    <li><strong>获取指定位置上的元素</strong></li>
                    <li><strong>插入元素</strong>：在指定位置插入</li>
                    <li><strong>删除元素</strong>：删除指定位置的元素</li>
                    <li><strong>获取长度</strong>：返回线性表的长度</li>
                </ul>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>线性表：顺序表</h2>
                <p>基于数组实现的线性表，使用顺序存储</p>
                <div class="code-block">
                    <pre><code class="language-java">public class ArrayList&lt;E&gt; {
    int capacity = 10;   //当前顺序表的容量
    int size = 0;        //当前已经存放的元素数量
    private Object[] array = new Object[capacity];
}</code></pre>
                </div>
                <p><strong>插入操作</strong>：需要将插入位置后的元素向后移动</p>
                <p><strong>删除操作</strong>：需要将删除位置后的元素向前移动</p>
                <p><strong>特点</strong>：</p>
                <ul>
                    <li>随机访问效率高（O(1)）</li>
                    <li>插入删除效率低（O(n)）</li>
                    <li>需要连续的内存空间</li>
                </ul>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>顺序表实现示例</h2>
                <div class="code-block">
                    <pre><code class="language-java">public void add(E element, int index){
    if(index &lt; 0 || index &gt; size)
        throw new IndexOutOfBoundsException("插入位置非法");

    // 容量检查和扩容
    if(capacity == size) {
        int newCapacity = capacity + (capacity &gt;&gt; 1);
        Object[] newArray = new Object[newCapacity];
        System.arraycopy(array, 0, newArray, 0, size);
        array = newArray;
        capacity = newCapacity;
    }

    // 元素后移
    for (int i = size; i &gt; index; i--)
        array[i] = array[i - 1];

    array[index] = element;
    size++;
}</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>线性表：链表</h2>
                <p>通过指针连接各个分散的结点，形成链状结构</p>
                <div class="code-block">
                    <pre><code class="language-java">public class LinkedList&lt;E&gt; {
    private final Node&lt;E&gt; head = new Node&lt;&gt;(null);
    private int size = 0;

    private static class Node&lt;E&gt; {
        E element;        //存放元素
        Node&lt;E&gt; next;    //指向下一个结点

        public Node(E element) {
            this.element = element;
        }
    }
}</code></pre>
                </div>
                <p><strong>特点</strong>：</p>
                <ul>
                    <li>不需要连续的内存空间</li>
                    <li>插入删除效率高（O(1)）</li>
                    <li>随机访问效率低（O(n)）</li>
                </ul>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>链表插入操作</h2>
                <div class="code-block">
                    <pre><code class="language-java">public void add(E element, int index){
    if(index &lt; 0 || index &gt; size)
        throw new IndexOutOfBoundsException("插入位置非法");

    Node&lt;E&gt; prev = head;
    for (int i = 0; i &lt; index; i++)
        prev = prev.next;

    Node&lt;E&gt; node = new Node&lt;&gt;(element);
    node.next = prev.next;   //新结点指向原本位置的结点
    prev.next = node;       //前驱结点指向新结点
    size++;
}</code></pre>
                </div>
                <p class="conclusion">链表操作的关键在于正确维护结点之间的指针关系。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>线性表：栈</h2>
                <p>特殊的线性表，只能在表尾进行插入和删除操作（FILO）</p>
                <div class="code-block">
                    <pre><code class="language-java">public class LinkedStack&lt;E&gt; {
    private final Node&lt;E&gt; head = new Node&lt;&gt;(null);

    // 入栈操作
    public void push(E element){
        Node&lt;E&gt; node = new Node&lt;&gt;(element);
        node.next = head.next;    //新结点指向栈顶
        head.next = node;         //头结点指向新结点
    }

    // 出栈操作
    public E pop(){
        if(head.next == null)
            throw new NoSuchElementException("栈为空");
        E e = head.next.element;
        head.next = head.next.next;
        return e;
    }
}</code></pre>
                </div>
                <p class="conclusion">栈的特点是后进先出，就像往箱子里放书一样。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>线性表：队列</h2>
                <p>特殊的线性表，元素只能从队尾进入，从队首出去（FIFO）</p>
                <div class="code-block">
                    <pre><code class="language-java">public class LinkedQueue&lt;E&gt; {
    private final Node&lt;E&gt; head = new Node&lt;&gt;(null);
    private Node&lt;E&gt; last = head;

    // 入队操作
    public void offer(E element){
        Node&lt;E&gt; node = new Node&lt;&gt;(element);
        last.next = node;
        last = node;
    }

    // 出队操作
    public E poll(){
        if(head.next == null)
            throw new NoSuchElementException("队列为空");
        E e = head.next.element;
        head.next = head.next.next;
        return e;
    }
}</code></pre>
                </div>
                <p class="conclusion">队列的特点是先进先出，就像排队买票一样。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>树：二叉树</h2>
                <p>度最大为2的特殊树结构，每个结点最多有两个子结点</p>
                <div class="code-block">
                    <pre><code class="language-java">public class TreeNode&lt;E&gt; {
    public E element;
    public TreeNode&lt;E&gt; left, right;

    public TreeNode(E element){
        this.element = element;
    }
}</code></pre>
                </div>
                <p><strong>特殊二叉树</strong>：</p>
                <ul>
                    <li><strong>满二叉树</strong>：所有结点度都是0或2，叶子结点在同一层</li>
                    <li><strong>完全二叉树</strong>：最后一层可能有空缺，叶子结点从左往右排列</li>
                    <li><strong>二叉查找树</strong>：左子树值&lt;根结点值&lt;右子树值</li>
                </ul>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>二叉树遍历</h2>
                <p>二叉树有四种遍历方式</p>
                <ul>
                    <li><strong>前序遍历</strong>：根节点 → 左子树 → 右子树</li>
                    <li><strong>中序遍历</strong>：左子树 → 根节点 → 右子树</li>
                    <li><strong>后序遍历</strong>：左子树 → 右子树 → 根节点</li>
                    <li><strong>层序遍历</strong>：按层次从上到下，从左到右</li>
                </ul>
                <div class="code-block">
                    <pre><code class="language-java">// 前序遍历
private static &lt;T&gt; void preOrder(TreeNode&lt;T&gt; root){
    if(root == null) return;
    System.out.print(root.element + " ");
    preOrder(root.left);
    preOrder(root.right);
}</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>平衡二叉树</h2>
                <p>为了避免二叉查找树退化成链表，需要保持树的平衡</p>
                <ul>
                    <li><strong>AVL树</strong>：任意结点左右子树高度差不超过1</li>
                    <li><strong>红黑树</strong>：通过颜色规则和旋转操作保持平衡</li>
                </ul>
                <p><strong>平衡因子</strong>：左子树高度 - 右子树高度</p>
                <p><strong>失衡类型与调整</strong>：</p>
                <ul>
                    <li><strong>LL型</strong>：右旋调整</li>
                    <li><strong>RR型</strong>：左旋调整</li>
                    <li><strong>LR型</strong>：先左旋后右旋</li>
                    <li><strong>RL型</strong>：先右旋后左旋</li>
                </ul>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>哈希表</h2>
                <p>通过哈希函数将关键字映射到存储位置的数据结构</p>
                <div class="code-block">
                    <pre><code class="language-java">public class HashTable&lt;E&gt; {
    private final int TABLE_SIZE = 10;
    private final Node&lt;E&gt;[] TABLE = new Node[TABLE_SIZE];

    public void insert(E element){
        int index = hash(element);
        Node&lt;E&gt; prev = TABLE[index];
        while (prev.next != null)
            prev = prev.next;
        prev.next = new Node&lt;&gt;(element);
    }

    private int hash(Object object){
        int hashCode = object.hashCode();
        return hashCode % TABLE_SIZE;
    }
}</code></pre>
                </div>
                <p><strong>哈希冲突解决方案</strong>：链地址法，将冲突元素连接成链表</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>实战练习：反转链表</h2>
                <p>LeetCode 206：给你单链表的头节点head，请你反转链表，并返回反转后的链表</p>
                <div class="code-block">
                    <pre><code class="language-java">// 示例
// 输入：head = [1,2,3,4,5]
// 输出：[5,4,3,2,1]

// 思路：需要修改每个节点的指针指向
public ListNode reverseList(ListNode head) {
    ListNode prev = null;
    ListNode current = head;

    while (current != null) {
        ListNode next = current.next;  // 保存下一个节点
        current.next = prev;          // 反转指针
        prev = current;               // prev向后移动
        current = next;              // current向后移动
    }

    return prev;  // prev就是新的头节点
}</code></pre>
                </div>
                <p class="conclusion">关键在于如何修改每个节点的指针指向，使用迭代法比递归法更高效。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>实战练习：括号匹配问题</h2>
                <p>LeetCode 20：判断字符串中的括号是否有效配对</p>
                <div class="code-block">
                    <pre><code class="language-java">// 示例
// 输入：s = "{[]}"  输出：true
// 输入：s = "([)]"  输出：false

public boolean isValid(String s) {
    Stack&lt;Character&gt; stack = new Stack&lt;&gt;();

    for (char c : s.toCharArray()) {
        if (c == '(' || c == '[' || c == '{') {
            stack.push(c);  // 左括号入栈
        } else {
            if (stack.isEmpty()) return false;  // 栈空则无效

            char top = stack.pop();
            // 检查是否匹配
            if ((c == ')' && top != '(') ||
                (c == ']' && top != '[') ||
                (c == '}' && top != '{')) {
                return false;
            }
        }
    }

    return stack.isEmpty();  // 栈空说明全部匹配
}</code></pre>
                </div>
                <p class="conclusion">利用栈的后进先出特性，完美解决括号匹配问题。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>实战练习：实现计算器</h2>
                <p>输入一个计算公式（含加减乘除运算符，没有负数但是有小数）得到结果</p>
                <div class="code-block">
                    <pre><code class="language-java">public class Calculator {
    public static double calculate(String expression) {
        // 使用两个栈：一个存数字，一个存运算符
        Stack&lt;Double&gt; numbers = new Stack&lt;&gt;();
        Stack&lt;Character&gt; operators = new Stack&lt;&gt;();

        for (int i = 0; i < expression.length(); i++) {
            char c = expression.charAt(i);

            if (Character.isDigit(c) || c == '.') {
                // 解析数字（包括小数）
                StringBuilder sb = new StringBuilder();
                while (i < expression.length() &&
                       (Character.isDigit(expression.charAt(i)) || expression.charAt(i) == '.')) {
                    sb.append(expression.charAt(i++));
                }
                i--;
                numbers.push(Double.parseDouble(sb.toString()));
            } else if (c == '+' || c == '-' || c == '*' || c == '/') {
                // 处理运算符优先级
                while (!operators.isEmpty() &&
                       precedence(operators.peek()) >= precedence(c)) {
                    applyOperator(numbers, operators);
                }
                operators.push(c);
            }
        }

        // 处理剩余运算符
        while (!operators.isEmpty()) {
            applyOperator(numbers, operators);
        }

        return numbers.pop();
    }
}</code></pre>
                </div>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>计算器实现（续）</h2>
                <div class="code-block">
                    <pre><code class="language-java">    private static int precedence(char op) {
        if (op == '+' || op == '-') return 1;
        if (op == '*' || op == '/') return 2;
        return 0;
    }

    private static void applyOperator(Stack&lt;Double&gt; numbers,
                                     Stack&lt;Character&gt; operators) {
        char op = operators.pop();
        double b = numbers.pop();
        double a = numbers.pop();

        switch (op) {
            case '+': numbers.push(a + b); break;
            case '-': numbers.push(a - b); break;
            case '*': numbers.push(a * b); break;
            case '/': numbers.push(a / b); break;
        }
    }

    public static void main(String[] args) {
        String expression = "1+4*3/1.321";
        double result = calculate(expression);
        System.out.println("结果: " + result);  // 输出: 2.2
    }
}</code></pre>
                </div>
                <p class="conclusion">使用栈结构能够很好地处理运算符优先级，实现基本的计算器功能。</p>
            </div>
        </section>

        <section class="slide">
            <div class="slide-content">
                <h2>总结</h2>
                <div class="summary-points">
                    <h3>从问题到泛型</h3>
                    <ul>
                        <li>Object类型存储的缺陷：类型不安全，需要强制转换</li>
                        <li>泛型的解决方案：编译时类型检查，运行时安全</li>
                        <li>泛型类、泛型方法、泛型接口的实际应用</li>
                        <li>通配符？extends和？super的使用场景</li>
                    </ul>

                    <h3>泛型的深入理解</h3>
                    <ul>
                        <li>类型擦除机制：泛型在编译后的处理方式</li>
                        <li>桥接方法：泛型重写的技术实现</li>
                        <li>泛型数组创建的限制和原因</li>
                        <li>泛型在集合类框架中的重要作用</li>
                    </ul>

                    <h3>数据结构基础</h3>
                    <ul>
                        <li>为什么学习数据结构：为理解集合类底层实现</li>
                        <li>线性表：数组的局限和链表的优势</li>
                        <li>栈和队列：特定场景下的最优解</li>
                        <li>树和哈希表：高效查找的数据结构基础</li>
                    </ul>
                </div>
                <p class="conclusion">泛型解决了类型安全问题，数据结构提供了高效的组织方式，两者结合构成了Java集合类框架的理论基础。</p>
            </div>
        </section>

        <div class="progress-bar-container">
            <div id="progress-bar"></div>
        </div>
        <div class="controls">
            <button id="prevBtn">上一页</button>
            <span id="slide-counter">1 / X</span>
            <button id="nextBtn">下一页</button>
        </div>
    </main>

    <script src="./js/animation.js"></script>
    <script src="./js/ppt.js"></script>
    <script src="../prism/prism.js"></script>
    <script src="../prism/prism-autoloader.min.js"></script>
    <script src="./js/nav.js"></script>
</body>

</html>